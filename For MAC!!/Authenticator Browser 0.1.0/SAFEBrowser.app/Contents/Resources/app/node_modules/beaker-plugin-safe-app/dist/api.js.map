{"version":3,"file":"api.js","sources":["webpack:///webpack/bootstrap c6ed48362a591459d3ba","webpack:///./src/api/helpers.js","webpack:///./src/api/app.js","webpack:///./src/api/cipher_opt.js","webpack:///./src/api/crypto.js","webpack:///./src/api/crypto_key_pair.js","webpack:///./src/api/crypto_public_encryption_key.js","webpack:///./src/api/crypto_secret_encryption_key.js","webpack:///./src/api/crypto_sign_key.js","webpack:///./src/api/emulations/nfs.js","webpack:///./src/api/immutable_data.js","webpack:///./src/api/mutable_data.js","webpack:///./src/api/mutable_data_entries.js","webpack:///./src/api/mutable_data_keys.js","webpack:///./src/api/mutable_data_mutation.js","webpack:///./src/api/mutable_data_permissions.js","webpack:///./src/api/mutable_data_permissions_set.js","webpack:///./src/api/mutable_data_values.js","webpack:///./src/api/index.js","webpack:///./src/api/ipc.js","webpack:///external \"crypto\"","webpack:///external \"electron\"","webpack:///external \"safe-app\"","webpack:///external \"stream\""],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 17);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c6ed48362a591459d3ba","const crypto = require('crypto'); // electron deps will be available inside browser\nconst { Readable } = require('stream');\n\nconst handles = new Map();\n\nexport const genRandomString = () => (crypto.randomBytes(32).toString('hex'));\n\nexport const genHandle = (obj) => {\n  const randHandle = genRandomString();\n  handles.set(randHandle, obj);\n  return randHandle;\n};\n\nexport const getObj = (handle) => {\n  return new Promise((resolve, reject) => {\n    const obj = handles.get(handle);\n    if (obj) {\n      return resolve(obj);\n    }\n    return reject(new Error('Invalid handle'));\n  });\n};\n\nexport const freeObj = (handle) => {\n  handles.delete(handle);\n};\n\nexport const forEachHelper = (appToken, containerHandle, sendHandles) => {\n  var readable = new Readable({ objectMode: true, read() {} })\n  getObj(appToken)\n    .then(() => getObj(containerHandle))\n    .then((container) => container.forEach((arg1, arg2) => {\n        setImmediate(() => {\n          if (sendHandles) {\n            arg1 = genHandle(arg1);\n          }\n          let args = [arg1];\n          if (arg2) {\n            if (sendHandles) {\n              arg2 = genHandle(arg2);\n            }\n            args.push(arg2);\n          }\n          readable.push(args)\n        })\n      })\n      .then(() => {\n        setImmediate(() => {\n          readable.push(null)\n        })\n      })\n    );\n  return readable;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/helpers.js\n// module id = 0\n// module chunks = 0","const safeApp = require('safe-app');\nconst ipc = require('./ipc');\nconst { genHandle, getObj, freeObj } = require('./helpers');\n\nmodule.exports.manifest = {\n  initialise: 'promise',\n  connect: 'promise',\n  authorise: 'promise',\n  connectAuthorised: 'promise',\n  webFetch: 'promise',\n  isRegistered: 'promise',\n  canAccessContainer: 'promise',\n  refreshContainersPermissions: 'promise',\n  getContainersNames: 'promise',\n  getHomeContainer: 'promise',\n  getContainer: 'promise',\n  getPubSignKey: 'promise',\n  getEncKey: 'promise',\n  getSignKeyFromRaw: 'promise',\n  getEncKeyKeyFromRaw: 'promise',\n  free: 'sync'\n};\n\n/**\n * Create a new SAFEApp instance without a connection to the network\n * @returns {Promise<SAFEAppToken>} new instace\n */\nmodule.exports.initialise = (appInfo) => {\n  if (this && this.sender) {\n    const wholeUrl = this.sender.getURL();\n    appInfo.scope = wholeUrl;\n  } else {\n    appInfo.scope = null;\n  }\n\n  return safeApp.initializeApp(appInfo)\n    .then(genHandle);\n};\n\n/**\n * Create a new, unregistered Session (read-only)\n * @returns {Promise<SAFEAppToken>} same instace\n */\nmodule.exports.connect = (appToken) => {\n  return getObj(appToken)\n    .then((app) => app.auth.connectUnregistered())\n    .then(() => appToken);\n};\n\n/**\n * With the options object it can be opt for getting a container\n * for the app itself: opts.own_container=true\n * @returns {Promise<AuthURI>} auth granted URI\n */\nmodule.exports.authorise = (appToken, permissions, options) => {\n  return new Promise((resolve, reject) => {\n    getObj(appToken)\n      .then((app) => app.auth.genAuthUri(permissions, options)\n        .then((authReq) => ipc.sendAuthReq(authReq, (err, res) => {\n          if (err) {\n            return reject(new Error('Unable to authorise the application: ', err)); // TODO send Error in specific\n          }\n          return resolve(res);\n        })))\n      .catch(reject);\n  });\n};\n\n/**\n * Create a new, registered Session (read-write)\n * @returns {Promise<SAFEAppToken>} same instace\n */\nmodule.exports.connectAuthorised = (appToken, authUri) => {\n  return getObj(appToken)\n    .then((app) => app.auth.loginFromURI(authUri))\n    .then((connectedApp) => appToken);\n};\n\n/**\n * Authorise container request\n * @returns {Promise<AuthURI>} auth granted URI\n */\nmodule.exports.authoriseContainer = (appToken, permissions) => {\n  return new Promise((resolve, reject) => {\n    getObj(appToken)\n      .then((app) => app.auth.genContainerAuthUri(permissions)\n        .then((authReq) => ipc.sendAuthReq(authReq, (err, res) => {\n          if (err) {\n            return reject(new Error('Unable to authorise the application: ', err)); // TODO send Error in specific\n          }\n          return resolve(res);\n        })))\n      .catch(reject);\n  });\n};\n\nmodule.exports.webFetch = (appToken, url) => {\n  return getObj(appToken)\n    .then((app) => app.webFetch(url)\n      .then((f) => app.immutableData.fetch(f.dataMapName))\n      .then((i) => i.read())\n    );\n};\n\n/**\n * Whether or not this is a registered/authenticated\n * session.\n *\n * @param {String} appToken - the application token\n * @returns {Boolean} true if this is an authenticated session\n **/\nmodule.exports.isRegistered = (appToken) => {\n  return getObj(appToken)\n    .then((app) => app.auth.registered);\n};\n\n/**\n * Whether or not this session has specifc permission access of a given\n * container.\n * @param {String} appToken - the application token\n * @arg {String} name  name of the container, e.g. `_public`\n * @arg {(String||Array<String>)} [permissions=['Read']] permissions to check for\n * @returns {Promise<Boolean>}\n **/\nmodule.exports.canAccessContainer = (appToken, name, permissions) => {\n  return getObj(appToken)\n    .then((app) => app.auth.canAccessContainer(name, permissions));\n};\n\n/**\n * Refresh permissions for accessible containers from the network. Useful when\n * you just connected or received a response from the authenticator in the IPC protocol.\n * @param {String} appToken - the application token\n */\nmodule.exports.refreshContainersPermissions = (appToken) => {\n  return getObj(appToken)\n    .then((app) => app.auth.refreshContainersPermissions());\n};\n\n/**\n * Get the names of all containers found.\n * @param {String} appToken - the application token\n * @returns {Promise<[String]>} list of containers names\n */\nmodule.exports.getContainersNames = (appToken) => {\n  return getObj(appToken)\n    .then((app) => app.auth.getContainersNames())\n    .then(genHandle);\n};\n\n/**\n * Get the MData for the apps own container generated by Authenticator\n * @param appToken\n * @return {*}\n */\nmodule.exports.getHomeContainer = (appToken) => {\n  return getObj(appToken)\n    .then((app) => app.auth.getHomeContainer())\n    .then(genHandle);\n};\n\n/**\n * Lookup and return the information necessary to access a container.\n * @param {String} appToken - the application token\n * @arg name {String} name of the container, e.g. `'_public'`\n * @returns {Promise<MutableDataHandle>} the handle for the Mutable Data behind it\n */\nmodule.exports.getContainer = (appToken, name) => {\n  return getObj(appToken)\n    .then((app) => app.auth.getContainer(name))\n    .then(genHandle);\n};\n\n/**\n * Get the public signing key of this session\n * @param {String} appToken - the application token\n * @returns {Promise<SignKeyHandle>}\n **/\nmodule.exports.getPubSignKey = (appToken) => {\n  return getObj(appToken)\n    .then((app) => app.auth.getPubSignKey())\n    .then(genHandle);\n};\n\n/**\n * Get the public encryption key of this session\n * @param {String} appToken - the application token\n * @returns {Promise<EncKeyHandle>}\n **/\nmodule.exports.getEncKey = (appToken) => {\n  return getObj(appToken)\n    .then((app) => app.auth.getEncKey())\n    .then(genHandle);\n};\n\n/**\n * Interprete the SignKey from a given raw string\n * @param {String} appToken - the application token\n * @param {String} raw\n * @returns {Promise<SignKeyHandle>}\n **/\nmodule.exports.getSignKeyFromRaw = (appToken, raw) => {\n  return getObj(appToken)\n    .then((app) => app.auth.getSignKeyFromRaw(raw))\n    .then(genHandle);\n};\n\n/**\n * Interprete the encryption Key from a given raw string\n * @param {String} appToken - the application token\n * @arg {String} raw\n * @returns {Promise<EncKeyHandle>}\n **/\nmodule.exports.getEncKeyKeyFromRaw = (appToken, raw) => {\n  return getObj(appToken)\n    .then((app) => app.auth.getEncKeyKeyFromRaw(raw))\n    .then(genHandle);\n};\n\n/**\n * Free the SAFEApp instance from memory\n * @param {String} appToken - the application token\n */\nmodule.exports.free = (appToken) => freeObj(appToken);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/app.js\n// module id = 1\n// module chunks = 0","const { genHandle, getObj, freeObj } = require('./helpers');\n\nmodule.exports.manifest = {\n  newPlainText: 'promise',\n  newSymmetric: 'promise',\n  newAsymmetric: 'promise',\n  free: 'sync'\n};\n\n/**\n * Create a PlainText Cipher Opt\n * @param {String} appToken - the application token\n * @returns {CipherOptHandle}\n **/\nmodule.exports.newPlainText = (appToken) => {\n  return getObj(appToken)\n    .then((app) => app.cipherOpt.newPlainText())\n    .then(genHandle);\n};\n\n/**\n * Create a new Symmetric Cipher\n * @param {String} appToken - the application token\n * @returns {CipherOptHandle}\n **/\nmodule.exports.newSymmetric = (appToken) => {\n  return getObj(appToken)\n    .then((app) => app.cipherOpt.newSymmetric())\n    .then(genHandle);\n};\n\n/**\n * Create a new Asymmetric Cipher for the given key\n * @param {String} appToken - the application token\n * @param {EncKeyHandle} keyHandle\n * @returns {CipherOptHandle}\n **/\nmodule.exports.newAsymmetric = (appToken, keyHandle) => {\n  return getObj(appToken)\n    .then((app) => getObj(keyHandle)\n      .then((key) => app.cipherOpt.newAsymmetric(key))\n      .then(genHandle)\n    );\n};\n\n/**\n * Free the CipherOpt instance from memory\n * @param {String} cipherOptHandle - the cipher opt handle\n */\nmodule.exports.free = (cipherOptHandle) => freeObj(cipherOptHandle);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/cipher_opt.js\n// module id = 2\n// module chunks = 0","const { genHandle, getObj } = require('./helpers');\n\nmodule.exports.manifest = {\n  sha3Hash: 'promise',\n  getAppPubSignKey: 'promise',\n  getAppPubEncKey: 'promise',\n  generateEncKeyPair: 'promise',\n  getSignKeyFromRaw: 'promise',\n  pubEncKeyKeyFromRaw: 'promise'\n};\n\n/**\n * Hash the given input with SHA3 Hash\n * @param appToken - the application token\n * @param inpt - input string\n * @return {Promise<Buffer>}\n */\nmodule.exports.sha3Hash = (appToken, inpt) => {\n  return getObj(appToken)\n    .then((app) => app.crypto.sha3Hash(inpt));\n};\n\n/**\n * Get the public signing key\n * @param appToken - the application token\n * @return {Promise<SignKeyHandle>}\n */\nmodule.exports.getAppPubSignKey = (appToken) => {\n  return getObj(appToken)\n    .then((app) => app.crypto.getAppPubSignKey())\n    .then(genHandle);\n};\n\n/**\n * Get the public encryption key\n * @param appToken - the application token\n * @return {Promise<PubEncKeyHandle>}\n */\nmodule.exports.getAppPubEncKey = (appToken) => {\n  return getObj(appToken)\n    .then((app) => app.crypto.getAppPubEncKey())\n    .then(genHandle);\n};\n\n/**\n * Generate a new Asymmetric EncryptionKeyPair\n * @param appToken - the application token\n * @return {Promise<KeyPairHandle>}\n */\nmodule.exports.generateEncKeyPair = (appToken) => {\n  return getObj(appToken)\n    .then((app) => app.crypto.generateEncKeyPair())\n    .then(genHandle);\n};\n\n/**\n * Interpret the SignKey from a given raw string\n * @param appToken - the application token\n * @param raw - raw input string\n * @return {Promise<SignKeyHandle>}\n */\nmodule.exports.getSignKeyFromRaw = (appToken, raw) => {\n  return getObj(appToken)\n    .then((app) => app.crypto.getSignKeyFromRaw(raw))\n    .then(genHandle);\n};\n\n/**\n * Interprete the encryption Key from a given raw string\n * @param appToken - the application token\n * @param raw - raw input string\n * @return {Promise<PubEncKeyHandle>}\n */\nmodule.exports.pubEncKeyKeyFromRaw = (appToken, raw) => {\n  return getObj(appToken)\n    .then((app) => app.crypto.pubEncKeyKeyFromRaw(raw))\n    .then(genHandle);\n};\n\n/**\n * Interpret the secret encryption Key from a given raw string\n * @param appToken - the application token\n * @param raw - raw input string\n * @return {Promise<SecEncKey>}\n */\nmodule.exports.secEncKeyKeyFromRaw = (appToken, raw) => {\n  return getObj(appToken)\n    .then((app) => app.crypto.secEncKeyKeyFromRaw(raw))\n    .then(genHandle);\n};\n\n/**\n * Generate a new Asymmetric EncryptionKeyPair from raw secret and public keys\n * @param appToken - the application token\n * @param rawPublicKey\n * @param rawSecretKey\n * @return {Promise<KeyPair>}\n */\nmodule.exports.generateEncKeyPairFromRaw = (appToken, rawPublicKey, rawSecretKey) => {\n  return getObj(appToken)\n    .then((app) => app.crypto.generateEncKeyPairFromRaw(rawPublicKey, rawSecretKey))\n    .then(genHandle);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/crypto.js\n// module id = 3\n// module chunks = 0","const { genHandle, getObj, freeObj } = require('./helpers');\n\nmodule.exports.manifest = {\n  getPubEncKey: 'promise',\n  getSecEncKey: 'promise',\n  decryptSealed: 'promise',\n  free: 'sync'\n};\n\n/**\n * Get the Public Encryption key instance of this keypair\n * @param appToken - application token\n * @param keyPairHandle - keyPair handle\n * @return {Promise<PubEncKey>}\n */\nmodule.exports.getPubEncKey = (appToken, keyPairHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(keyPairHandle))\n    .then((keyPair) => genHandle(keyPair.pubEncKey));\n};\n\n/**\n * Get the Secrect Encryption key instance of this keypair\n * @param appToken - application token\n * @param keyPairHandle - keyPair handle\n * @return {Promise<SecEncKey>}\n */\nmodule.exports.getSecEncKey = (appToken, keyPairHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(keyPairHandle))\n    .then((keyPair) => genHandle(keyPair.secEncKey));\n};\n\n/**\n * Decrypt the given ciphertext with a seal (buffer or string) using the private and public key\n * @param appToken - application token\n * @param keyPairHandle - keyPair handle\n * @param cipher\n * @return {Promise<Buffer>}\n */\nmodule.exports.decryptSealed = (appToken, keyPairHandle, cipher) => {\n  return getObj(appToken)\n    .then(() => getObj(keyPairHandle))\n    .then((keyPair) => keyPair.decryptSealed(cipher));\n};\n\n/**\n * Free the KeyPair instance from memory\n * @param {String} keyPairHandle - the KeyPair handle\n */\nmodule.exports.free = (keyPairHandle) => freeObj(keyPairHandle);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/crypto_key_pair.js\n// module id = 4\n// module chunks = 0","const { getObj, freeObj } = require('./helpers');\n\nmodule.exports.manifest = {\n  getRaw: 'promise',\n  encryptSealed: 'promise',\n  encrypt: 'promise',\n  free: 'sync'\n};\n\n/**\n * Generate raw string copy of encryption key\n * @param appToken - application token\n * @param pubEncKeyHandle - public encrypted key handle\n * @return {Promise<String>}\n */\nmodule.exports.getRaw = (appToken, pubEncKeyHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(pubEncKeyHandle))\n    .then((pubEncKey) => pubEncKey.getRaw());\n};\n\n/**\n * Encrypt the input (buffer or string) using the private and public key with a seal\n * @param appToken - application token\n * @param pubEncKeyHandle - public encrypted key handle\n * @param str\n * @return {Promise<Buffer>}\n */\nmodule.exports.encryptSealed = (appToken, pubEncKeyHandle, str) => {\n  return getObj(appToken)\n    .then(() => getObj(pubEncKeyHandle))\n    .then((pubEncKey) => pubEncKey.encryptSealed(str));\n};\n\n/**\n * Encrypt the input (buffer or string) using the private and public key and the given privateKey\n * @param appToken - application token\n * @param pubEncKeyHandle - public encrypted key handle\n * @param str\n * @param secretKey\n * @return {Promise<Buffer>}\n */\nmodule.exports.encrypt = (appToken, pubEncKeyHandle, str, secretKey) => {\n  return getObj(appToken)\n    .then(() => getObj(pubEncKeyHandle))\n    .then((pubEncKey) => pubEncKey.encrypt(str, secretKey));\n};\n\n/**\n * Free the PubEncKey instance from memory\n * @param {String} pubEncKeyHandle - the public encryption key handle\n */\nmodule.exports.free = (pubEncKeyHandle) => freeObj(pubEncKeyHandle);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/crypto_public_encryption_key.js\n// module id = 5\n// module chunks = 0","const { getObj, freeObj } = require('./helpers');\n\nmodule.exports.manifest = {\n  getRaw: 'promise',\n  decrypt: 'promise',\n  free: 'sync'\n};\n\n/**\n * Generate raw string copy of encryption key\n * @param appToken - application token\n * @param secEncKeyHandle - secret encrypted key handle\n * @return {Promise<String>}\n */\nmodule.exports.getRaw = (appToken, secEncKeyHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(secEncKeyHandle))\n    .then((secEncKey) => secEncKey.getRaw());\n};\n\n/**\n * Decrypt the given ciphertext (buffer or string) using the private and public key\n * @param appToken - application token\n * @param secEncKeyHandle - secret encrypted key handle\n * @param cipher\n * @param theirPubKey\n * @return {Promise<Buffer>}\n */\nmodule.exports.decrypt = (appToken, secEncKeyHandle, cipher, theirPubKey) => {\n  return getObj(appToken)\n    .then(() => getObj(secEncKeyHandle))\n    .then((secEncKey) => secEncKey.decrypt(cipher, theirPubKey));\n};\n\n/**\n * Free the SecEncKey instance from memory\n * @param {String} secEncKeyHandle - the secret encryption key handle\n */\nmodule.exports.free = (secEncKeyHandle) => freeObj(secEncKeyHandle);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/crypto_secret_encryption_key.js\n// module id = 6\n// module chunks = 0","const { getObj, freeObj } = require('./helpers');\n\nmodule.exports.manifest = {\n  getRaw: 'promise',\n  free: 'sync'\n};\n\n/**\n * Generate raw string copy of encryption key\n * @param appToken - application token\n * @param signKeyHandle - public encrypted key handle\n * @return {Promise<String>}\n */\nmodule.exports.getRaw = (appToken, signKeyHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(signKeyHandle))\n    .then((signKey) => signKey.getRaw());\n};\n\n/**\n * Free the SignKey instance from memory\n * @param {String} signKeyHandle - the SignKey handle\n */\nmodule.exports.free = (signKeyHandle) => freeObj(signKeyHandle);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/crypto_sign_key.js\n// module id = 7\n// module chunks = 0","const { genHandle, getObj, freeObj } = require('../helpers');\n\nmodule.exports.manifest = {\n  create: 'promise',\n  fetch: 'promise',\n  insert: 'promise',\n  update: 'promise',\n  getFileMeta: 'promise',\n  free: 'sync'\n};\n\nmodule.exports.create = (appToken, nfsHandle, content) => {\n  return getObj(appToken)\n    .then(() => getObj(nfsHandle))\n    .then((nfs) => nfs.create(content))\n    .then(genHandle);\n};\n\nmodule.exports.fetch = (appToken, nfsHandle, fileName) => {\n  return getObj(appToken)\n    .then(() => getObj(nfsHandle))\n    .then((nfs) => nfs.fetch(fileName))\n    .then(genHandle);\n};\n\nmodule.exports.insert = (appToken, nfsHandle, fileHandle, fileName) => {\n  return getObj(appToken)\n    .then(() => getObj(nfsHandle))\n    .then((nfs) => {\n      return getObj(fileHandle).then((file) => nfs.insert(fileName, file));\n    })\n    .then(() => fileHandle);\n};\n\nmodule.exports.update = (appToken, nfsHandle, fileHandle, fileName, version) => {\n  return getObj(appToken)\n    .then(() => getObj(nfsHandle))\n    .then((nfs) => {\n      return getObj(fileHandle).then((file) => nfs.update(fileName, file, version));\n    })\n    .then(() => fileHandle);\n};\n\nmodule.exports.getFileMeta = (fileHandle) => {\n  return getObj(fileHandle).then((file) => (\n    {\n      dataMapName: file.dataMapName,\n      created: file.created,\n      modified: file.modified,\n      size: file.size,\n      version: file.version\n    }\n  ))\n};\n\n/**\n * Free the File instance from memory\n * @param {String} fileHandle - the File handle\n */\nmodule.exports.free = (fileHandle) => freeObj(fileHandle);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/emulations/nfs.js\n// module id = 8\n// module chunks = 0","const { genHandle, getObj, freeObj } = require('./helpers');\n\nmodule.exports.manifest = {\n  create: 'promise',\n  fetch: 'promise',\n  write: 'promise',\n  closeWriter: 'promise',\n  read: 'promise',\n  size: 'promise',\n  closeReader: 'promise',\n};\n\n/**\n * Create a new ImmutableData Writer\n * @param {String} appToken - the application token\n * @returns {Promise<Handle>} - the ImmutableData Writer Handle\n **/\nmodule.exports.create = (appToken) => {\n  return getObj(appToken)\n    .then((app) => app.immutableData.create())\n    .then(genHandle);\n};\n\n/**\n * Look up an existing Immutable Data for the given address\n * @param {String} appToken - the application token\n * @param {Buffer} address - the XorName on the network\n * @returns {Promise<Handle>} - the ImmutableData Reader Handle\n **/\nmodule.exports.fetch = (appToken, address) => {\n  return getObj(appToken)\n    .then((app) => app.immutableData.fetch(address))\n    .then(genHandle);\n};\n\n/**\n * Append the given data to immutable Data.\n *\n * @param {String} appToken - the application token\n * @param {Handle} writerHandle - the writer handle\n * @param {String} string\n * @returns {Promise<()>}\n **/\nmodule.exports.write = (appToken, writerHandle, string) => {\n  return getObj(appToken)\n    .then(() => getObj(writerHandle))\n    .then((writer) => writer.write(string));\n};\n\n/**\n * Close and write the immutable Data to the network.\n * @param {String} appToken - the application token\n * @param {Handle} writerHandle - the writer handle\n * @returns {Promise<String>} the address to the data once written to the network\n **/\nmodule.exports.closeWriter = (appToken, writerHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(writerHandle))\n    .then((writer) => writer.close())\n    .then((addr) => {\n      freeObj(writerHandle);\n      return addr;\n    });\n};\n\n/**\n * Read the given amount of bytes from the network\n * @param {String} appToken - the application token\n * @param {Handle} readerHandle - the reader handle\n * @param {Object=} options\n * @param {Number} [options.offset=0] start position\n * @param {Number} [options.end=size] end position or end of data\n **/\nmodule.exports.read = (appToken, readerHandle, options) => {\n  return getObj(appToken)\n    .then(() => getObj(readerHandle))\n    .then((reader) => reader.read(options));\n};\n\n/**\n * The size of the mutable data on the network\n * @param {String} appToken - the application token\n * @param {Handle} readerHandle - the reader handle\n * @returns {Promise<Number>} length in bytes\n **/\nmodule.exports.size = (appToken, readerHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(readerHandle))\n    .then((reader) => reader.size());\n};\n\n/**\n * Close the Reader handle\n * @param {String} appToken - the application token\n * @param {Handle} readerHandle - the reader handle\n * @returns {Promise<()>}\n */\nmodule.exports.closeReader = (appToken, readerHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(readerHandle))\n    .then((reader) => reader.close())\n    .then(() => freeObj(readerHandle));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/immutable_data.js\n// module id = 9\n// module chunks = 0","const { genHandle, getObj, freeObj } = require('./helpers');\n\nmodule.exports.manifest = {\n  newRandomPrivate: 'promise',\n  newRandomPublic: 'promise',\n  newPrivate: 'promise',\n  newPublic: 'promise',\n  newPermissions: 'promise',\n  newPermissionSet: 'promise',\n  newMutation: 'promise',\n  newEntries: 'promise',\n  quickSetup: 'promise',\n  encryptKey: 'promise',\n  encryptValue: 'promise',\n  getNameAndTag: 'promise',\n  getVersion: 'promise',\n  get: 'promise',\n  put: 'promise',\n  getEntries: 'promise',\n  getKeys: 'promise',\n  getValues: 'promise',\n  getPermissions: 'promise',\n  getUserPermissions: 'promise',\n  delUserPermissions: 'promise',\n  setUserPermissions: 'promise',\n  applyEntriesMutation: 'promise',\n  serialise: 'promise',\n  fromSerial: 'promise',\n  emulateAs: 'promise',\n  free: 'sync'\n};\n\n/**\n * Create a new mutuable data at a random address with private\n * access.\n * @param {String} appToken - the application token\n * @param {Number} typeTag - the typeTag to use\n * @returns {Promise<MutableDataHandle>}\n **/\nmodule.exports.newRandomPrivate = (appToken, typeTag) => {\n  return getObj(appToken)\n    .then((app) => app.mutableData.newRandomPrivate(typeTag))\n    .then(genHandle);\n};\n\n/**\n * Create a new mutuable data at a random address with public\n * access.\n * @param {String} appToken - the application token\n * @param {Number} typeTag - the typeTag to use\n * @returns {Promise<MutableDataHandle>}\n **/\nmodule.exports.newRandomPublic = (appToken, typeTag) => {\n  return getObj(appToken)\n    .then((app) => app.mutableData.newRandomPublic(typeTag))\n    .then(genHandle);\n};\n\n/**\n * Initiate a mutuable data at the given address with private\n * access.\n * @param {String} appToken - the application token\n * @param {Buffer|String}\n * @param {Number} typeTag - the typeTag to use\n * @returns {Promise<MutableDataHandle>}\n **/\nmodule.exports.newPrivate = (appToken, name, typeTag) => {\n  return getObj(appToken)\n    .then((app) => app.mutableData.newPrivate(name, typeTag))\n    .then(genHandle);\n};\n\n/**\n * Initiate a mutuable data at the given address with public\n * access.\n * @param {String} appToken - the application token\n * @param {Buffer|String}\n * @param {Number} typeTag - the typeTag to use\n * @returns {Promise<MutableDataHandle>}\n **/\nmodule.exports.newPublic = (appToken, name, typeTag) => {\n  return getObj(appToken)\n    .then((app) => app.mutableData.newPublic(name, typeTag))\n    .then(genHandle);\n};\n\n/**\n * Create a new Permissions object.\n * @param {String} appToken - the application token\n * @returns {Promise<PermissionsHandle>}\n **/\nmodule.exports.newPermissions = (appToken) => {\n  return getObj(appToken)\n    .then((app) => app.mutableData.newPermissions())\n    .then(genHandle);\n};\n\n/**\n * Create a new PermissionsSet object.\n * @param {String} appToken - the application token\n * @returns {Promise<PermissionsSetHandle>}\n **/\nmodule.exports.newPermissionSet = (appToken) => {\n  return getObj(appToken)\n    .then((app) => app.mutableData.newPermissionSet())\n    .then(genHandle);\n};\n\n/**\n * Create a new Mutation object.\n * @param {String} appToken - the application token\n * @returns {Promise<MutationHandle>}\n **/\nmodule.exports.newMutation = (appToken) => {\n  return getObj(appToken)\n    .then((app) => app.mutableData.newMutation())\n    .then(genHandle);\n};\n\n/**\n * Create a new Entries object.\n * @param {String} appToken - the application token\n * @returns {Promise<EntriesHandle>}\n **/\nmodule.exports.newEntries = (appToken) => {\n  return getObj(appToken)\n    .then((app) => app.mutableData.newEntries())\n    .then(genHandle);\n};\n\n// MutableData functions\n/**\n * Quickly set up a newly (not yet created) MutableData with\n * the app having full-access permissions (and no other).\n *\n * @param {String} appToken - the application token\n * @param {MutableDataHandle} mdHandle - the MutableData handle\n * @param {Object=} data - a key-value payload it should\n *        create the data with\n * @returns {Promise<MutableDataHandle>} - self\n **/\nmodule.exports.quickSetup = (appToken, mdHandle, data) => {\n  return getObj(appToken)\n    .then(() => getObj(mdHandle))\n    .then((md) => md.quickSetup(data))\n    .then(() => mdHandle);\n};\n\n/**\n * Encrypt the entry key provided as parameter with the encryption key\n * contained in a Private MutableData. If the MutableData is Public, the same\n * (and unencrypted) value is returned.\n *\n * @param {String} appToken - the application token\n * @param {MutableDataHandle} mdHandle - the MutableData handle\n * @param {(String|Buffer)} key - the key you want to encrypt\n * @returns {Promise<Key>} - the encrypted entry key\n **/\nmodule.exports.encryptKey = (appToken, mdHandle, key) => {\n  return getObj(appToken)\n    .then(() => getObj(mdHandle))\n    .then((md) => md.encryptKey(key));\n};\n\n/**\n * Encrypt the entry value provided as parameter with the encryption key\n * contained in a Private MutableData. If the MutableData is Public, the same\n * (and unencrypted) value is returned.\n *\n * @param {String} appToken - the application token\n * @param {MutableDataHandle} mdHandle - the MutableData handle\n * @param {(String|Buffer)} value - the data you want to encrypt\n * @returns {Promise<Value>} - the encrypted entry value\n **/\nmodule.exports.encryptValue = (appToken, mdHandle, value) => {\n  return getObj(appToken)\n    .then(() => getObj(mdHandle))\n    .then((md) => md.encryptValue(value));\n};\n\n\nmodule.exports.decrypt = (appToken, mdHandle, value) => {\n  return getObj(appToken)\n    .then(() => getObj(mdHandle))\n    .then((md) => md.decrypt(value));\n};\n\n\n\n/**\n * Look up the name and tag of the MutableData as required to look it\n * up on the network.\n *\n * @param {String} appToken - the application token\n * @param {MutableDataHandle} mdHandle - the MutableData handle\n * @returns {Promise<NameAndTag>}\n **/\nmodule.exports.getNameAndTag = (appToken, mdHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(mdHandle))\n    .then((md) => md.getNameAndTag());\n};\n\n/**\n * Look up the mutable data object version on the network\n *\n * @param {String} appToken - the application token\n * @param {MutableDataHandle} mdHandle - the MutableData handle\n * @returns {Promise<Number>} the version\n **/\nmodule.exports.getVersion = (appToken, mdHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(mdHandle))\n    .then((md) => md.getVersion());\n};\n\n/**\n * Look up the value of a specific key\n *\n * @param {String} appToken - the application token\n * @param {MutableDataHandle} mdHandle - the MutableData handle\n * @param {String} key - the entry's key\n * @returns {Promise<ValueVersion>} - the value at the current version\n **/\nmodule.exports.get = (appToken, mdHandle, key) => {\n  return getObj(appToken)\n    .then(() => getObj(mdHandle))\n    .then((md) => md.get(key));\n};\n\n/**\n * Create this MutableData on the network.\n * @param {String} appToken - the application token\n * @param {MutableDataHandle} mdHandle - the MutableData handle\n * @param {PermissionsHandle} permissionsHandle - the permissions to create the mdata with\n * @param {EntriesHandle} entriesHandle - data payload to create the mdata with\n * @returns {Promise<()>}\n **/\nmodule.exports.put = (appToken, mdHandle, permissionsHandle, entriesHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(mdHandle))\n    .then((md) => getObj(permissionsHandle)\n      .then((permissions) => getObj(entriesHandle)\n        .then((entries) => md.put(permissions, entries))\n      ));\n};\n\n/**\n * Get a Handle to the entries associated with this mdata\n * @param {String} appToken - the application token\n * @param {MutableDataHandle} mdHandle - the MutableData handle\n * @returns {Promise<(EntriesHandle)>}\n **/\nmodule.exports.getEntries = (appToken, mdHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(mdHandle))\n    .then((md) => md.getEntries())\n    .then(genHandle);\n};\n\n/**\n * Get a Handle to the keys associated with this mdata\n * @param {String} appToken - the application token\n * @param {MutableDataHandle} mdHandle - the MutableData handle\n * @returns {Promise<(KeysHandle)>}\n **/\nmodule.exports.getKeys = (appToken, mdHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(mdHandle))\n    .then((md) => md.getKeys())\n    .then(genHandle);\n};\n\n/**\n * Get a Handle to the values associated with this mdata\n * @param {String} appToken - the application token\n * @param {MutableDataHandle} mdHandle - the MutableData handle\n * @returns {Promise<(ValuesHandle)>}\n **/\nmodule.exports.getValues = (appToken, mdHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(mdHandle))\n    .then((md) => md.getValues())\n    .then(genHandle);\n};\n\n/**\n * Get a Handle to the permissions associated with this mdata\n * @param {String} appToken - the application token\n * @param {MutableDataHandle} mdHandle - the MutableData handle\n * @returns {Promise<(PermissionsHandle)>}\n **/\nmodule.exports.getPermissions = (appToken, mdHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(mdHandle))\n    .then((md) => md.getPermissions())\n    .then(genHandle);\n};\n\n/**\n * Get a Handle to the permissions associated with this mdata for\n * a specifc key\n * @param {String} appToken - the application token\n * @param {MutableDataHandle} mdHandle - the MutableData handle\n * @param {SignKeyHandle} signKeyHandle - the sign key to look up\n * @returns {Promise<(PermissionsSetHandle)>}\n **/\nmodule.exports.getUserPermissions = (appToken, mdHandle, signKeyHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(signKeyHandle))\n    .then((signKey) => getObj(mdHandle)\n      .then((md) => md.getUserPermissions(signKey))\n      .then(genHandle)\n    );\n};\n\n/**\n * Delete the permissions of a specifc key. Directly commits to the network.\n * Requires 'ManagePermissions'-Permission for the app.\n * @param {String} appToken - the application token\n * @param {MutableDataHandle} mdHandle - the MutableData handle\n * @param {SignKeyHandle} signKeyHandle - the sign key to lookup for\n * @param {Number} version - the current version, to confirm you are\n *        actually asking for the right state\n * @returns {Promise} - once finished\n **/\nmodule.exports.delUserPermissions = (appToken, mdHandle, signKeyHandle, version) => {\n  return getObj(appToken)\n    .then(() => getObj(signKeyHandle))\n    .then((signKey) => getObj(mdHandle)\n      .then((md) => md.delUserPermissions(signKey, version))\n    );\n};\n\n/**\n * Set the permissions of a specifc key. Directly commits to the network.\n * Requires 'ManagePermissions'-Permission for the app.\n * @param {String} appToken - the application token\n * @param {MutableDataHandle} mdHandle - the MutableData handle\n * @param {SignKeyHandle} signKeyHandle - the sign key to lookup for\n * @param {PermissionsSetHandle} pmSetHandle - the PermissionsSet to set to\n * @param {Number} version - the current version, to confirm you are\n *        actually asking for the right state\n * @returns {Promise} - once finished\n **/\nmodule.exports.setUserPermissions = (appToken, mdHandle, signKeyHandle, pmSetHandle, version) => {\n  return getObj(appToken)\n    .then(() => getObj(signKeyHandle)\n      .then((signKey) => getObj(pmSetHandle)\n        .then((pmSet) => getObj(mdHandle)\n          .then((md) => md.setUserPermissions(signKey, pmSet, version))\n        )));\n};\n\n/**\n * Commit the transaction to the network\n * @param {String} appToken - the application token\n * @param {MutableDataHandle} mdHandle - the MutableData handle\n * @param {MutationHandle} mutationHandle - the Mutation you want to apply\n * @return {Promise}\n **/\nmodule.exports.applyEntriesMutation = (appToken, mdHandle, mutationHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(mutationHandle))\n    .then((mutation) => getObj(mdHandle)\n      .then((md) => md.applyEntriesMutation(mutation))\n    );\n};\n\n/**\n * Serialise the current mdata\n * @param {String} appToken - the application token\n * @param {MutableDataHandle} mdHandle - the MutableData handle\n * @returns {Promise<(String)>}\n **/\nmodule.exports.serialise = (appToken, mdHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(mdHandle))\n    .then((md) => md.serialise());\n};\n\n/**\n * Deserialize the mdata\n * @param {String} appToken - the application token\n * @returns {Promise<MutableDataHandle>}\n */\nmodule.exports.fromSerial = (appToken, data) => {\n  return getObj(appToken)\n    .then((app) => app.mutableData.fromSerial(data))\n    .then(genHandle);\n};\n\n/**\n * Wrap this MData into a known abstraction. Currently known: `NFS`\n * @param {String} appToken - the application token\n * @param {MutableDataHandle} mdHandle - the MutableData handle\n * @param {String} eml - name of the emulation\n * @returns {EmulationHandle} the Emulation you are asking for\n **/\nmodule.exports.emulateAs = (appToken, mdHandle, eml) => {\n  return getObj(appToken)\n    .then(() => getObj(mdHandle))\n    .then((md) => md.emulateAs(eml))\n    .then(genHandle);\n};\n\n/**\n * Free the MutableData instance from memory\n * @param {String} mdHandle - the MutableData handle\n */\nmodule.exports.free = (mdHandle) => freeObj(mdHandle);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/mutable_data.js\n// module id = 10\n// module chunks = 0","const { genHandle, getObj, freeObj, forEachHelper } = require('./helpers');\n\nmodule.exports.manifest = {\n  len: 'promise',\n  get: 'promise',\n  _with_cb_forEach: 'readable',\n  insert: 'promise',\n  mutate: 'promise',\n  free: 'sync'\n};\n\n\n/**\n * Get the total number of entries in the Mdata\n * @param {String} appToken - the application token\n * @param {EntriesHandle} entriesHandle - the Entries obj handle\n * @returns {Promise<Number>}\n **/\nmodule.exports.len = (appToken, entriesHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(entriesHandle))\n    .then((entries) => entries.len());\n};\n\n/**\n * Look up the value of a specific key\n *\n * @param {String} appToken - the application token\n * @param {EntriesHandle} entriesHandle - the Entries obj handle\n * @param {String} keyName - the entry's key\n * @returns {Promise<ValueVersion>} - the value at the current version\n **/\nmodule.exports.get = (appToken, entriesHandle, keyName) => {\n  return getObj(appToken)\n    .then(() => getObj(entriesHandle))\n    .then((entries) => entries.get(keyName));\n};\n\n/**\n * Iterate over the entries, execute the function every time\n * @param {String} appToken - the application token\n * @param {EntriesHandle} entriesHandle - the Entries obj handle\n * @param {function(Buffer, ValueVersion)} fn - the function to call\n * @returns {Promise<()>} - resolves once the iteration is done\n **/\nmodule.exports._with_cb_forEach = (appToken, entriesHandle) => {\n  return forEachHelper(appToken, entriesHandle);\n};\n\n/**\n * Insert a new entry. Will directly commit that transaction to the network.\n * Will fail if the entry already exists or the current app doesn't have the\n * permissions to edit that mdata.\n *\n * @param {String} appToken - the application token\n * @param {EntriesHandle} entriesHandle - the Entries obj handle\n * @param {(String|Buffer)} keyName - the key you want store the data under\n * @param {(String|Buffer)} value - the data you want to store\n * @returns {Promise<>}\n **/\nmodule.exports.insert = (appToken, entriesHandle, keyName, value) => {\n  return getObj(appToken)\n    .then(() => getObj(entriesHandle))\n    .then((entries) => entries.insert(keyName, value));\n};\n\n/**\n * Start a new transaction of mutation of the entries\n * @param {String} appToken - the application token\n * @param {EntriesHandle} entriesHandle - the Entries obj handle\n * @return {Promise<MutationHandle>}\n **/\nmodule.exports.mutate = (appToken, entriesHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(entriesHandle))\n    .then((entries) => entries.mutate())\n    .then(genHandle);\n};\n\n/**\n * Free the Entries instance from memory\n * @param {String} entriesHandle - the Entries handle\n */\nmodule.exports.free = (entriesHandle) => freeObj(entriesHandle);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/mutable_data_entries.js\n// module id = 11\n// module chunks = 0","const { getObj, freeObj, forEachHelper } = require('./helpers');\n\nmodule.exports.manifest = {\n  len: 'promise',\n  _with_cb_forEach: 'readable',\n  free: 'sync'\n};\n\n/**\n * Get the total number of keys in the Mdata\n * @param {String} appToken - the application token\n * @param {KeysHandle} keysHandle - the Keys obj handle\n * @returns {Promise<Number>}\n **/\nmodule.exports.len = (appToken, keysHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(keysHandle))\n    .then((keys) => keys.len());\n};\n\n/**\n * Iterate over the value, execute the function every time\n * @param {String} appToken - the application token\n * @param {KeysHandle} keysHandle - the Keys obj handle\n * @param {function(Buffer)} fn - the function to call with the key in the buffer\n * @returns {Promise<()>} - resolves once the iteration is done\n **/\nmodule.exports._with_cb_forEach = (appToken, keysHandle) => {\n  return forEachHelper(appToken, keysHandle);\n}\n\n/**\n * Free the Keys instance from memory\n * @param {String} keysHandle - the Keys handle\n */\nmodule.exports.free = (keysHandle) => freeObj(keysHandle);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/mutable_data_keys.js\n// module id = 12\n// module chunks = 0","const { getObj, freeObj } = require('./helpers');\n\nmodule.exports.manifest = {\n  insert: 'promise',\n  remove: 'promise',\n  update: 'promise',\n  free: 'sync'\n};\n\n/**\n * Store a new `Insert`-Action in the transaction.\n *\n * @param {String} appToken - the application token\n * @param {MutationHandle} mutationHandle - the Mutation obj handle\n * @param {(String|Buffer)} keyName\n * @param {(String|Buffer)} value\n * @returns {Promise} resolves once the storing is done\n **/\nmodule.exports.insert = (appToken, mutationHandle, keyName, value) => {\n  return getObj(appToken)\n    .then(() => getObj(mutationHandle))\n    .then((mutation) => mutation.insert(keyName, value));\n};\n\n/**\n * Store a new `Remove`-Action in the transaction\n *\n * @param {String} appToken - the application token\n * @param {MutationHandle} mutationHandle - the Mutation obj handle\n * @param {(String|Buffer)} keyName - the key you want to remove\n * @param {Number} version - the current version, to confirm you are\n *        actually asking for the right state\n * @returns {Promise} resolves once the storing is done\n **/\nmodule.exports.remove = (appToken, mutationHandle, keyName, version) => {\n  return getObj(appToken)\n    .then(() => getObj(mutationHandle))\n    .then((mutation) => mutation.remove(keyName, version));\n};\n\n/**\n * Store a `Update`-Action in the transaction\n *\n * @param {String} appToken - the application token\n * @param {MutationHandle} mutationHandle - the Mutation obj handle\n * @param {(String|Buffer)} keyName - the key you want to remove\n * @param {(String|Buffer)} value - the value to upate to\n * @param {Number} version - the current version, to confirm you are\n *        actually asking for the right state\n * @returns {Promise} resolves once the storing is done\n **/\nmodule.exports.update = (appToken, mutationHandle, keyName, value, version) => {\n  return getObj(appToken)\n    .then(() => getObj(mutationHandle))\n    .then((mutation) => mutation.update(keyName, value, version));\n};\n\n/**\n * Free the Mutation instance from memory\n * @param {String} mutationHandle - the application token\n */\nmodule.exports.free = (mutationHandle) => freeObj(mutationHandle);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/mutable_data_mutation.js\n// module id = 13\n// module chunks = 0","const { genHandle, getObj, freeObj, forEachHelper } = require('./helpers');\n\nmodule.exports.manifest = {\n  len: 'promise',\n  getPermissionsSet: 'promise',\n  insertPermissionsSet: 'promise',\n  _with_cb_forEach: 'readable',\n  free: 'sync'\n};\n\n/**\n * Total number of permission entries\n * @param {String} appToken - the application token\n * @param {PermissionsHandle} permissionsHandle - the Permissions obj handle\n * @returns {Promise<Number>}\n **/\nmodule.exports.len = (appToken, permissionsHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(permissionsHandle))\n    .then((permissions) => permissions.len());\n};\n\n/**\n * Lookup the permissions of a specifc key\n * @param {String} appToken - the application token\n * @param {PermissionsHandle} permissionsHandle - the Permissions obj handle\n * @param {SignKeyHandle} signKeyHandle - the key to lookup for\n * @returns {Promise<PermissionsSetHandle>} - the permissions set for that key\n **/\nmodule.exports.getPermissionsSet = (appToken, permissionsHandle, signKeyHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(signKeyHandle))\n    .then((signKey) => getObj(permissionsHandle)\n      .then((permissions) => permissions.getPermissionSet(signKey))\n      .then(genHandle)\n    );\n};\n\n/**\n * Insert a new permissions to a specifc key. Directly commits to the network.\n * Requires 'ManagePermissions'-Permission for the app.\n * @param {String} appToken - the application token\n * @param {PermissionsHandle} permissionsHandle - the Permissions obj handle\n * @param {SignKeyHandle} signKeyHandle - the key to lookup for\n * @param {PermissionsSetHandle} pmSetHandle - the permissions set you'd like insert\n * @returns {Promise} - once finished\n **/\nmodule.exports.insertPermissionsSet = (appToken, permissionsHandle, signKeyHandle, pmSetHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(signKeyHandle))\n    .then((signKey) => getObj(pmSetHandle)\n      .then((pmSet) => getObj(permissionsHandle)\n        .then((permissions) => permissions.insertPermissionSet(signKey, pmSet))\n      ));\n};\n\n/**\n * Iterate over the entries, execute the function every time\n * @param {String} appToken - the application token\n * @param {PermissionsHandle} permissionsHandle - the Permissions obj handle\n * @param {function(Buffer, ValueVersion)} fn - the function to call\n * @returns {Promise<()>} - resolves once the iteration is done\n **/\nmodule.exports._with_cb_forEach = (appToken, permissionsHandle) => {\n  return forEachHelper(appToken, permissionsHandle, true);\n};\n\n/**\n * Free the Permissions instance from memory\n * @param {String} permissionsHandle - the application token\n */\nmodule.exports.free = (permissionsHandle) => freeObj(permissionsHandle);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/mutable_data_permissions.js\n// module id = 14\n// module chunks = 0","const { getObj, freeObj } = require('./helpers');\n\nmodule.exports.manifest = {\n  setAllow: 'promise',\n  setDeny: 'promise',\n  clear: 'promise',\n  free: 'sync'\n};\n\n/**\n * Set the action as allowed\n * @param {String} appToken - the application token\n * @param {PermissionsSetHandle} permissionsSetHandle - the PermissionsSet obj handle\n * @param {MDataAction} action\n * @returns {Promise}\n **/\nmodule.exports.setAllow = (appToken, permissionsSetHandle, action) => {\n  return getObj(appToken)\n    .then(() => getObj(permissionsSetHandle))\n    .then((pmSet) => pmSet.setAllow(action));\n};\n\n/**\n * Set the action as denied\n * @param {String} appToken - the application token\n * @param {PermissionsSetHandle} permissionsSetHandle - the PermissionsSet obj handle\n * @param {MDataAction} action\n * @returns {Promise}\n **/\nmodule.exports.setDeny = (appToken, permissionsSetHandle, action) => {\n  return getObj(appToken)\n    .then(() => getObj(permissionsSetHandle))\n    .then((pmSet) => pmSet.setDeny(action));\n};\n\n/**\n * Remove action from the set\n * @param {String} appToken - the application token\n * @param {PermissionsSetHandle} permissionsSetHandle - the PermissionsSet obj handle\n * @param {MDataAction} action\n * @returns {Promise}\n **/\nmodule.exports.clear = (appToken, permissionsSetHandle, action) => {\n  return getObj(appToken)\n    .then(() => getObj(permissionsSetHandle))\n    .then((pmSet) => pmSet.clear(action));\n};\n\n/**\n * Free the PermissionsSet instance from memory\n * @param {String} permissionsSetHandle - the application token\n */\nmodule.exports.free = (permissionsSetHandle) => freeObj(permissionsSetHandle);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/mutable_data_permissions_set.js\n// module id = 15\n// module chunks = 0","const { getObj, freeObj, forEachHelper } = require('./helpers');\n\nmodule.exports.manifest = {\n  len: 'promise',\n  _with_cb_forEach: 'readable',\n  free: 'sync'\n};\n\n/**\n * Get the total number of values in the Mdata\n * @param {String} appToken - the application token\n * @param {ValuesHandle} valuesHandle - the Values obj handle\n * @returns {Promise<Number>}\n **/\nmodule.exports.len = (appToken, valuesHandle) => {\n  return getObj(appToken)\n    .then(() => getObj(valuesHandle))\n    .then((values) => values.len());\n};\n\n/**\n * Iterate over the value, execute the function every time\n * @param {String} appToken - the application token\n * @param {ValuesHandle} valuesHandle - the Values obj handle\n * @param {function(Buffer, ValueVersion)} fn - the function to call\n * @returns {Promise<()>} - resolves once the iteration is done\n **/\nmodule.exports._with_cb_forEach = (appToken, valuesHandle) => {\n  return forEachHelper(appToken, valuesHandle);\n};\n\n/**\n * Free the Values instance from memory\n * @param {String} valuesHandle - the Values handle\n */\nmodule.exports.free = (valuesHandle) => freeObj(valuesHandle);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/mutable_data_values.js\n// module id = 16\n// module chunks = 0","const app = require('./app');\nconst cipherOpt = require('./cipher_opt');\nconst imdata = require('./immutable_data');\nconst crypto = require('./crypto');\nconst cryptoKeyPair = require('./crypto_key_pair');\nconst cryptoSecEncKey = require('./crypto_secret_encryption_key');\nconst cryptoPubEncKey = require('./crypto_public_encryption_key');\nconst cryptoSignKey = require('./crypto_sign_key');\nconst mdata = require('./mutable_data');\nconst mdataEntries = require('./mutable_data_entries');\nconst mdataKeys = require('./mutable_data_keys');\nconst mdataValues = require('./mutable_data_values');\nconst mdataMutation = require('./mutable_data_mutation');\nconst mdataPermissions = require('./mutable_data_permissions');\nconst mdataPermissionsSet = require('./mutable_data_permissions_set');\nconst nfs = require('./emulations/nfs');\n\nmodule.exports = [\n  {\n    name: 'safeApp',\n    isInternal: true,\n    manifest: app.manifest,\n    methods: app\n  },\n  {\n    name: 'safeCipherOpt',\n    isInternal: true,\n    manifest: cipherOpt.manifest,\n    methods: cipherOpt\n  },\n  {\n    name: 'safeImmutableData',\n    isInternal: true,\n    manifest: imdata.manifest,\n    methods: imdata\n  },\n  {\n    name: 'safeCrypto',\n    isInternal: true,\n    manifest: crypto.manifest,\n    methods: crypto\n  },\n  {\n    name: 'safeCryptoKeyPair',\n    isInternal: true,\n    manifest: cryptoKeyPair.manifest,\n    methods: cryptoKeyPair\n  },\n  {\n    name: 'safeCryptoSecEncKey',\n    isInternal: true,\n    manifest: cryptoSecEncKey.manifest,\n    methods: cryptoSecEncKey\n  },\n  {\n    name: 'safeCryptoPubEncKey',\n    isInternal: true,\n    manifest: cryptoPubEncKey.manifest,\n    methods: cryptoPubEncKey\n  },\n  {\n    name: 'safeCryptoSignKey',\n    isInternal: true,\n    manifest: cryptoSignKey.manifest,\n    methods: cryptoSignKey\n  },\n  {\n    name: 'safeMutableData',\n    isInternal: true,\n    manifest: mdata.manifest,\n    methods: mdata\n  },\n  {\n    name: 'safeMutableDataEntries',\n    isInternal: true,\n    manifest: mdataEntries.manifest,\n    methods: mdataEntries\n  },\n  {\n    name: 'safeMutableDataKeys',\n    isInternal: true,\n    manifest: mdataKeys.manifest,\n    methods: mdataKeys\n  },\n  {\n    name: 'safeMutableDataValues',\n    isInternal: true,\n    manifest: mdataValues.manifest,\n    methods: mdataValues\n  },\n  {\n    name: 'safeMutableDataMutation',\n    isInternal: true,\n    manifest: mdataMutation.manifest,\n    methods: mdataMutation\n  },\n  {\n    name: 'safeMutableDataPermissions',\n    isInternal: true,\n    manifest: mdataPermissions.manifest,\n    methods: mdataPermissions\n  },\n  {\n    name: 'safeMutableDataPermissionsSet',\n    isInternal: true,\n    manifest: mdataPermissionsSet.manifest,\n    methods: mdataPermissionsSet\n  },\n  {\n    name: 'safeNfs',\n    isInternal: true,\n    manifest: nfs.manifest,\n    methods: nfs\n  }\n];\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/index.js\n// module id = 17\n// module chunks = 0","/* eslint-disable import/no-extraneous-dependencies, import/no-unresolved */\nconst ipcMain = require('electron').ipcMain; // electron deps will be avaible inside browser\n/* eslint-enable import/no-extraneous-dependencies, import/no-unresolved */\nconst genRandomString = require('./helpers').genRandomString;\n\nclass IpcTask {\n  constructor() {\n    this.tasks = [];\n    this.tasksInfo = {};\n    this.isProcessing = false;\n    this.currentTaskId = null;\n    this.currentTaskInfo = null;\n    this.currentTaskCb = null;\n  }\n\n  add(info, cb) {\n    const token = genRandomString();\n    this.tasks.push(token);\n    this.tasksInfo[token] = { info, cb };\n    this.next();\n  }\n\n  remove() {\n    const index = this.tasks.indexOf(this.currentTaskId);\n    this.tasks.splice(index, 1);\n    delete this.tasksInfo[this.currentTaskId];\n    this.isProcessing = false;\n    return this;\n  }\n\n  next() {\n    if (this.isProcessing || this.tasks.length === 0) {\n      return;\n    }\n    this.isProcessing = true;\n    this.currentTaskId = this.tasks[0];\n    this.currentTaskInfo = this.tasksInfo[this.currentTaskId].info;\n    this.currentTaskCb = this.tasksInfo[this.currentTaskId].cb;\n    ipcEvent.sender.send('webClientAuthReq', this.currentTaskInfo);\n  }\n}\n\nconst ipcTask = new IpcTask();\n\nlet ipcEvent = null;\n\nipcMain.on('registerSafeApp', (event) => {\n  ipcEvent = event;\n});\n\nipcMain.on('webClientContainerRes', (event, res) => {\n  // handle response\n  if (typeof ipcTask.currentTaskCb === 'function') {\n    ipcTask.currentTaskCb(null, res);\n  }\n  ipcTask.remove().next();\n});\n\nipcMain.on('webClientAuthRes', (event, res) => {\n  // handle response\n  if (typeof ipcTask.currentTaskCb === 'function') {\n    ipcTask.currentTaskCb(null, res);\n  }\n  ipcTask.remove().next();\n});\n\nipcMain.on('webClientErrorRes', (event, err) => {\n  // handle Error\n  if (typeof ipcTask.currentTaskCb === 'function') {\n    ipcTask.currentTaskCb(err);\n  }\n  ipcTask.remove().next();\n});\n\nmodule.exports.sendAuthReq = (req, cb) => {\n  ipcTask.add(req.uri, cb);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/ipc.js\n// module id = 18\n// module chunks = 0","module.exports = require(\"crypto\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"crypto\"\n// module id = 19\n// module chunks = 0","module.exports = require(\"electron\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"electron\"\n// module id = 20\n// module chunks = 0","module.exports = require(\"safe-app\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"safe-app\"\n// module id = 21\n// module chunks = 0","module.exports = require(\"stream\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"stream\"\n// module id = 22\n// module chunks = 0"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AChEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5EA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;A","sourceRoot":""}