module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _path = __webpack_require__(1);

	var _path2 = _interopRequireDefault(_path);

	var _fs = __webpack_require__(2);

	var _fs2 = _interopRequireDefault(_fs);

	var _url = __webpack_require__(3);

	var _url2 = _interopRequireDefault(_url);

	var _electron = __webpack_require__(4);

	var _client_manager = __webpack_require__(5);

	var _client_manager2 = _interopRequireDefault(_client_manager);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* eslint-disable import/extensions */
	var safeAuthScheme = 'safe-auth';
	/* eslint-enable import/extensions */


	var isDevMode = process.execPath.match(/[\\/]electron/);

	var appInfo = {
	  id: 'net.maidsafe.safebrowser',
	  exec: isDevMode ? process.execPath + ' ' + _electron.app.getAppPath() : _electron.app.getPath('exe'),
	  vendor: 'maidsafe',
	  name: 'safe-browser',
	  icon: 'iconPath'
	};

	var registerSafeAuthProtocol = function registerSafeAuthProtocol() {
	  _client_manager2.default.registerUriScheme(appInfo, safeAuthScheme);

	  _electron.protocol.registerBufferProtocol(safeAuthScheme, function (req, cb) {
	    var parsedUrl = _url2.default.parse(req.url);
	    switch (parsedUrl.pathname) {
	      case '/bundle.js':
	        cb({
	          mimeType: 'application/javascript',
	          data: _fs2.default.readFileSync(_path2.default.resolve(__dirname, 'bundle.js'))
	        });
	        break;
	      case '/bundle.js.map':
	        cb({
	          mimeType: 'application/octet-stream',
	          data: _fs2.default.readFileSync(_path2.default.resolve(__dirname, 'bundle.js.map'))
	        });
	        break;
	      default:
	        cb({ mimeType: 'text/html', data: _fs2.default.readFileSync(_path2.default.resolve(__dirname, 'app.html')) });
	        break;
	    }
	  }, function (err) {
	    if (err) console.error('Failed to register protocol');
	  });
	};

	var scheme = {
	  scheme: safeAuthScheme,
	  label: 'SAFE Authenticator',
	  isStandardURL: true,
	  isInternal: true,
	  register: registerSafeAuthProtocol
	};

	exports.default = scheme;
	module.exports = exports['default'];

/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = require("path");

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = require("fs");

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = require("url");

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = require("electron");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _ffi = __webpack_require__(6);

	var _ffi2 = _interopRequireDefault(_ffi);

	var _i18n = __webpack_require__(7);

	var _i18n2 = _interopRequireDefault(_i18n);

	var _config = __webpack_require__(26);

	var _config2 = _interopRequireDefault(_config);

	var _types = __webpack_require__(27);

	var types = _interopRequireWildcard(_types);

	var _typesParser = __webpack_require__(38);

	var typeParser = _interopRequireWildcard(_typesParser);

	var _typesConstructor = __webpack_require__(59);

	var typeConstructor = _interopRequireWildcard(_typesConstructor);

	var _sys_uri_loader = __webpack_require__(60);

	var _sys_uri_loader2 = _interopRequireDefault(_sys_uri_loader);

	var _FfiApi2 = __webpack_require__(62);

	var _FfiApi3 = _interopRequireDefault(_FfiApi2);

	var _constants = __webpack_require__(61);

	var _constants2 = _interopRequireDefault(_constants);

	var _error_code_lookup = __webpack_require__(63);

	var _error_code_lookup2 = _interopRequireDefault(_error_code_lookup);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Client Manager
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Expose API for Authenticator as a client
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	/* eslint-disable no-underscore-dangle */
	/* eslint-disable import/no-unresolved, import/extensions */

	/* eslint-enable import/no-unresolved, import/extensions */


	// Private variable symbols
	var _networkState = Symbol('networkState');
	var _networkStateChangeListener = Symbol('networkStateChangeListener');
	var _networkStateChangeIpcListener = Symbol('networkStateChangeIpcListener');
	var _appListUpdateListener = Symbol('appListUpdateListener');
	var _authReqListener = Symbol('authReqListener');
	var _containerReqListener = Symbol('containerReqListener');
	var _reqErrorListener = Symbol('reqErrorListener');
	var _authenticatorHandle = Symbol('clientHandle');
	var _reqDecryptList = Symbol('reqDecryptList');
	var _callbackRegistry = Symbol('callbackRegistry');

	var ClientManager = function (_FfiApi) {
	  _inherits(ClientManager, _FfiApi);

	  function ClientManager() {
	    _classCallCheck(this, ClientManager);

	    var _this = _possibleConstructorReturn(this, (ClientManager.__proto__ || Object.getPrototypeOf(ClientManager)).call(this));

	    _config2.default.i18n();
	    _this[_networkState] = _constants2.default.NETWORK_STATUS.DISCONNECTED;
	    _this[_networkStateChangeListener] = null;
	    _this[_networkStateChangeIpcListener] = null;
	    _this[_appListUpdateListener] = null;
	    _this[_authReqListener] = null;
	    _this[_containerReqListener] = null;
	    _this[_reqErrorListener] = null;
	    _this[_authenticatorHandle] = null;
	    _this[_reqDecryptList] = {};
	    _this[_callbackRegistry] = {};
	    return _this;
	  }

	  _createClass(ClientManager, [{
	    key: 'getFunctionsToRegister',


	    /**
	     * Functions to register with FFI library
	     * @returns Object
	     */
	    /* eslint-disable no-unused-vars, class-methods-use-this */
	    value: function getFunctionsToRegister() {
	      /* eslint-enable no-unused-vars, class-methods-use-this */
	      return {
	        create_acc: [types.int32, [types.CString, types.CString, types.CString, types.AppHandlePointer, 'pointer', 'pointer']],
	        login: [types.int32, [types.CString, types.CString, types.AppHandlePointer, 'pointer', 'pointer']],
	        auth_decode_ipc_msg: [types.Void, [types.voidPointer, types.CString, types.voidPointer, 'pointer', 'pointer', 'pointer']],
	        encode_auth_resp: [types.Void, [types.voidPointer, types.AuthReqPointer, types.u32, types.bool, types.voidPointer, 'pointer']],
	        encode_containers_resp: [types.Void, [types.voidPointer, types.ContainersReqPointer, types.u32, types.bool, types.voidPointer, 'pointer']],
	        authenticator_registered_apps: [types.Void, [types.voidPointer, types.voidPointer, 'pointer']],
	        authenticator_revoke_app: [types.Void, [types.voidPointer, types.CString, types.voidPointer, 'pointer']]
	      };
	    }

	    /**
	     * Set SAFE Network connectivity state listener
	     * @param cb - callback to be invoked on network state change
	     */

	  }, {
	    key: 'setNetworkListener',
	    value: function setNetworkListener(cb) {
	      if (typeof cb !== 'function') {
	        throw new Error(_i18n2.default.__('messages.must_be_function', _i18n2.default.__('Network listener callback')));
	      }
	      this[_networkStateChangeListener] = cb;
	    }

	    /**
	     * Set registered app list update listener
	     * @param cb
	     */

	  }, {
	    key: 'setAppListUpdateListener',
	    value: function setAppListUpdateListener(cb) {
	      if (typeof cb !== 'function') {
	        throw new Error(_i18n2.default.__('messages.must_be_function', _i18n2.default.__('App list listener callback')));
	      }
	      this[_appListUpdateListener] = cb;
	    }

	    /**
	     * Set auth request listener
	     * @param cb
	     */

	  }, {
	    key: 'setAuthReqListener',
	    value: function setAuthReqListener(cb) {
	      if (typeof cb !== 'function') {
	        return;
	      }
	      this[_authReqListener] = cb;
	    }

	    /**
	     * Set container request listener
	     * @param cb
	     */

	  }, {
	    key: 'setContainerReqListener',
	    value: function setContainerReqListener(cb) {
	      if (typeof cb !== 'function') {
	        return;
	      }
	      this[_containerReqListener] = cb;
	    }

	    /**
	     * Set request error listener
	     * @param cb
	     */

	  }, {
	    key: 'setReqErrorListener',
	    value: function setReqErrorListener(cb) {
	      if (typeof cb !== 'function') {
	        return;
	      }
	      this[_reqErrorListener] = cb;
	    }

	    /**
	     * Set Network IPC listener
	     * @param cb
	     */

	  }, {
	    key: 'setNetworkIpcListener',
	    value: function setNetworkIpcListener(cb) {
	      this[_networkStateChangeIpcListener] = cb;
	    }

	    /**
	     * Authorise application request
	     * @param req
	     * @param isAllowed
	     * @returns {Promise}
	     */

	  }, {
	    key: 'authDecision',
	    value: function authDecision(req, isAllowed) {
	      var _this2 = this;

	      return new Promise(function (resolve, reject) {
	        if (!_this2.authenticatorHandle) {
	          return reject(new Error(_i18n2.default.__('messages.unauthorised')));
	        }

	        if (!req || typeof isAllowed !== 'boolean') {
	          return reject(new Error(_i18n2.default.__('messages.invalid_params')));
	        }

	        if (!req.reqId || !_this2[_reqDecryptList][req.reqId]) {
	          return reject(new Error(_i18n2.default.__('messages.invalid_req')));
	        }

	        var authReq = types.allocAuthReq(typeConstructor.constructAuthReq(_this2[_reqDecryptList][req.reqId]));

	        delete _this2[_reqDecryptList][req.reqId];

	        try {
	          _this2[_callbackRegistry].authDecisionCb = _ffi2.default.Callback(types.Void, [types.voidPointer, types.FfiResult, types.CString], function (userData, result, res) {
	            var code = result.error_code;
	            if (code !== 0 && !res) {
	              return reject(_error_code_lookup2.default[code]);
	            }
	            if (isAllowed) {
	              _this2._updateAppList();
	            }
	            resolve(res);
	          });
	          _this2.safeLib.encode_auth_resp(_this2.authenticatorHandle, authReq, req.reqId, isAllowed, types.Null, _this2[_callbackRegistry].authDecisionCb);
	        } catch (e) {
	          reject(e);
	        }
	      });
	    }

	    /**
	     * Authorise container request
	     * @param req
	     * @param isAllowed
	     * @returns {Promise}
	     */

	  }, {
	    key: 'containerDecision',
	    value: function containerDecision(req, isAllowed) {
	      var _this3 = this;

	      return new Promise(function (resolve, reject) {
	        if (!_this3.authenticatorHandle) {
	          return reject(new Error(_i18n2.default.__('messages.unauthorised')));
	        }

	        if (!req || typeof isAllowed !== 'boolean') {
	          return reject(new Error(_i18n2.default.__('messages.invalid_params')));
	        }

	        if (!req.reqId || !_this3[_reqDecryptList][req.reqId]) {
	          return reject(new Error(_i18n2.default.__('messages.invalid_req')));
	        }
	        var contReq = types.allocContainerReq(typeConstructor.constructContainerReq(_this3[_reqDecryptList][req.reqId]));

	        delete _this3[_reqDecryptList][req.reqId];

	        try {
	          _this3[_callbackRegistry].contDecisionCb = _ffi2.default.Callback(types.Void, [types.voidPointer, types.FfiResult, types.CString], function (userData, result, res) {
	            var code = result.error_code;
	            if (code !== 0 && !res) {
	              return reject(_error_code_lookup2.default[code]);
	            }
	            if (isAllowed) {
	              _this3._updateAppList();
	            }
	            resolve(res);
	          });

	          _this3.safeLib.encode_containers_resp(_this3.authenticatorHandle, contReq, req.reqId, isAllowed, types.Null, _this3[_callbackRegistry].contDecisionCb);
	        } catch (e) {
	          reject(e);
	        }
	      });
	    }

	    /**
	     * Revoke application authorisation
	     * @param appId
	     * @returns {Promise}
	     */
	    /* eslint-disable class-methods-use-this */

	  }, {
	    key: 'revokeApp',
	    value: function revokeApp(appId) {
	      var _this4 = this;

	      /* eslint-enable class-methods-use-this */
	      return new Promise(function (resolve, reject) {
	        if (!appId) {
	          return reject(new Error(_i18n2.default.__('messages.should_not_be_empty', _i18n2.default.__('AppId'))));
	        }

	        if (typeof appId !== 'string') {
	          return reject(new Error(_i18n2.default.__('messages.must_be_string', _i18n2.default.__('AppId'))));
	        }

	        if (!appId.trim()) {
	          return reject(new Error(_i18n2.default.__('messages.should_not_be_empty', _i18n2.default.__('AppId'))));
	        }

	        if (!_this4.authenticatorHandle) {
	          return reject(new Error(_i18n2.default.__('messages.unauthorised')));
	        }

	        try {
	          _this4[_callbackRegistry].revokeCb = _ffi2.default.Callback(types.Void, [types.voidPointer, types.FfiResult, types.CString], function (userData, result, res) {
	            var code = result.error_code;
	            if (code !== 0) {
	              return reject(_error_code_lookup2.default[code]);
	            }
	            _this4._updateAppList();
	            try {
	              _this4.openUri(res);
	            } catch (e) {
	              console.error('Failed to open custom URI after revoke');
	            }
	            resolve();
	          });

	          _this4.safeLib.authenticator_revoke_app(_this4.authenticatorHandle, types.allocCString(appId), types.Null, _this4[_callbackRegistry].revokeCb);
	        } catch (e) {
	          reject(e.message);
	        }
	      });
	    }

	    /**
	     * User login
	     * @param {string} locator
	     * @param {string} secret
	     * @returns {Promise}
	     */

	  }, {
	    key: 'login',
	    value: function login(locator, secret) {
	      var _this5 = this;

	      return new Promise(function (resolve, reject) {
	        var validationErr = _this5._isUserCredentialsValid(locator, secret);
	        if (validationErr) {
	          return reject(validationErr);
	        }

	        var appHandle = types.allocAppHandlePointer();

	        var onStateChange = _this5._getFfiNetworkStateCb();

	        try {
	          var onResult = function onResult(err, res) {
	            if (err || res !== 0) {
	              return reject(_error_code_lookup2.default[res]);
	            }
	            _this5[_authenticatorHandle] = appHandle.deref();
	            _this5._pushNetworkState(_constants2.default.NETWORK_STATUS.CONNECTED);
	            resolve();
	          };
	          _this5.safeLib.login.async(types.allocCString(locator), types.allocCString(secret), appHandle, types.Null, onStateChange, onResult);
	        } catch (e) {
	          console.error('Login error :: ' + e.message);
	        }
	      });
	    }

	    /**
	     * Create new account
	     * @param {string} locator
	     * @param {string} secret
	     * @returns {Promise}
	     */

	  }, {
	    key: 'createAccount',
	    value: function createAccount(locator, secret, invitation) {
	      var _this6 = this;

	      return new Promise(function (resolve, reject) {
	        var validationErr = _this6._isUserCredentialsValid(locator, secret);
	        if (validationErr) {
	          return reject(validationErr);
	        }
	        var appHandle = types.allocAppHandlePointer();

	        var onStateChange = _this6._getFfiNetworkStateCb();

	        if (!(invitation && typeof invitation === 'string' && invitation.trim())) {
	          return Promise.reject(new Error(_i18n2.default.__('messages.invalid_invite_code')));
	        }

	        try {
	          var onResult = function onResult(err, res) {
	            if (err || res !== 0) {
	              return reject(_error_code_lookup2.default[res]);
	            }
	            _this6[_authenticatorHandle] = appHandle.deref();
	            _this6._pushNetworkState(_constants2.default.NETWORK_STATUS.CONNECTED);
	            resolve();
	          };
	          _this6.safeLib.create_acc.async(types.allocCString(locator), types.allocCString(secret), types.allocCString(invitation), appHandle, types.Null, onStateChange, onResult);
	        } catch (e) {
	          console.error('Create account error :: ' + e.message);
	        }
	      });
	    }

	    /**
	     * User logout
	     */

	  }, {
	    key: 'logout',
	    value: function logout() {
	      this._pushNetworkState(-1);
	      this[_authenticatorHandle] = null;
	    }

	    /**
	     * Get list of authorised applications
	     * @returns {Promise}
	     */

	  }, {
	    key: 'getAuthorisedApps',
	    value: function getAuthorisedApps() {
	      var _this7 = this;

	      return new Promise(function (resolve, reject) {
	        if (!_this7.authenticatorHandle) {
	          return reject(new Error(_i18n2.default.__('messages.unauthorised')));
	        }
	        try {
	          _this7[_callbackRegistry].appListCb = _ffi2.default.Callback(types.Void, [types.voidPointer, types.FfiResult, types.RegisteredAppPointer, types.usize], function (userData, result, appList, len) {
	            if (result.error_code !== 0) {
	              return reject(_error_code_lookup2.default[result.error_code]);
	            }
	            var apps = typeParser.parseRegisteredAppArray(appList, len);
	            resolve(apps);
	          });
	          _this7.safeLib.authenticator_registered_apps(_this7.authenticatorHandle, types.Null, _this7[_callbackRegistry].appListCb);
	        } catch (e) {
	          reject(e.message);
	        }
	      });
	    }

	    /**
	     * Decrypt auth or container request
	     * @param url
	     * @returns {Promise}
	     */

	  }, {
	    key: 'decryptRequest',
	    value: function decryptRequest(url) {
	      var _this8 = this;

	      return new Promise(function (resolve, reject) {
	        if (!url) {
	          return reject();
	        }

	        var msg = url.replace('safe-auth://', '');

	        if (!_this8.authenticatorHandle) {
	          return reject(new Error(_i18n2.default.__('messages.unauthorised')));
	        }

	        _this8[_callbackRegistry].decryptReqAuthCb = _ffi2.default.Callback(types.Void, [types.voidPointer, types.u32, types.AuthReqPointer], function (userData, reqId, req) {
	          if (typeof _this8[_authReqListener] !== 'function') {
	            return;
	          }
	          var authReq = typeParser.parseAuthReq(req.deref());
	          _this8[_reqDecryptList][reqId] = authReq;
	          _this8[_authReqListener]({
	            reqId: reqId,
	            authReq: authReq
	          });
	        });

	        _this8[_callbackRegistry].decryptReqContainerCb = _ffi2.default.Callback(types.Void, [types.voidPointer, types.u32, types.ContainersReqPointer], function (userData, reqId, req) {
	          if (typeof _this8[_containerReqListener] !== 'function') {
	            return;
	          }
	          var contReq = typeParser.parseContainerReq(req.deref());
	          _this8[_reqDecryptList][reqId] = contReq;
	          _this8[_containerReqListener]({
	            reqId: reqId,
	            contReq: contReq
	          });
	        });

	        _this8[_callbackRegistry].decryptReqErrorCb = _ffi2.default.Callback(types.Void, [types.voidPointer, types.FfiResult, types.CString], function (userData, result, error) {
	          if (typeof _this8[_reqErrorListener] !== 'function') {
	            return;
	          }
	          _this8[_reqErrorListener]({
	            code: result.error_code,
	            msg: error
	          });
	        });

	        try {
	          _this8.safeLib.auth_decode_ipc_msg(_this8.authenticatorHandle, types.allocCString(msg), types.Null, _this8[_callbackRegistry].decryptReqAuthCb, _this8[_callbackRegistry].decryptReqContainerCb, _this8[_callbackRegistry].decryptReqErrorCb);
	        } catch (e) {
	          console.error('Auth request decrypt error :: ' + e.message);
	        }
	      });
	    }

	    /**
	     * Register URI scheme for cross platforms
	     * @param appInfo
	     * @param schemes
	     * @returns {*}
	     */
	    /* eslint-disable class-methods-use-this */

	  }, {
	    key: 'registerUriScheme',
	    value: function registerUriScheme(appInfo, schemes) {
	      /* eslint-enable class-methods-use-this */
	      return _sys_uri_loader2.default.registerUriScheme(appInfo, schemes);
	    }

	    /**
	     * Open Custom URI
	     * @param uri
	     * @returns {*}
	     */
	    /* eslint-disable class-methods-use-this */

	  }, {
	    key: 'openUri',
	    value: function openUri(uri) {
	      /* eslint-enable class-methods-use-this */
	      return _sys_uri_loader2.default.openUri(uri);
	    }

	    /**
	     * Update app list - Calls app list update listener
	     * @private
	     */

	  }, {
	    key: '_updateAppList',
	    value: function _updateAppList() {
	      var _this9 = this;

	      this.getAuthorisedApps().then(function (apps) {
	        if (typeof _this9[_appListUpdateListener] === 'function') {
	          _this9[_appListUpdateListener](null, apps);
	        }
	      });
	    }

	    /**
	     * Prepare FFI network state callback function
	     * @returns {*}
	     * @private
	     */

	  }, {
	    key: '_getFfiNetworkStateCb',
	    value: function _getFfiNetworkStateCb() {
	      var _this10 = this;

	      return _ffi2.default.Callback(types.Void, [types.voidPointer, types.int32, types.int32], function (userData, res, state) {
	        _this10[_networkState] = state;
	        _this10._pushNetworkState();
	      });
	    }

	    /**
	     * Push network state to registered listeners
	     * @param state
	     * @private
	     */

	  }, {
	    key: '_pushNetworkState',
	    value: function _pushNetworkState(state) {
	      var networkState = state;
	      if (typeof networkState === 'undefined') {
	        networkState = this[_networkState];
	      }

	      this[_networkState] = networkState;

	      if (typeof this[_networkStateChangeListener] === 'function') {
	        this[_networkStateChangeListener](null, networkState);
	      }
	      if (typeof this[_networkStateChangeIpcListener] === 'function') {
	        this[_networkStateChangeIpcListener](null, networkState);
	      }
	    }

	    /**
	     * Validate user credential - locator and secret
	     * @param locator
	     * @param secret
	     * @returns {Error}
	     * @private
	     */
	    /* eslint-disable class-methods-use-this */

	  }, {
	    key: '_isUserCredentialsValid',
	    value: function _isUserCredentialsValid(locator, secret) {
	      /* eslint-enable class-methods-use-this */
	      if (!locator) {
	        return new Error(_i18n2.default.__('messages.should_not_be_empty', _i18n2.default.__('Locator')));
	      }

	      if (!secret) {
	        return new Error(_i18n2.default.__('messages.should_not_be_empty', _i18n2.default.__('Secret')));
	      }

	      if (typeof locator !== 'string') {
	        return new Error(_i18n2.default.__('messages.must_be_string', _i18n2.default.__('Locator')));
	      }

	      if (typeof secret !== 'string') {
	        return new Error(_i18n2.default.__('messages.must_be_string', _i18n2.default.__('Secret')));
	      }
	      if (!locator.trim()) {
	        return new Error(_i18n2.default.__('messages.should_not_be_empty', _i18n2.default.__('Locator')));
	      }

	      if (!secret.trim()) {
	        return new Error(_i18n2.default.__('messages.should_not_be_empty', _i18n2.default.__('Secret')));
	      }
	    }
	  }, {
	    key: 'authenticatorHandle',
	    get: function get() {
	      return this[_authenticatorHandle];
	    }
	  }, {
	    key: 'networkState',
	    get: function get() {
	      return this[_networkState];
	    }
	  }]);

	  return ClientManager;
	}(_FfiApi3.default);

	var clientManager = new ClientManager();
	exports.default = clientManager;
	module.exports = exports['default'];

/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = require("ffi");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(8);


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @author      Created by Marcus Spiegel <marcus.spiegel@gmail.com> on 2011-03-25.
	 * @link        https://github.com/mashpie/i18n-node
	 * @license     http://opensource.org/licenses/MIT
	 *
	 * @version     0.8.3
	 */

	'use strict';

	// dependencies
	var vsprintf = __webpack_require__(9).vsprintf,
	  fs = __webpack_require__(2),
	  url = __webpack_require__(3),
	  path = __webpack_require__(1),
	  debug = __webpack_require__(10)('i18n:debug'),
	  warn = __webpack_require__(10)('i18n:warn'),
	  error = __webpack_require__(10)('i18n:error'),
	  Mustache = __webpack_require__(18),
	  Messageformat = __webpack_require__(19),
	  MakePlural = __webpack_require__(22).load(
	    __webpack_require__(23)
	  ),
	  parseInterval = __webpack_require__(24).default;

	// exports an instance
	module.exports = (function() {

	  var MessageformatInstanceForLocale = {},
	    PluralsForLocale = {},
	    locales = {},
	    api = {
	      '__': '__',
	      '__n': '__n',
	      '__l': '__l',
	      '__h': '__h',
	      '__mf': '__mf',
	      'getLocale': 'getLocale',
	      'setLocale': 'setLocale',
	      'getCatalog': 'getCatalog',
	      'getLocales': 'getLocales',
	      'addLocale': 'addLocale',
	      'removeLocale': 'removeLocale'
	    },
	    pathsep = path.sep, // ---> means win support will be available in node 0.8.x and above
	    autoReload,
	    cookiename,
	    defaultLocale,
	    directory,
	    directoryPermissions,
	    extension,
	    fallbacks,
	    indent,
	    logDebugFn,
	    logErrorFn,
	    logWarnFn,
	    objectNotation,
	    prefix,
	    queryParameter,
	    register,
	    updateFiles,
	    syncFiles;

	  // public exports
	  var i18n = {};

	  i18n.locales = locales;

	  i18n.version = '0.8.3';

	  i18n.configure = function i18nConfigure(opt) {

	    // reset locales
	    locales = {};

	    // Provide custom API method aliases if desired
	    // This needs to be processed before the first call to applyAPItoObject()
	    if (opt.api && typeof opt.api === 'object') {
	      for (var method in opt.api) {
	        if (opt.api.hasOwnProperty(method)) {
	          var alias = opt.api[method];
	          if (typeof api[method] !== 'undefined') {
	            api[method] = alias;
	          }
	        }
	      }
	    }

	    // you may register i18n in global scope, up to you
	    if (typeof opt.register === 'object') {
	      register = opt.register;
	      // or give an array objects to register to
	      if (Array.isArray(opt.register)) {
	        register = opt.register;
	        register.forEach(function(r) {
	          applyAPItoObject(r);
	        });
	      } else {
	        applyAPItoObject(opt.register);
	      }
	    }

	    // sets a custom cookie name to parse locale settings from
	    cookiename = (typeof opt.cookie === 'string') ? opt.cookie : null;

	    // query-string parameter to be watched - @todo: add test & doc
	    queryParameter = (typeof opt.queryParameter === 'string') ? opt.queryParameter : null;

	    // where to store json files
	    directory = (typeof opt.directory === 'string') ?
	      opt.directory : path.join(__dirname, 'locales');

	    // permissions when creating new directories
	    directoryPermissions = (typeof opt.directoryPermissions === 'string') ?
	      parseInt(opt.directoryPermissions, 8) : null;

	    // write new locale information to disk
	    updateFiles = (typeof opt.updateFiles === 'boolean') ? opt.updateFiles : true;

	    // sync locale information accros all files
	    syncFiles = (typeof opt.syncFiles === 'boolean') ? opt.syncFiles : false;

	    // what to use as the indentation unit (ex: "\t", "  ")
	    indent = (typeof opt.indent === 'string') ? opt.indent : '\t';

	    // json files prefix
	    prefix = (typeof opt.prefix === 'string') ? opt.prefix : '';

	    // where to store json files
	    extension = (typeof opt.extension === 'string') ? opt.extension : '.json';

	    // setting defaultLocale
	    defaultLocale = (typeof opt.defaultLocale === 'string') ? opt.defaultLocale : 'en';

	    // auto reload locale files when changed
	    autoReload = (typeof opt.autoReload === 'boolean') ? opt.autoReload : false;

	    // enable object notation?
	    objectNotation = (typeof opt.objectNotation !== 'undefined') ? opt.objectNotation : false;
	    if (objectNotation === true) objectNotation = '.';

	    // read language fallback map
	    fallbacks = (typeof opt.fallbacks === 'object') ? opt.fallbacks : {};

	    // setting custom logger functions
	    logDebugFn = (typeof opt.logDebugFn === 'function') ? opt.logDebugFn : debug;
	    logWarnFn = (typeof opt.logWarnFn === 'function') ? opt.logWarnFn : warn;
	    logErrorFn = (typeof opt.logErrorFn === 'function') ? opt.logErrorFn : error;

	    // when missing locales we try to guess that from directory
	    opt.locales = opt.locales || guessLocales(directory);

	    // implicitly read all locales
	    if (Array.isArray(opt.locales)) {

	      opt.locales.forEach(function(l) {
	        read(l);
	      });

	      // auto reload locale files when changed
	      if (autoReload) {

	        // watch changes of locale files (it's called twice because fs.watch is still unstable)
	        fs.watch(directory, function(event, filename) {
	          var localeFromFile = guessLocaleFromFile(filename);

	          if (localeFromFile && opt.locales.indexOf(localeFromFile) > -1) {
	            logDebug('Auto reloading locale file "' + filename + '".');
	            read(localeFromFile);
	          }

	        });
	      }
	    }
	  };

	  i18n.init = function i18nInit(request, response, next) {
	    if (typeof request === 'object') {

	      // guess requested language/locale
	      guessLanguage(request);

	      // bind api to req
	      applyAPItoObject(request);

	      // looks double but will ensure schema on api refactor
	      i18n.setLocale(request, request.locale);
	    } else {
	      return logError('i18n.init must be called with one parameter minimum, ie. i18n.init(req)');
	    }

	    if (typeof response === 'object') {
	      applyAPItoObject(response);

	      // and set that locale to response too
	      i18n.setLocale(response, request.locale);
	    }

	    // head over to next callback when bound as middleware
	    if (typeof next === 'function') {
	      return next();
	    }
	  };

	  i18n.__ = function i18nTranslate(phrase) {
	    var msg;
	    var argv = parseArgv(arguments);
	    var namedValues = argv[0];
	    var args = argv[1];

	    // called like __({phrase: "Hello", locale: "en"})
	    if (typeof phrase === 'object') {
	      if (typeof phrase.locale === 'string' && typeof phrase.phrase === 'string') {
	        msg = translate(phrase.locale, phrase.phrase);
	      }
	    }
	    // called like __("Hello")
	    else {
	      // get translated message with locale from scope (deprecated) or object
	      msg = translate(getLocaleFromObject(this), phrase);
	    }

	    // postprocess to get compatible to plurals
	    if (typeof msg === 'object' && msg.one) {
	      msg = msg.one;
	    }

	    // in case there is no 'one' but an 'other' rule
	    if (typeof msg === 'object' && msg.other) {
	      msg = msg.other;
	    }

	    // head over to postProcessing
	    return postProcess(msg, namedValues, args);
	  };

	  i18n.__mf = function i18nMessageformat(phrase) {
	    var msg, mf, f;
	    var targetLocale = defaultLocale;
	    var argv = parseArgv(arguments);
	    var namedValues = argv[0];
	    var args = argv[1];

	    // called like __({phrase: "Hello", locale: "en"})
	    if (typeof phrase === 'object') {
	      if (typeof phrase.locale === 'string' && typeof phrase.phrase === 'string') {
	        msg = phrase.phrase;
	        targetLocale = phrase.locale;
	      }
	    }
	    // called like __("Hello")
	    else {
	      // get translated message with locale from scope (deprecated) or object
	      msg = phrase;
	      targetLocale = getLocaleFromObject(this);
	    }

	    msg = translate(targetLocale, msg);
	    // --- end get msg

	    // now head over to Messageformat
	    // and try to cache instance
	    if (MessageformatInstanceForLocale[targetLocale]) {
	      mf = MessageformatInstanceForLocale[targetLocale];
	    } else {
	      mf = new Messageformat(targetLocale);
	      mf.compiledFunctions = {};
	      MessageformatInstanceForLocale[targetLocale] = mf;
	    }

	    // let's try to cache that function
	    if (mf.compiledFunctions[msg]) {
	      f = mf.compiledFunctions[msg];
	    } else {
	      f = mf.compile(msg);
	      mf.compiledFunctions[msg] = f;
	    }

	    return postProcess(f(namedValues), namedValues, args);
	  };

	  i18n.__l = function i18nTranslationList(phrase) {
	    var translations = [];
	    Object.keys(locales).sort().forEach(function(l) {
	      translations.push(i18n.__({ phrase: phrase, locale: l }));
	    });
	    return translations;
	  };

	  i18n.__h = function i18nTranslationHash(phrase) {
	    var translations = [];
	    Object.keys(locales).sort().forEach(function(l) {
	      var hash = {};
	      hash[l] = i18n.__({ phrase: phrase, locale: l });
	      translations.push(hash);
	    });
	    return translations;
	  };

	  i18n.__n = function i18nTranslatePlural(singular, plural, count) {
	    var msg, namedValues, targetLocale, args = [];

	    // Accept an object with named values as the last parameter
	    if (argsEndWithNamedObject(arguments)) {
	      namedValues = arguments[arguments.length - 1];
	      args = arguments.length >= 5 ? Array.prototype.slice.call(arguments, 3, -1) : [];
	    } else {
	      namedValues = {};
	      args = arguments.length >= 4 ? Array.prototype.slice.call(arguments, 3) : [];
	    }

	    // called like __n({singular: "%s cat", plural: "%s cats", locale: "en"}, 3)
	    if (typeof singular === 'object') {
	      if (
	        typeof singular.locale === 'string' &&
	        typeof singular.singular === 'string' &&
	        typeof singular.plural === 'string'
	      ) {
	        targetLocale = singular.locale;
	        msg = translate(singular.locale, singular.singular, singular.plural);
	      }
	      args.unshift(count);

	      // some template engines pass all values as strings -> so we try to convert them to numbers
	      if (typeof plural === 'number' || parseInt(plural, 10) + '' === plural) {
	        count = plural;
	      }

	      // called like __n({singular: "%s cat", plural: "%s cats", locale: "en", count: 3})
	      if (typeof singular.count === 'number' || typeof singular.count === 'string') {
	        count = singular.count;
	        args.unshift(plural);
	      }
	    } else {
	      // called like  __n('cat', 3)
	      if (typeof plural === 'number' || parseInt(plural, 10) + '' === plural) {
	        count = plural;

	        // we add same string as default
	        // which efectivly copies the key to the plural.value
	        // this is for initialization of new empty translations
	        plural = singular;

	        args.unshift(count);
	        args.unshift(plural);
	      }
	      // called like __n('%s cat', '%s cats', 3)
	      // get translated message with locale from scope (deprecated) or object
	      msg = translate(getLocaleFromObject(this), singular, plural);
	      targetLocale = getLocaleFromObject(this);
	    }

	    if (count === null) count = namedValues.count;

	    // enforce number
	    count = parseInt(count, 10);

	    // find the correct plural rule for given locale
	    if (typeof msg === 'object') {
	      var p;
	      // create a new Plural for locale
	      // and try to cache instance
	      if (PluralsForLocale[targetLocale]) {
	        p = PluralsForLocale[targetLocale];
	      } else {
	        // split locales with a region code
	        var lc = targetLocale.toLowerCase().split(/[_-\s]+/)
	          .filter(function(el){ return true && el; });
	        // take the first part of locale, fallback to full locale
	        p = new MakePlural(lc[0] || targetLocale);
	        PluralsForLocale[targetLocale] = p;
	      }

	      // fallback to 'other' on case of missing translations
	      msg = msg[p(count)] || msg.other;
	    }

	    // head over to postProcessing
	    return postProcess(msg, namedValues, args, count);
	  };

	  i18n.setLocale = function i18nSetLocale(object, locale, skipImplicitObjects) {

	    // when given an array of objects => setLocale on each
	    if (Array.isArray(object) && typeof locale === 'string') {
	      for (var i = object.length - 1; i >= 0; i--) {
	        i18n.setLocale(object[i], locale, true);
	      }
	      return i18n.getLocale(object[0]);
	    }

	    // defaults to called like i18n.setLocale(req, 'en')
	    var targetObject = object;
	    var targetLocale = locale;

	    // called like req.setLocale('en') or i18n.setLocale('en')
	    if (locale === undefined && typeof object === 'string') {
	      targetObject = this;
	      targetLocale = object;
	    }

	    // consider a fallback
	    if (!locales[targetLocale] && fallbacks[targetLocale]) {
	      targetLocale = fallbacks[targetLocale];
	    }

	    // now set locale on object
	    targetObject.locale = locales[targetLocale] ? targetLocale : defaultLocale;

	    // consider any extra registered objects
	    if (typeof register === 'object') {
	      if (Array.isArray(register) && !skipImplicitObjects) {
	        register.forEach(function(r) {
	          r.locale = targetObject.locale;
	        });
	      } else {
	        register.locale = targetObject.locale;
	      }
	    }

	    // consider res
	    if (targetObject.res && !skipImplicitObjects) {

	      // escape recursion
	      // @see  - https://github.com/balderdashy/sails/pull/3631
	      //       - https://github.com/mashpie/i18n-node/pull/218
	      if (targetObject.res.locals) {
	        i18n.setLocale(targetObject.res, targetObject.locale, true);
	        i18n.setLocale(targetObject.res.locals, targetObject.locale, true);
	      } else {
	        i18n.setLocale(targetObject.res, targetObject.locale);
	      }
	    }

	    // consider locals
	    if (targetObject.locals && !skipImplicitObjects) {

	      // escape recursion
	      // @see  - https://github.com/balderdashy/sails/pull/3631
	      //       - https://github.com/mashpie/i18n-node/pull/218
	      if (targetObject.locals.res) {
	        i18n.setLocale(targetObject.locals, targetObject.locale, true);
	        i18n.setLocale(targetObject.locals.res, targetObject.locale, true);
	      } else {
	        i18n.setLocale(targetObject.locals, targetObject.locale);
	      }
	    }

	    return i18n.getLocale(targetObject);
	  };

	  i18n.getLocale = function i18nGetLocale(request) {

	    // called like i18n.getLocale(req)
	    if (request && request.locale) {
	      return request.locale;
	    }

	    // called like req.getLocale()
	    return this.locale || defaultLocale;
	  };

	  i18n.getCatalog = function i18nGetCatalog(object, locale) {
	    var targetLocale;

	    // called like i18n.getCatalog(req)
	    if (typeof object === 'object' && typeof object.locale === 'string' && locale === undefined) {
	      targetLocale = object.locale;
	    }

	    // called like i18n.getCatalog(req, 'en')
	    if (!targetLocale && typeof object === 'object' && typeof locale === 'string') {
	      targetLocale = locale;
	    }

	    // called like req.getCatalog('en')
	    if (!targetLocale && locale === undefined && typeof object === 'string') {
	      targetLocale = object;
	    }

	    // called like req.getCatalog()
	    if (!targetLocale &&
	      object === undefined &&
	      locale === undefined &&
	      typeof this.locale === 'string'
	    ) {
	      if (register && register.GLOBAL) {
	        targetLocale = '';
	      } else {
	        targetLocale = this.locale;
	      }
	    }

	    // called like i18n.getCatalog()
	    if (targetLocale === undefined || targetLocale === '') {
	      return locales;
	    }

	    if (!locales[targetLocale] && fallbacks[targetLocale]) {
	      targetLocale = fallbacks[targetLocale];
	    }

	    if (locales[targetLocale]) {
	      return locales[targetLocale];
	    } else {
	      logWarn('No catalog found for "' + targetLocale + '"');
	      return false;
	    }
	  };

	  i18n.getLocales = function i18nGetLocales() {
	    return Object.keys(locales);
	  };

	  i18n.addLocale = function i18nAddLocale(locale) {
	    read(locale);
	  };

	  i18n.removeLocale = function i18nRemoveLocale(locale) {
	    delete locales[locale];
	  };

	  // ===================
	  // = private methods =
	  // ===================

	  var postProcess = function(msg, namedValues, args, count) {

	    // test for parsable interval string
	    if ((/\|/).test(msg)) {
	      msg = parsePluralInterval(msg, count);
	    }

	    // replace the counter
	    if (typeof count === 'number') {
	      msg = vsprintf(msg, [parseInt(count, 10)]);
	    }

	    // if the msg string contains {{Mustache}} patterns we render it as a mini tempalate
	    if ((/{{.*}}/).test(msg)) {
	      msg = Mustache.render(msg, namedValues);
	    }

	    // if we have extra arguments with values to get replaced,
	    // an additional substition injects those strings afterwards
	    if ((/%/).test(msg) && args && args.length > 0) {
	      msg = vsprintf(msg, args);
	    }

	    return msg;
	  };

	  var argsEndWithNamedObject = function(args) {
	    return (args.length > 1 &&
	      args[args.length - 1] !== null &&
	      typeof args[args.length - 1] === 'object');
	  };

	  var parseArgv = function(args) {
	    var namedValues, returnArgs;

	    if (argsEndWithNamedObject(args)) {
	      namedValues = args[args.length - 1];
	      returnArgs = Array.prototype.slice.call(args, 1, -1);
	    } else {
	      namedValues = {};
	      returnArgs = args.length >= 2 ? Array.prototype.slice.call(args, 1) : [];
	    }

	    return [namedValues, returnArgs];
	  };

	  /**
	   * registers all public API methods to a given response object when not already declared
	   */
	  var applyAPItoObject = function(object) {

	    var alreadySetted = true;

	    // attach to itself if not provided
	    for (var method in api) {
	      if (api.hasOwnProperty(method)) {
	        var alias = api[method];

	        // be kind rewind, or better not touch anything already existing
	        if (!object[alias]) {
	          alreadySetted = false;
	          object[alias] = i18n[method].bind(object);
	        }
	      }
	    }

	    // set initial locale if not set
	    if (!object.locale) {
	      object.locale = defaultLocale;
	    }

	    // escape recursion
	    if (alreadySetted) {
	      return;
	    }

	    // attach to response if present (ie. in express)
	    if (object.res) {
	      applyAPItoObject(object.res);
	    }

	    // attach to locals if present (ie. in express)
	    if (object.locals) {
	      applyAPItoObject(object.locals);
	    }
	  };

	  /**
	   * tries to guess locales by scanning the given directory
	   */
	  var guessLocales = function(directory) {
	    var entries = fs.readdirSync(directory);
	    var localesFound = [];

	    for (var i = entries.length - 1; i >= 0; i--) {
	      if (entries[i].match(/^\./)) continue;
	      var localeFromFile = guessLocaleFromFile(entries[i]);
	      if (localeFromFile) localesFound.push(localeFromFile);
	    }

	    return localesFound.sort();
	  };

	  /**
	   * tries to guess locales from a given filename
	   */
	  var guessLocaleFromFile = function(filename) {
	    var extensionRegex = new RegExp(extension + '$', 'g');
	    var prefixRegex = new RegExp('^' + prefix, 'g');

	    if (prefix && !filename.match(prefixRegex)) return false;
	    if (extension && !filename.match(extensionRegex)) return false;
	    return filename.replace(prefix, '').replace(extensionRegex, '');
	  };

	  /**
	   * guess language setting based on http headers
	   */

	  var guessLanguage = function(request) {
	    if (typeof request === 'object') {
	      var languageHeader = request.headers? request.headers['accept-language'] : undefined,
	        languages = [],
	        regions = [];

	      request.languages = [defaultLocale];
	      request.regions = [defaultLocale];
	      request.language = defaultLocale;
	      request.region = defaultLocale;

	      // a query parameter overwrites all
	      if (queryParameter && request.url) {
	        var urlObj = url.parse(request.url, true);
	        if (urlObj.query[queryParameter]) {
	          logDebug('Overriding locale from query: ' + urlObj.query[queryParameter]);
	          request.language = urlObj.query[queryParameter].toLowerCase();
	          return i18n.setLocale(request, request.language);
	        }
	      }

	      // a cookie overwrites headers
	      if (cookiename && request.cookies && request.cookies[cookiename]) {
	        request.language = request.cookies[cookiename];
	        return i18n.setLocale(request, request.language);
	      }

	      // 'accept-language' is the most common source
	      if (languageHeader) {
	        var acceptedLanguages = getAcceptedLanguagesFromHeader(languageHeader),
	          match, fallbackMatch, fallback;
	        for (var i = 0; i < acceptedLanguages.length; i++) {
	          var lang = acceptedLanguages[i],
	            lr = lang.split('-', 2),
	            parentLang = lr[0],
	            region = lr[1];

	          // Check if we have a configured fallback set for this language.
	          if (fallbacks && fallbacks[lang]) {
	            fallback = fallbacks[lang];
	            // Fallbacks for languages should be inserted
	            // where the original, unsupported language existed.
	            var acceptedLanguageIndex = acceptedLanguages.indexOf(lang);
	            var fallbackIndex = acceptedLanguages.indexOf(fallback);
	            if(fallbackIndex > -1) {
	              acceptedLanguages.splice(fallbackIndex, 1);
	            }
	            acceptedLanguages.splice(acceptedLanguageIndex + 1, 0, fallback);
	          }

	          // Check if we have a configured fallback set for the parent language of the locale.
	          if (fallbacks && fallbacks[parentLang]) {
	            fallback = fallbacks[parentLang];
	            // Fallbacks for a parent language should be inserted
	            // to the end of the list, so they're only picked
	            // if there is no better match.
	            if (acceptedLanguages.indexOf(fallback) < 0) {
	              acceptedLanguages.push(fallback);
	            }
	          }

	          if (languages.indexOf(parentLang) < 0) {
	            languages.push(parentLang.toLowerCase());
	          }
	          if (region) {
	            regions.push(region.toLowerCase());
	          }

	          if (!match && locales[lang]) {
	            match = lang;
	            break;
	          }

	          if (!fallbackMatch && locales[parentLang]) {
	            fallbackMatch = parentLang;
	          }
	        }

	        request.language = match || fallbackMatch || request.language;
	        request.region = regions[0] || request.region;
	        return i18n.setLocale(request, request.language);
	      }
	    }

	    // last resort: defaultLocale
	    return i18n.setLocale(request, defaultLocale);
	  };

	  /**
	   * Get a sorted list of accepted languages from the HTTP Accept-Language header
	   */
	  var getAcceptedLanguagesFromHeader = function(header) {
	    var languages = header.split(','),
	      preferences = {};
	    return languages.map(function parseLanguagePreference(item) {
	      var preferenceParts = item.trim().split(';q=');
	      if (preferenceParts.length < 2) {
	        preferenceParts[1] = 1.0;
	      } else {
	        var quality = parseFloat(preferenceParts[1]);
	        preferenceParts[1] = quality ? quality : 0.0;
	      }
	      preferences[preferenceParts[0]] = preferenceParts[1];

	      return preferenceParts[0];
	    }).filter(function(lang) {
	      return preferences[lang] > 0;
	    }).sort(function sortLanguages(a, b) {
	      return preferences[b] - preferences[a];
	    });
	  };

	  /**
	   * searches for locale in given object
	   */

	  var getLocaleFromObject = function(obj) {
	    var locale;
	    if (obj && obj.scope) {
	      locale = obj.scope.locale;
	    }
	    if (obj && obj.locale) {
	      locale = obj.locale;
	    }
	    return locale;
	  };

	  /**
	   * splits and parses a phrase for mathematical interval expressions
	   */
	  var parsePluralInterval = function(phrase, count) {
	    var returnPhrase = phrase;
	    var phrases = phrase.split(/\|/);

	    // some() breaks on 1st true
	    phrases.some(function(p) {
	      var matches = p.match(/^\s*([\(\)\[\]\d,]+)?\s*(.*)$/);

	      // not the same as in combined condition
	      if (matches[1]) {
	        if (matchInterval(count, matches[1]) === true) {
	          returnPhrase = matches[2];
	          return true;
	        }
	      } else {
	        returnPhrase = p;
	      }

	    });
	    return returnPhrase;
	  };

	  /**
	   * test a number to match mathematical interval expressions
	   * [0,2] - 0 to 2 (including, matches: 0, 1, 2)
	   * ]0,3[ - 0 to 3 (excluding, matches: 1, 2)
	   * [1]   - 1 (matches: 1)
	   * [20,] - all numbers ≥20 (matches: 20, 21, 22, ...)
	   * [,20] - all numbers ≤20 (matches: 20, 21, 22, ...)
	   */
	  var matchInterval = function(number, interval) {
	    interval = parseInterval(interval);
	    if (interval && typeof number === 'number') {
	      if (interval.from.value === number) {
	        return interval.from.included;
	      }
	      if (interval.to.value === number) {
	        return interval.to.included;
	      }

	      return (Math.min(interval.from.value, number) === interval.from.value &&
	        Math.max(interval.to.value, number) === interval.to.value);
	    }
	    return false;
	  };

	  /**
	   * read locale file, translate a msg and write to fs if new
	   */
	  var translate = function(locale, singular, plural, skipSyncToAllFiles) {

	    // add same key to all translations
	    if (!skipSyncToAllFiles && syncFiles) {
	      syncToAllFiles(singular, plural);
	    }

	    if (locale === undefined) {
	      logWarn('WARN: No locale found - check the context of the call to __(). Using ' +
	        defaultLocale + ' as current locale');
	      locale = defaultLocale;
	    }

	    if (!locales[locale] && fallbacks[locale]) {
	      locale = fallbacks[locale];
	    }

	    // attempt to read when defined as valid locale
	    if (!locales[locale]) {
	      read(locale);
	    }

	    // fallback to default when missed
	    if (!locales[locale]) {

	      logWarn('WARN: Locale ' + locale +
	        ' couldn\'t be read - check the context of the call to $__. Using ' +
	        defaultLocale + ' (default) as current locale');

	      locale = defaultLocale;
	      read(locale);
	    }

	    // dotnotaction add on, @todo: factor out
	    var defaultSingular = singular;
	    var defaultPlural = plural;
	    if (objectNotation) {
	      var indexOfColon = singular.indexOf(':');
	      // We compare against 0 instead of -1 because
	      // we don't really expect the string to start with ':'.
	      if (0 < indexOfColon) {
	        defaultSingular = singular.substring(indexOfColon + 1);
	        singular = singular.substring(0, indexOfColon);
	      }
	      if (plural && typeof plural !== 'number') {
	        indexOfColon = plural.indexOf(':');
	        if (0 < indexOfColon) {
	          defaultPlural = plural.substring(indexOfColon + 1);
	          plural = plural.substring(0, indexOfColon);
	        }
	      }
	    }

	    var accessor = localeAccessor(locale, singular);
	    var mutator = localeMutator(locale, singular);

	    if (plural) {
	      if (!accessor()) {
	        mutator({
	          'one': defaultSingular || singular,
	          'other': defaultPlural || plural
	        });
	        write(locale);
	      }
	    }

	    if (!accessor()) {
	      mutator(defaultSingular || singular);
	      write(locale);
	    }

	    return accessor();
	  };

	  /**
	   * initialize the same key in all locales
	   * when not already existing, checked via translate
	   */
	  var syncToAllFiles = function(singular, plural) {
	    // iterate over locales and translate again
	    // this will implicitly write/sync missing keys
	    // to the rest of locales
	    for (var l in locales) {
	      translate(l, singular, plural, true);
	    }
	  };

	  /**
	   * Allows delayed access to translations nested inside objects.
	   * @param {String} locale The locale to use.
	   * @param {String} singular The singular term to look up.
	   * @param {Boolean} [allowDelayedTraversal=true] Is delayed traversal of the tree allowed?
	   * This parameter is used internally. It allows to signal the accessor that
	   * a translation was not found in the initial lookup and that an invocation
	   * of the accessor may trigger another traversal of the tree.
	   * @returns {Function} A function that, when invoked, returns the current value stored
	   * in the object at the requested location.
	   */
	  var localeAccessor = function(locale, singular, allowDelayedTraversal) {
	    // Bail out on non-existent locales to defend against internal errors.
	    if (!locales[locale]) return Function.prototype;

	    // Handle object lookup notation
	    var indexOfDot = objectNotation && singular.lastIndexOf(objectNotation);
	    if (objectNotation && (0 < indexOfDot && indexOfDot < singular.length - 1)) {
	      // If delayed traversal wasn't specifically forbidden, it is allowed.
	      if (typeof allowDelayedTraversal === 'undefined') allowDelayedTraversal = true;
	      // The accessor we're trying to find and which we want to return.
	      var accessor = null;
	      // An accessor that returns null.
	      var nullAccessor = function() {
	        return null;
	      };
	      // Do we need to re-traverse the tree upon invocation of the accessor?
	      var reTraverse = false;
	      // Split the provided term and run the callback for each subterm.
	      singular.split(objectNotation).reduce(function(object, index) {
	        // Make the accessor return null.
	        accessor = nullAccessor;
	        // If our current target object (in the locale tree) doesn't exist or
	        // it doesn't have the next subterm as a member...
	        if (null === object || !object.hasOwnProperty(index)) {
	          // ...remember that we need retraversal (because we didn't find our target).
	          reTraverse = allowDelayedTraversal;
	          // Return null to avoid deeper iterations.
	          return null;
	        }
	        // We can traverse deeper, so we generate an accessor for this current level.
	        accessor = function() {
	          return object[index];
	        };
	        // Return a reference to the next deeper level in the locale tree.
	        return object[index];

	      }, locales[locale]);
	      // Return the requested accessor.
	      return function() {
	        // If we need to re-traverse (because we didn't find our target term)
	        // traverse again and return the new result (but don't allow further iterations)
	        // or return the previously found accessor if it was already valid.
	        return (reTraverse) ? localeAccessor(locale, singular, false)() : accessor();
	      };

	    } else {
	      // No object notation, just return an accessor that performs array lookup.
	      return function() {
	        return locales[locale][singular];
	      };
	    }
	  };

	  /**
	   * Allows delayed mutation of a translation nested inside objects.
	   * @description Construction of the mutator will attempt to locate the requested term
	   * inside the object, but if part of the branch does not exist yet, it will not be
	   * created until the mutator is actually invoked. At that point, re-traversal of the
	   * tree is performed and missing parts along the branch will be created.
	   * @param {String} locale The locale to use.
	   * @param {String} singular The singular term to look up.
	   * @param [Boolean} [allowBranching=false] Is the mutator allowed to create previously
	   * non-existent branches along the requested locale path?
	   * @returns {Function} A function that takes one argument. When the function is
	   * invoked, the targeted translation term will be set to the given value inside the locale table.
	   */
	  var localeMutator = function(locale, singular, allowBranching) {
	    // Bail out on non-existent locales to defend against internal errors.
	    if (!locales[locale]) return Function.prototype;

	    // Handle object lookup notation
	    var indexOfDot = objectNotation && singular.lastIndexOf(objectNotation);
	    if (objectNotation && (0 < indexOfDot && indexOfDot < singular.length - 1)) {
	      // If branching wasn't specifically allowed, disable it.
	      if (typeof allowBranching === 'undefined') allowBranching = false;
	      // This will become the function we want to return.
	      var accessor = null;
	      // An accessor that takes one argument and returns null.
	      var nullAccessor = function() {
	        return null;
	      };
	      // Fix object path.
	      var fixObject = function() {
	        return {};
	      };
	      // Are we going to need to re-traverse the tree when the mutator is invoked?
	      var reTraverse = false;
	      // Split the provided term and run the callback for each subterm.
	      singular.split(objectNotation).reduce(function(object, index) {
	        // Make the mutator do nothing.
	        accessor = nullAccessor;
	        // If our current target object (in the locale tree) doesn't exist or
	        // it doesn't have the next subterm as a member...
	        if (null === object || !object.hasOwnProperty(index)) {
	          // ...check if we're allowed to create new branches.
	          if (allowBranching) {
	            // Fix `object` if `object` is not Object.
	            if (null === object || typeof object !== 'object') {
	              object = fixObject();
	            }
	            // If we are allowed to, create a new object along the path.
	            object[index] = {};
	          } else {
	            // If we aren't allowed, remember that we need to re-traverse later on and...
	            reTraverse = true;
	            // ...return null to make the next iteration bail our early on.
	            return null;
	          }
	        }
	        // Generate a mutator for the current level.
	        accessor = function(value) {
	          object[index] = value;
	          return value;
	        };
	        // Generate a fixer for the current level.
	        fixObject = function() {
	          object[index] = {};
	          return object[index];
	        };

	        // Return a reference to the next deeper level in the locale tree.
	        return object[index];

	      }, locales[locale]);

	      // Return the final mutator.
	      return function(value) {
	        // If we need to re-traverse the tree
	        // invoke the search again, but allow branching
	        // this time (because here the mutator is being invoked)
	        // otherwise, just change the value directly.
	        return (reTraverse) ? localeMutator(locale, singular, true)(value) : accessor(value);
	      };

	    } else {
	      // No object notation, just return a mutator that performs array lookup and changes the value.
	      return function(value) {
	        locales[locale][singular] = value;
	        return value;
	      };
	    }
	  };

	  /**
	   * try reading a file
	   */
	  var read = function(locale) {
	    var localeFile = {},
	      file = getStorageFilePath(locale);
	    try {
	      logDebug('read ' + file + ' for locale: ' + locale);
	      localeFile = fs.readFileSync(file);
	      try {
	        // parsing filecontents to locales[locale]
	        locales[locale] = JSON.parse(localeFile);
	      } catch (parseError) {
	        logError('unable to parse locales from file (maybe ' +
	          file + ' is empty or invalid json?): ', parseError);
	      }
	    } catch (readError) {
	      // unable to read, so intialize that file
	      // locales[locale] are already set in memory, so no extra read required
	      // or locales[locale] are empty, which initializes an empty locale.json file

	      // since the current invalid locale could exist, we should back it up
	      if (fs.existsSync(file)) {
	        logDebug('backing up invalid locale ' + locale + ' to ' + file + '.invalid');
	        fs.renameSync(file, file + '.invalid');
	      }

	      logDebug('initializing ' + file);
	      write(locale);
	    }
	  };

	  /**
	   * try writing a file in a created directory
	   */
	  var write = function(locale) {
	    var stats, target, tmp;

	    // don't write new locale information to disk if updateFiles isn't true
	    if (!updateFiles) {
	      return;
	    }

	    // creating directory if necessary
	    try {
	      stats = fs.lstatSync(directory);
	    } catch (e) {
	      logDebug('creating locales dir in: ' + directory);
	      fs.mkdirSync(directory, directoryPermissions);
	    }

	    // first time init has an empty file
	    if (!locales[locale]) {
	      locales[locale] = {};
	    }

	    // writing to tmp and rename on success
	    try {
	      target = getStorageFilePath(locale);
	      tmp = target + '.tmp';
	      fs.writeFileSync(tmp, JSON.stringify(locales[locale], null, indent), 'utf8');
	      stats = fs.statSync(tmp);
	      if (stats.isFile()) {
	        fs.renameSync(tmp, target);
	      } else {
	        logError('unable to write locales to file (either ' +
	          tmp + ' or ' + target + ' are not writeable?): ');
	      }
	    } catch (e) {
	      logError('unexpected error writing files (either ' +
	        tmp + ' or ' + target + ' are not writeable?): ', e);
	    }
	  };

	  /**
	   * basic normalization of filepath
	   */
	  var getStorageFilePath = function(locale) {
	    // changed API to use .json as default, #16
	    var ext = extension || '.json',
	      filepath = path.normalize(directory + pathsep + prefix + locale + ext),
	      filepathJS = path.normalize(directory + pathsep + prefix + locale + '.js');
	    // use .js as fallback if already existing
	    try {
	      if (fs.statSync(filepathJS)) {
	        logDebug('using existing file ' + filepathJS);
	        extension = '.js';
	        return filepathJS;
	      }
	    } catch (e) {
	      logDebug('will use ' + filepath);
	    }
	    return filepath;
	  };

	  /**
	   * Logging proxies
	   */
	  function logDebug(msg) {
	    logDebugFn(msg);
	  }

	  function logWarn(msg) {
	    logWarnFn(msg);
	  }

	  function logError(msg) {
	    logErrorFn(msg);
	  }

	  return i18n;

	}());

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	(function(window) {
	    var re = {
	        not_string: /[^s]/,
	        number: /[diefg]/,
	        json: /[j]/,
	        not_json: /[^j]/,
	        text: /^[^\x25]+/,
	        modulo: /^\x25{2}/,
	        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijosuxX])/,
	        key: /^([a-z_][a-z_\d]*)/i,
	        key_access: /^\.([a-z_][a-z_\d]*)/i,
	        index_access: /^\[(\d+)\]/,
	        sign: /^[\+\-]/
	    }

	    function sprintf() {
	        var key = arguments[0], cache = sprintf.cache
	        if (!(cache[key] && cache.hasOwnProperty(key))) {
	            cache[key] = sprintf.parse(key)
	        }
	        return sprintf.format.call(null, cache[key], arguments)
	    }

	    sprintf.format = function(parse_tree, argv) {
	        var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = ""
	        for (i = 0; i < tree_length; i++) {
	            node_type = get_type(parse_tree[i])
	            if (node_type === "string") {
	                output[output.length] = parse_tree[i]
	            }
	            else if (node_type === "array") {
	                match = parse_tree[i] // convenience purposes only
	                if (match[2]) { // keyword argument
	                    arg = argv[cursor]
	                    for (k = 0; k < match[2].length; k++) {
	                        if (!arg.hasOwnProperty(match[2][k])) {
	                            throw new Error(sprintf("[sprintf] property '%s' does not exist", match[2][k]))
	                        }
	                        arg = arg[match[2][k]]
	                    }
	                }
	                else if (match[1]) { // positional argument (explicit)
	                    arg = argv[match[1]]
	                }
	                else { // positional argument (implicit)
	                    arg = argv[cursor++]
	                }

	                if (get_type(arg) == "function") {
	                    arg = arg()
	                }

	                if (re.not_string.test(match[8]) && re.not_json.test(match[8]) && (get_type(arg) != "number" && isNaN(arg))) {
	                    throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)))
	                }

	                if (re.number.test(match[8])) {
	                    is_positive = arg >= 0
	                }

	                switch (match[8]) {
	                    case "b":
	                        arg = arg.toString(2)
	                    break
	                    case "c":
	                        arg = String.fromCharCode(arg)
	                    break
	                    case "d":
	                    case "i":
	                        arg = parseInt(arg, 10)
	                    break
	                    case "j":
	                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)
	                    break
	                    case "e":
	                        arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential()
	                    break
	                    case "f":
	                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)
	                    break
	                    case "g":
	                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg)
	                    break
	                    case "o":
	                        arg = arg.toString(8)
	                    break
	                    case "s":
	                        arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg)
	                    break
	                    case "u":
	                        arg = arg >>> 0
	                    break
	                    case "x":
	                        arg = arg.toString(16)
	                    break
	                    case "X":
	                        arg = arg.toString(16).toUpperCase()
	                    break
	                }
	                if (re.json.test(match[8])) {
	                    output[output.length] = arg
	                }
	                else {
	                    if (re.number.test(match[8]) && (!is_positive || match[3])) {
	                        sign = is_positive ? "+" : "-"
	                        arg = arg.toString().replace(re.sign, "")
	                    }
	                    else {
	                        sign = ""
	                    }
	                    pad_character = match[4] ? match[4] === "0" ? "0" : match[4].charAt(1) : " "
	                    pad_length = match[6] - (sign + arg).length
	                    pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : "") : ""
	                    output[output.length] = match[5] ? sign + arg + pad : (pad_character === "0" ? sign + pad + arg : pad + sign + arg)
	                }
	            }
	        }
	        return output.join("")
	    }

	    sprintf.cache = {}

	    sprintf.parse = function(fmt) {
	        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0
	        while (_fmt) {
	            if ((match = re.text.exec(_fmt)) !== null) {
	                parse_tree[parse_tree.length] = match[0]
	            }
	            else if ((match = re.modulo.exec(_fmt)) !== null) {
	                parse_tree[parse_tree.length] = "%"
	            }
	            else if ((match = re.placeholder.exec(_fmt)) !== null) {
	                if (match[2]) {
	                    arg_names |= 1
	                    var field_list = [], replacement_field = match[2], field_match = []
	                    if ((field_match = re.key.exec(replacement_field)) !== null) {
	                        field_list[field_list.length] = field_match[1]
	                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
	                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
	                                field_list[field_list.length] = field_match[1]
	                            }
	                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
	                                field_list[field_list.length] = field_match[1]
	                            }
	                            else {
	                                throw new SyntaxError("[sprintf] failed to parse named argument key")
	                            }
	                        }
	                    }
	                    else {
	                        throw new SyntaxError("[sprintf] failed to parse named argument key")
	                    }
	                    match[2] = field_list
	                }
	                else {
	                    arg_names |= 2
	                }
	                if (arg_names === 3) {
	                    throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported")
	                }
	                parse_tree[parse_tree.length] = match
	            }
	            else {
	                throw new SyntaxError("[sprintf] unexpected placeholder")
	            }
	            _fmt = _fmt.substring(match[0].length)
	        }
	        return parse_tree
	    }

	    var vsprintf = function(fmt, argv, _argv) {
	        _argv = (argv || []).slice(0)
	        _argv.splice(0, 0, fmt)
	        return sprintf.apply(null, _argv)
	    }

	    /**
	     * helpers
	     */
	    function get_type(variable) {
	        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()
	    }

	    function str_repeat(input, multiplier) {
	        return Array(multiplier + 1).join(input)
	    }

	    /**
	     * export to either browser or node.js
	     */
	    if (true) {
	        exports.sprintf = sprintf
	        exports.vsprintf = vsprintf
	    }
	    else {
	        window.sprintf = sprintf
	        window.vsprintf = vsprintf

	        if (typeof define === "function" && define.amd) {
	            define(function() {
	                return {
	                    sprintf: sprintf,
	                    vsprintf: vsprintf
	                }
	            })
	        }
	    }
	})(typeof window === "undefined" ? this : window);


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Detect Electron renderer process, which is node, but we should
	 * treat as a browser.
	 */

	if (typeof process !== 'undefined' && process.type === 'renderer') {
	  module.exports = __webpack_require__(11);
	} else {
	  module.exports = __webpack_require__(14);
	}


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = __webpack_require__(12);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();

	/**
	 * Colors.
	 */

	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];

	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */

	function useColors() {
	  // NB: In an Electron preload script, document will be defined but not fully
	  // initialized. Since we know we're in Chrome, we'll just detect this case
	  // explicitly
	  if (typeof window !== 'undefined' && window && typeof window.process !== 'undefined' && window.process.type === 'renderer') {
	    return true;
	  }

	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	  return (typeof document !== 'undefined' && document && 'WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (typeof window !== 'undefined' && window && window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
	    // double check webkit in userAgent just in case we are in a worker
	    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
	}

	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */

	exports.formatters.j = function(v) {
	  try {
	    return JSON.stringify(v);
	  } catch (err) {
	    return '[UnexpectedJSONParseError]: ' + err.message;
	  }
	};


	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */

	function formatArgs(args) {
	  var useColors = this.useColors;

	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);

	  if (!useColors) return;

	  var c = 'color: ' + this.color;
	  args.splice(1, 0, c, 'color: inherit')

	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-zA-Z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });

	  args.splice(lastC, 0, c);
	}

	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */

	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  try {
	    return exports.storage.debug;
	  } catch(e) {}

	  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	  if (typeof process !== 'undefined' && 'env' in process) {
	    return process.env.DEBUG;
	  }
	}

	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */

	exports.enable(load());

	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */

	function localstorage() {
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(13);

	/**
	 * The currently active debug mode names, and names to skip.
	 */

	exports.names = [];
	exports.skips = [];

	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	 */

	exports.formatters = {};

	/**
	 * Previous log timestamp.
	 */

	var prevTime;

	/**
	 * Select a color.
	 * @param {String} namespace
	 * @return {Number}
	 * @api private
	 */

	function selectColor(namespace) {
	  var hash = 0, i;

	  for (i in namespace) {
	    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
	    hash |= 0; // Convert to 32bit integer
	  }

	  return exports.colors[Math.abs(hash) % exports.colors.length];
	}

	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */

	function createDebug(namespace) {

	  function debug() {
	    // disabled?
	    if (!debug.enabled) return;

	    var self = debug;

	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;

	    // turn the `arguments` into a proper Array
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }

	    args[0] = exports.coerce(args[0]);

	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %O
	      args.unshift('%O');
	    }

	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);

	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });

	    // apply env-specific formatting (colors, etc.)
	    exports.formatArgs.call(self, args);

	    var logFn = debug.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }

	  debug.namespace = namespace;
	  debug.enabled = exports.enabled(namespace);
	  debug.useColors = exports.useColors();
	  debug.color = selectColor(namespace);

	  // env-specific initialization logic for debug instances
	  if ('function' === typeof exports.init) {
	    exports.init(debug);
	  }

	  return debug;
	}

	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */

	function enable(namespaces) {
	  exports.save(namespaces);

	  exports.names = [];
	  exports.skips = [];

	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;

	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	function disable() {
	  exports.enable('');
	}

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 13 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */

	var s = 1000
	var m = s * 60
	var h = m * 60
	var d = h * 24
	var y = d * 365.25

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	module.exports = function (val, options) {
	  options = options || {}
	  var type = typeof val
	  if (type === 'string' && val.length > 0) {
	    return parse(val)
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ?
				fmtLong(val) :
				fmtShort(val)
	  }
	  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))
	}

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str)
	  if (str.length > 10000) {
	    return
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)
	  if (!match) {
	    return
	  }
	  var n = parseFloat(match[1])
	  var type = (match[2] || 'ms').toLowerCase()
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n
	    default:
	      return undefined
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd'
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h'
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm'
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's'
	  }
	  return ms + 'ms'
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  return plural(ms, d, 'day') ||
	    plural(ms, h, 'hour') ||
	    plural(ms, m, 'minute') ||
	    plural(ms, s, 'second') ||
	    ms + ' ms'
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) {
	    return
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's'
	}


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var tty = __webpack_require__(15);
	var util = __webpack_require__(16);

	/**
	 * This is the Node.js implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = __webpack_require__(12);
	exports.init = init;
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;

	/**
	 * Colors.
	 */

	exports.colors = [6, 2, 3, 4, 5, 1];

	/**
	 * Build up the default `inspectOpts` object from the environment variables.
	 *
	 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
	 */

	exports.inspectOpts = Object.keys(process.env).filter(function (key) {
	  return /^debug_/i.test(key);
	}).reduce(function (obj, key) {
	  // camel-case
	  var prop = key
	    .substring(6)
	    .toLowerCase()
	    .replace(/_([a-z])/, function (_, k) { return k.toUpperCase() });

	  // coerce string value into JS value
	  var val = process.env[key];
	  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
	  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
	  else if (val === 'null') val = null;
	  else val = Number(val);

	  obj[prop] = val;
	  return obj;
	}, {});

	/**
	 * The file descriptor to write the `debug()` calls to.
	 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
	 *
	 *   $ DEBUG_FD=3 node script.js 3>debug.log
	 */

	var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

	if (1 !== fd && 2 !== fd) {
	  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()
	}

	var stream = 1 === fd ? process.stdout :
	             2 === fd ? process.stderr :
	             createWritableStdioStream(fd);

	/**
	 * Is stdout a TTY? Colored output is enabled when `true`.
	 */

	function useColors() {
	  return 'colors' in exports.inspectOpts
	    ? Boolean(exports.inspectOpts.colors)
	    : tty.isatty(fd);
	}

	/**
	 * Map %o to `util.inspect()`, all on a single line.
	 */

	exports.formatters.o = function(v) {
	  this.inspectOpts.colors = this.useColors;
	  return util.inspect(v, this.inspectOpts)
	    .replace(/\s*\n\s*/g, ' ');
	};

	/**
	 * Map %o to `util.inspect()`, allowing multiple lines if needed.
	 */

	exports.formatters.O = function(v) {
	  this.inspectOpts.colors = this.useColors;
	  return util.inspect(v, this.inspectOpts);
	};

	/**
	 * Adds ANSI color escape codes if enabled.
	 *
	 * @api public
	 */

	function formatArgs(args) {
	  var name = this.namespace;
	  var useColors = this.useColors;

	  if (useColors) {
	    var c = this.color;
	    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

	    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
	    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
	  } else {
	    args[0] = new Date().toUTCString()
	      + ' ' + name + ' ' + args[0];
	  }
	}

	/**
	 * Invokes `util.format()` with the specified arguments and writes to `stream`.
	 */

	function log() {
	  return stream.write(util.format.apply(util, arguments) + '\n');
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  if (null == namespaces) {
	    // If you set a process.env field to null or undefined, it gets cast to the
	    // string 'null' or 'undefined'. Just delete instead.
	    delete process.env.DEBUG;
	  } else {
	    process.env.DEBUG = namespaces;
	  }
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  return process.env.DEBUG;
	}

	/**
	 * Copied from `node/src/node.js`.
	 *
	 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
	 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
	 */

	function createWritableStdioStream (fd) {
	  var stream;
	  var tty_wrap = process.binding('tty_wrap');

	  // Note stream._type is used for test-module-load-list.js

	  switch (tty_wrap.guessHandleType(fd)) {
	    case 'TTY':
	      stream = new tty.WriteStream(fd);
	      stream._type = 'tty';

	      // Hack to have stream not keep the event loop alive.
	      // See https://github.com/joyent/node/issues/1726
	      if (stream._handle && stream._handle.unref) {
	        stream._handle.unref();
	      }
	      break;

	    case 'FILE':
	      var fs = __webpack_require__(2);
	      stream = new fs.SyncWriteStream(fd, { autoClose: false });
	      stream._type = 'fs';
	      break;

	    case 'PIPE':
	    case 'TCP':
	      var net = __webpack_require__(17);
	      stream = new net.Socket({
	        fd: fd,
	        readable: false,
	        writable: true
	      });

	      // FIXME Should probably have an option in net.Socket to create a
	      // stream from an existing fd which is writable only. But for now
	      // we'll just add this hack and set the `readable` member to false.
	      // Test: ./node test/fixtures/echo.js < /etc/passwd
	      stream.readable = false;
	      stream.read = null;
	      stream._type = 'pipe';

	      // FIXME Hack to have stream not keep the event loop alive.
	      // See https://github.com/joyent/node/issues/1726
	      if (stream._handle && stream._handle.unref) {
	        stream._handle.unref();
	      }
	      break;

	    default:
	      // Probably an error on in uv_guess_handle()
	      throw new Error('Implement me. Unknown stream file type!');
	  }

	  // For supporting legacy API we put the FD here.
	  stream.fd = fd;

	  stream._isStdio = true;

	  return stream;
	}

	/**
	 * Init logic for `debug` instances.
	 *
	 * Create a new `inspectOpts` object in case `useColors` is set
	 * differently for a particular `debug` instance.
	 */

	function init (debug) {
	  debug.inspectOpts = util._extend({}, exports.inspectOpts);
	}

	/**
	 * Enable namespaces listed in `process.env.DEBUG` initially.
	 */

	exports.enable(load());


/***/ },
/* 15 */
/***/ function(module, exports) {

	module.exports = require("tty");

/***/ },
/* 16 */
/***/ function(module, exports) {

	module.exports = require("util");

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = require("net");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * mustache.js - Logic-less {{mustache}} templates with JavaScript
	 * http://github.com/janl/mustache.js
	 */

	/*global define: false Mustache: true*/

	(function defineMustache (global, factory) {
	  if (typeof exports === 'object' && exports && typeof exports.nodeName !== 'string') {
	    factory(exports); // CommonJS
	  } else if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	  } else {
	    global.Mustache = {};
	    factory(global.Mustache); // script, wsh, asp
	  }
	}(this, function mustacheFactory (mustache) {

	  var objectToString = Object.prototype.toString;
	  var isArray = Array.isArray || function isArrayPolyfill (object) {
	    return objectToString.call(object) === '[object Array]';
	  };

	  function isFunction (object) {
	    return typeof object === 'function';
	  }

	  /**
	   * More correct typeof string handling array
	   * which normally returns typeof 'object'
	   */
	  function typeStr (obj) {
	    return isArray(obj) ? 'array' : typeof obj;
	  }

	  function escapeRegExp (string) {
	    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
	  }

	  /**
	   * Null safe way of checking whether or not an object,
	   * including its prototype, has a given property
	   */
	  function hasProperty (obj, propName) {
	    return obj != null && typeof obj === 'object' && (propName in obj);
	  }

	  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
	  // See https://github.com/janl/mustache.js/issues/189
	  var regExpTest = RegExp.prototype.test;
	  function testRegExp (re, string) {
	    return regExpTest.call(re, string);
	  }

	  var nonSpaceRe = /\S/;
	  function isWhitespace (string) {
	    return !testRegExp(nonSpaceRe, string);
	  }

	  var entityMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;',
	    '/': '&#x2F;',
	    '`': '&#x60;',
	    '=': '&#x3D;'
	  };

	  function escapeHtml (string) {
	    return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap (s) {
	      return entityMap[s];
	    });
	  }

	  var whiteRe = /\s*/;
	  var spaceRe = /\s+/;
	  var equalsRe = /\s*=/;
	  var curlyRe = /\s*\}/;
	  var tagRe = /#|\^|\/|>|\{|&|=|!/;

	  /**
	   * Breaks up the given `template` string into a tree of tokens. If the `tags`
	   * argument is given here it must be an array with two string values: the
	   * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
	   * course, the default is to use mustaches (i.e. mustache.tags).
	   *
	   * A token is an array with at least 4 elements. The first element is the
	   * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
	   * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
	   * all text that appears outside a symbol this element is "text".
	   *
	   * The second element of a token is its "value". For mustache tags this is
	   * whatever else was inside the tag besides the opening symbol. For text tokens
	   * this is the text itself.
	   *
	   * The third and fourth elements of the token are the start and end indices,
	   * respectively, of the token in the original template.
	   *
	   * Tokens that are the root node of a subtree contain two more elements: 1) an
	   * array of tokens in the subtree and 2) the index in the original template at
	   * which the closing tag for that section begins.
	   */
	  function parseTemplate (template, tags) {
	    if (!template)
	      return [];

	    var sections = [];     // Stack to hold section tokens
	    var tokens = [];       // Buffer to hold the tokens
	    var spaces = [];       // Indices of whitespace tokens on the current line
	    var hasTag = false;    // Is there a {{tag}} on the current line?
	    var nonSpace = false;  // Is there a non-space char on the current line?

	    // Strips all whitespace tokens array for the current line
	    // if there was a {{#tag}} on it and otherwise only space.
	    function stripSpace () {
	      if (hasTag && !nonSpace) {
	        while (spaces.length)
	          delete tokens[spaces.pop()];
	      } else {
	        spaces = [];
	      }

	      hasTag = false;
	      nonSpace = false;
	    }

	    var openingTagRe, closingTagRe, closingCurlyRe;
	    function compileTags (tagsToCompile) {
	      if (typeof tagsToCompile === 'string')
	        tagsToCompile = tagsToCompile.split(spaceRe, 2);

	      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
	        throw new Error('Invalid tags: ' + tagsToCompile);

	      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
	      closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
	      closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
	    }

	    compileTags(tags || mustache.tags);

	    var scanner = new Scanner(template);

	    var start, type, value, chr, token, openSection;
	    while (!scanner.eos()) {
	      start = scanner.pos;

	      // Match any text between tags.
	      value = scanner.scanUntil(openingTagRe);

	      if (value) {
	        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
	          chr = value.charAt(i);

	          if (isWhitespace(chr)) {
	            spaces.push(tokens.length);
	          } else {
	            nonSpace = true;
	          }

	          tokens.push([ 'text', chr, start, start + 1 ]);
	          start += 1;

	          // Check for whitespace on the current line.
	          if (chr === '\n')
	            stripSpace();
	        }
	      }

	      // Match the opening tag.
	      if (!scanner.scan(openingTagRe))
	        break;

	      hasTag = true;

	      // Get the tag type.
	      type = scanner.scan(tagRe) || 'name';
	      scanner.scan(whiteRe);

	      // Get the tag value.
	      if (type === '=') {
	        value = scanner.scanUntil(equalsRe);
	        scanner.scan(equalsRe);
	        scanner.scanUntil(closingTagRe);
	      } else if (type === '{') {
	        value = scanner.scanUntil(closingCurlyRe);
	        scanner.scan(curlyRe);
	        scanner.scanUntil(closingTagRe);
	        type = '&';
	      } else {
	        value = scanner.scanUntil(closingTagRe);
	      }

	      // Match the closing tag.
	      if (!scanner.scan(closingTagRe))
	        throw new Error('Unclosed tag at ' + scanner.pos);

	      token = [ type, value, start, scanner.pos ];
	      tokens.push(token);

	      if (type === '#' || type === '^') {
	        sections.push(token);
	      } else if (type === '/') {
	        // Check section nesting.
	        openSection = sections.pop();

	        if (!openSection)
	          throw new Error('Unopened section "' + value + '" at ' + start);

	        if (openSection[1] !== value)
	          throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
	      } else if (type === 'name' || type === '{' || type === '&') {
	        nonSpace = true;
	      } else if (type === '=') {
	        // Set the tags for the next time around.
	        compileTags(value);
	      }
	    }

	    // Make sure there are no open sections when we're done.
	    openSection = sections.pop();

	    if (openSection)
	      throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);

	    return nestTokens(squashTokens(tokens));
	  }

	  /**
	   * Combines the values of consecutive text tokens in the given `tokens` array
	   * to a single token.
	   */
	  function squashTokens (tokens) {
	    var squashedTokens = [];

	    var token, lastToken;
	    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
	      token = tokens[i];

	      if (token) {
	        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
	          lastToken[1] += token[1];
	          lastToken[3] = token[3];
	        } else {
	          squashedTokens.push(token);
	          lastToken = token;
	        }
	      }
	    }

	    return squashedTokens;
	  }

	  /**
	   * Forms the given array of `tokens` into a nested tree structure where
	   * tokens that represent a section have two additional items: 1) an array of
	   * all tokens that appear in that section and 2) the index in the original
	   * template that represents the end of that section.
	   */
	  function nestTokens (tokens) {
	    var nestedTokens = [];
	    var collector = nestedTokens;
	    var sections = [];

	    var token, section;
	    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
	      token = tokens[i];

	      switch (token[0]) {
	        case '#':
	        case '^':
	          collector.push(token);
	          sections.push(token);
	          collector = token[4] = [];
	          break;
	        case '/':
	          section = sections.pop();
	          section[5] = token[2];
	          collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
	          break;
	        default:
	          collector.push(token);
	      }
	    }

	    return nestedTokens;
	  }

	  /**
	   * A simple string scanner that is used by the template parser to find
	   * tokens in template strings.
	   */
	  function Scanner (string) {
	    this.string = string;
	    this.tail = string;
	    this.pos = 0;
	  }

	  /**
	   * Returns `true` if the tail is empty (end of string).
	   */
	  Scanner.prototype.eos = function eos () {
	    return this.tail === '';
	  };

	  /**
	   * Tries to match the given regular expression at the current position.
	   * Returns the matched text if it can match, the empty string otherwise.
	   */
	  Scanner.prototype.scan = function scan (re) {
	    var match = this.tail.match(re);

	    if (!match || match.index !== 0)
	      return '';

	    var string = match[0];

	    this.tail = this.tail.substring(string.length);
	    this.pos += string.length;

	    return string;
	  };

	  /**
	   * Skips all text until the given regular expression can be matched. Returns
	   * the skipped string, which is the entire tail if no match can be made.
	   */
	  Scanner.prototype.scanUntil = function scanUntil (re) {
	    var index = this.tail.search(re), match;

	    switch (index) {
	      case -1:
	        match = this.tail;
	        this.tail = '';
	        break;
	      case 0:
	        match = '';
	        break;
	      default:
	        match = this.tail.substring(0, index);
	        this.tail = this.tail.substring(index);
	    }

	    this.pos += match.length;

	    return match;
	  };

	  /**
	   * Represents a rendering context by wrapping a view object and
	   * maintaining a reference to the parent context.
	   */
	  function Context (view, parentContext) {
	    this.view = view;
	    this.cache = { '.': this.view };
	    this.parent = parentContext;
	  }

	  /**
	   * Creates a new context using the given view with this context
	   * as the parent.
	   */
	  Context.prototype.push = function push (view) {
	    return new Context(view, this);
	  };

	  /**
	   * Returns the value of the given name in this context, traversing
	   * up the context hierarchy if the value is absent in this context's view.
	   */
	  Context.prototype.lookup = function lookup (name) {
	    var cache = this.cache;

	    var value;
	    if (cache.hasOwnProperty(name)) {
	      value = cache[name];
	    } else {
	      var context = this, names, index, lookupHit = false;

	      while (context) {
	        if (name.indexOf('.') > 0) {
	          value = context.view;
	          names = name.split('.');
	          index = 0;

	          /**
	           * Using the dot notion path in `name`, we descend through the
	           * nested objects.
	           *
	           * To be certain that the lookup has been successful, we have to
	           * check if the last object in the path actually has the property
	           * we are looking for. We store the result in `lookupHit`.
	           *
	           * This is specially necessary for when the value has been set to
	           * `undefined` and we want to avoid looking up parent contexts.
	           **/
	          while (value != null && index < names.length) {
	            if (index === names.length - 1)
	              lookupHit = hasProperty(value, names[index]);

	            value = value[names[index++]];
	          }
	        } else {
	          value = context.view[name];
	          lookupHit = hasProperty(context.view, name);
	        }

	        if (lookupHit)
	          break;

	        context = context.parent;
	      }

	      cache[name] = value;
	    }

	    if (isFunction(value))
	      value = value.call(this.view);

	    return value;
	  };

	  /**
	   * A Writer knows how to take a stream of tokens and render them to a
	   * string, given a context. It also maintains a cache of templates to
	   * avoid the need to parse the same template twice.
	   */
	  function Writer () {
	    this.cache = {};
	  }

	  /**
	   * Clears all cached templates in this writer.
	   */
	  Writer.prototype.clearCache = function clearCache () {
	    this.cache = {};
	  };

	  /**
	   * Parses and caches the given `template` and returns the array of tokens
	   * that is generated from the parse.
	   */
	  Writer.prototype.parse = function parse (template, tags) {
	    var cache = this.cache;
	    var tokens = cache[template];

	    if (tokens == null)
	      tokens = cache[template] = parseTemplate(template, tags);

	    return tokens;
	  };

	  /**
	   * High-level method that is used to render the given `template` with
	   * the given `view`.
	   *
	   * The optional `partials` argument may be an object that contains the
	   * names and templates of partials that are used in the template. It may
	   * also be a function that is used to load partial templates on the fly
	   * that takes a single argument: the name of the partial.
	   */
	  Writer.prototype.render = function render (template, view, partials) {
	    var tokens = this.parse(template);
	    var context = (view instanceof Context) ? view : new Context(view);
	    return this.renderTokens(tokens, context, partials, template);
	  };

	  /**
	   * Low-level method that renders the given array of `tokens` using
	   * the given `context` and `partials`.
	   *
	   * Note: The `originalTemplate` is only ever used to extract the portion
	   * of the original template that was contained in a higher-order section.
	   * If the template doesn't use higher-order sections, this argument may
	   * be omitted.
	   */
	  Writer.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate) {
	    var buffer = '';

	    var token, symbol, value;
	    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
	      value = undefined;
	      token = tokens[i];
	      symbol = token[0];

	      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);
	      else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);
	      else if (symbol === '>') value = this.renderPartial(token, context, partials, originalTemplate);
	      else if (symbol === '&') value = this.unescapedValue(token, context);
	      else if (symbol === 'name') value = this.escapedValue(token, context);
	      else if (symbol === 'text') value = this.rawValue(token);

	      if (value !== undefined)
	        buffer += value;
	    }

	    return buffer;
	  };

	  Writer.prototype.renderSection = function renderSection (token, context, partials, originalTemplate) {
	    var self = this;
	    var buffer = '';
	    var value = context.lookup(token[1]);

	    // This function is used to render an arbitrary template
	    // in the current context by higher-order sections.
	    function subRender (template) {
	      return self.render(template, context, partials);
	    }

	    if (!value) return;

	    if (isArray(value)) {
	      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
	        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);
	      }
	    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {
	      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);
	    } else if (isFunction(value)) {
	      if (typeof originalTemplate !== 'string')
	        throw new Error('Cannot use higher-order sections without the original template');

	      // Extract the portion of the original template that the section contains.
	      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);

	      if (value != null)
	        buffer += value;
	    } else {
	      buffer += this.renderTokens(token[4], context, partials, originalTemplate);
	    }
	    return buffer;
	  };

	  Writer.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate) {
	    var value = context.lookup(token[1]);

	    // Use JavaScript's definition of falsy. Include empty arrays.
	    // See https://github.com/janl/mustache.js/issues/186
	    if (!value || (isArray(value) && value.length === 0))
	      return this.renderTokens(token[4], context, partials, originalTemplate);
	  };

	  Writer.prototype.renderPartial = function renderPartial (token, context, partials) {
	    if (!partials) return;

	    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
	    if (value != null)
	      return this.renderTokens(this.parse(value), context, partials, value);
	  };

	  Writer.prototype.unescapedValue = function unescapedValue (token, context) {
	    var value = context.lookup(token[1]);
	    if (value != null)
	      return value;
	  };

	  Writer.prototype.escapedValue = function escapedValue (token, context) {
	    var value = context.lookup(token[1]);
	    if (value != null)
	      return mustache.escape(value);
	  };

	  Writer.prototype.rawValue = function rawValue (token) {
	    return token[1];
	  };

	  mustache.name = 'mustache.js';
	  mustache.version = '2.3.0';
	  mustache.tags = [ '{{', '}}' ];

	  // All high-level mustache.* functions use this writer.
	  var defaultWriter = new Writer();

	  /**
	   * Clears all cached templates in the default writer.
	   */
	  mustache.clearCache = function clearCache () {
	    return defaultWriter.clearCache();
	  };

	  /**
	   * Parses and caches the given template in the default writer and returns the
	   * array of tokens it contains. Doing this ahead of time avoids the need to
	   * parse templates on the fly as they are rendered.
	   */
	  mustache.parse = function parse (template, tags) {
	    return defaultWriter.parse(template, tags);
	  };

	  /**
	   * Renders the `template` with the given `view` and `partials` using the
	   * default writer.
	   */
	  mustache.render = function render (template, view, partials) {
	    if (typeof template !== 'string') {
	      throw new TypeError('Invalid template! Template should be a "string" ' +
	                          'but "' + typeStr(template) + '" was given as the first ' +
	                          'argument for mustache#render(template, view, partials)');
	    }

	    return defaultWriter.render(template, view, partials);
	  };

	  // This is here for backwards compatibility with 0.4.x.,
	  /*eslint-disable */ // eslint wants camel cased function name
	  mustache.to_html = function to_html (template, view, partials, send) {
	    /*eslint-enable*/

	    var result = mustache.render(template, view, partials);

	    if (isFunction(send)) {
	      send(result);
	    } else {
	      return result;
	    }
	  };

	  // Export the escaping function so that the user may override it.
	  // See https://github.com/janl/mustache.js/issues/244
	  mustache.escape = escapeHtml;

	  // Export these mainly for testing, but also for advanced usage.
	  mustache.Scanner = Scanner;
	  mustache.Context = Context;
	  mustache.Writer = Writer;

	  return mustache;
	}));


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/** @file messageformat.js - ICU PluralFormat + SelectFormat for JavaScript
	 *
	 * @author Alex Sexton - @SlexAxton, Eemeli Aro
	 * @version 0.3.1
	 * @copyright 2012-2016 Alex Sexton, Eemeli Aro, and Contributors
	 * @license To use or fork, MIT. To contribute back, Dojo CLA  */


	/** Utility function for quoting an Object's key value iff required
	 *
	 * @private  */
	function propname(key, obj) {
	  /* Quote the key if it contains invalid characters or is an
	   * ECMAScript 3rd Edition reserved word.
	   */
	  if (/^[A-Z_$][0-9A-Z_$]*$/i.test(key) &&
	     ['break', 'continue', 'delete', 'else', 'for', 'function', 'if', 'in', 'new',
	      'return', 'this', 'typeof', 'var', 'void', 'while', 'with', 'case', 'catch',
	      'default', 'do', 'finally', 'instanceof', 'switch', 'throw', 'try'].indexOf(key) < 0) {
	    return obj ? obj + '.' + key : key;
	  } else {
	    var jkey = JSON.stringify(key);
	    return obj ? obj + '[' + jkey + ']' : jkey;
	  }
	}

	/** Utility formatter function for enforcing Bidi Structured Text by using UCC
	 *
	 * @private  */
	function bidiMarkText(text, locale) {
	  function isLocaleRTL(locale) {
	    /* list inlined from data extracted from CLDR v27 & v28
	     * to verify/recreate, use the following:
	     *   git clone https://github.com/unicode-cldr/cldr-misc-full.git
	     *   cd cldr-misc-full/main/
	     *   grep characterOrder -r . | tr '"/' '\t' | cut -f2,6 | grep -C4 right-to-left
	     */
	    var rtlLanguages = ['ar', 'ckb', 'fa', 'he', 'ks($|[^bfh])', 'lrc', 'mzn', 'pa-Arab', 'ps', 'ug', 'ur', 'uz-Arab', 'yi'];
	    return new RegExp('^' + rtlLanguages.join('|^')).test(locale);
	  }
	  var mark = JSON.stringify(isLocaleRTL(locale) ? '\u200F' : '\u200E');
	  return mark + ' + ' + text + ' + ' + mark;
	}

	/** Create a new message formatter
	 *
	 * @class
	 * @param {string|string[]} [locale="en"] - The locale to use, with fallbacks
	 * @param {function} [pluralFunc] - Optional custom pluralization function
	 * @param {function[]} [formatters] - Optional custom formatting functions  */
	function MessageFormat(locale, pluralFunc, formatters) {
	  if (!locale) {
	    this.lc = ['en'];
	  } else if (typeof locale == 'string') {
	    this.lc = [];
	    for (var l = locale; l; l = l.replace(/[-_]?[^-_]*$/, '')) this.lc.push(l);
	  } else {
	    this.lc = locale;
	  }
	  if (!pluralFunc) {
	    if (this.lc.every(function(l){
	      pluralFunc = MessageFormat.plurals[l];
	      return !pluralFunc;
	    })) {
	      throw new Error('Plural function for locale `' + this.lc.join(',') + '` not found');
	    }
	  }
	  this.runtime = new Runtime(this.lc[0], pluralFunc, formatters);
	}

	module.exports = MessageFormat;


	/** Parse an input string to its AST
	 *
	 *  Precompiled from `lib/messageformat-parser.pegjs` by
	 *  {@link http://pegjs.org/ PEG.js}. Included in MessageFormat object
	 *  to enable testing.
	 *
	 * @private  */
	MessageFormat._parse = __webpack_require__(20).parse;


	/** Pluralization functions from
	 *  {@link http://github.com/eemeli/make-plural.js make-plural}
	 *
	 * @memberof MessageFormat
	 * @type Object.<string,function>  */
	MessageFormat.plurals = __webpack_require__(21);


	/** Default number formatting functions in the style of ICU's
	 *  {@link http://icu-project.org/apiref/icu4j/com/ibm/icu/text/MessageFormat.html simpleArg syntax}
	 *  implemented using the
	 *  {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl Intl}
	 *  object defined by ECMA-402.
	 *
	 *  **Note**: Intl is not defined in default Node until 0.11.15 / 0.12.0, so
	 *  earlier versions require a {@link https://www.npmjs.com/package/intl polyfill}.
	 *  Therefore {@link MessageFormat.withIntlSupport} needs to be true for these
	 *  functions to be available for inclusion in the output.
	 *
	 * @see MessageFormat#setIntlSupport
	 *
	 * @namespace
	 * @memberof MessageFormat
	 * @property {function} number - Represent a number as an integer, percent or currency value
	 * @property {function} date - Represent a date as a full/long/default/short string
	 * @property {function} time - Represent a time as a full/long/default/short string
	 *
	 * @example
	 * var mf = new MessageFormat('en').setIntlSupport(true);
	 * mf.currency = 'EUR';
	 * var cf = mf.compile('The total is {V,number,currency}.');
	 *
	 * cf({ V: 5.5 })
	 * // 'The total is €5.50.'
	 *
	 * @example
	 * var mf = new MessageFormat('en', null, {number: MessageFormat.number});
	 * mf.currency = 'EUR';
	 * var cf = mf.compile('The total is {V,number,currency}.');
	 *
	 * cf({ V: 5.5 })
	 * // 'The total is €5.50.'  */
	MessageFormat.formatters = {
	  number: function(self) {
	    return new Function("v,lc,p",
	      "return Intl.NumberFormat(lc,\n" +
	      "    p=='integer' ? {maximumFractionDigits:0}\n" +
	      "  : p=='percent' ? {style:'percent'}\n" +
	      "  : p=='currency' ? {style:'currency', currency:'" + (self.currency || 'USD') + "', minimumFractionDigits:2, maximumFractionDigits:2}\n" +
	      "  : {}).format(v)"
	    );
	  },
	  date: function(v,lc,p) {
	    var o = {day:'numeric', month:'short', year:'numeric'};
	    switch (p) {
	      case 'full': o.weekday = 'long';
	      case 'long': o.month = 'long'; break;
	      case 'short': o.month = 'numeric';
	    }
	    return (new Date(v)).toLocaleDateString(lc, o)
	  },
	  time: function(v,lc,p) {
	    var o = {second:'numeric', minute:'numeric', hour:'numeric'};
	    switch (p) {
	      case 'full': case 'long': o.timeZoneName = 'short'; break;
	      case 'short': delete o.minute;
	    }
	    return (new Date(v)).toLocaleTimeString(lc, o)
	  }
	};

	/** Enable or disable the addition of Unicode control characters to all input
	 *  to preserve the integrity of the output when mixing LTR and RTL text.
	 *
	 * @see http://cldr.unicode.org/development/development-process/design-proposals/bidi-handling-of-structured-text
	 *
	 * @memberof MessageFormat
	 * @param {boolean} [enable=true]
	 * @returns {MessageFormat} The MessageFormat instance, to allow for chaining
	 *
	 * @example
	 * // upper case stands for RTL characters, output is shown as rendered
	 * var mf = new MessageFormat('en');
	 *
	 * mf.compile('{0} >> {1} >> {2}')(['first', 'SECOND', 'THIRD']);
	 * // 'first >> THIRD << SECOND'
	 *
	 * mf.setBiDiSupport(true);
	 * mf.compile('{0} >> {1} >> {2}')(['first', 'SECOND', 'THIRD']);
	 * // 'first >> SECOND >> THIRD'  */
	MessageFormat.prototype.setBiDiSupport = function(enable) {
	    this.bidiSupport = !!enable || (typeof enable == 'undefined');
	    return this;
	};


	/** Enable or disable support for the default formatters, which require the
	 *  `Intl` object. Note that this can't be autodetected, as the environment
	 *  in which the formatted text is compiled into Javascript functions is not
	 *  necessarily the same environment in which they will get executed.
	 *
	 * @see MessageFormat.formatters
	 *
	 * @memberof MessageFormat
	 * @param {boolean} [enable=true]
	 * @returns {MessageFormat} The MessageFormat instance, to allow for chaining
	 *
	 * @example
	 * // Intl is not defined in default Node until 0.11.15 / 0.12.0
	 * var Intl = require('intl');
	 * var mf = new MessageFormat('en').setIntlSupport(true);
	 * mf.currency = 'EUR';
	 *
	 * mf.compile('The total is {V,number,currency}.')({ V: 5.5 });
	 * // 'The total is €5.50.'  */
	MessageFormat.prototype.setIntlSupport = function(enable) {
	    this.withIntlSupport = !!enable || (typeof enable == 'undefined');
	    return this;
	};


	/** A set of utility functions that are called by the compiled Javascript
	 *  functions, these are included locally in the output of {@link
	 *  MessageFormat#compile compile()}.
	 *
	 * @class
	 * @param {string} [locale] - The parsed locale
	 * @param {function} [pluralFunc] - Pluralization function for the locale
	 * @param {function[]} [formatters] - Optional custom formatting functions  */
	function Runtime(locale, pluralFunc, formatters) {

	  /** Pluralization functions included in compiled output
	   *
	   * @instance
	   * @type Object.<string,function>  */
	  this.pluralFuncs = {};
	  this.pluralFuncs[locale] = pluralFunc;

	  /** Custom formatting functions called by `{var, fn[, args]*}` syntax
	   *
	   *  For examples, see {@link MessageFormat.formatters}
	   *
	   * @instance
	   * @see MessageFormat.formatters
	   * @type Object.<string,function>  */
	  this.fmt = {};
	  if (formatters) for (var f in formatters) {
	    this.fmt[f] = formatters[f];
	  }
	}

	Runtime.prototype = {

	  /** Utility function for `#` in plural rules
	   *
	   * @param {number} value - The value to operate on
	   * @param {number} [offset=0] - An optional offset, set by the surrounding context  */
	  number: function(value, offset) {
	    if (isNaN(value)) throw new Error("'" + value + "' isn't a number.");
	    return value - (offset || 0);
	  },

	  /** Utility function for `{N, plural|selectordinal, ...}`
	   *
	   * @param {number} value - The key to use to find a pluralization rule
	   * @param {number} offset - An offset to apply to `value`
	   * @param {function} lcfunc - A locale function from `pluralFuncs`
	   * @param {Object.<string,string>} data - The object from which results are looked up
	   * @param {?boolean} isOrdinal - If true, use ordinal rather than cardinal rules
	   * @returns {string} The result of the pluralization  */
	  plural: function(value, offset, lcfunc, data, isOrdinal) {
	    if ({}.hasOwnProperty.call(data, value)) return data[value]();
	    if (offset) value -= offset;
	    var key = lcfunc(value, isOrdinal);
	    if (key in data) return data[key]();
	    return data.other();
	  },

	  /** Utility function for `{N, select, ...}`
	   *
	   * @param {number} value - The key to use to find a selection
	   * @param {Object.<string,string>} data - The object from which results are looked up
	   * @returns {string} The result of the select statement  */
	  select: function(value, data) {
	    if ({}.hasOwnProperty.call(data, value)) return data[value]();
	    return data.other()
	  },

	  /** Custom stringifier
	   *
	   * @example
	   * var mf = new MessageFormat('en');
	   * console.log(mf.runtime.toString())
	   * > var pluralFuncs = {
	   * >   en: function (n, ord) {
	   * >     var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,
	   * >         n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
	   * >     if (ord) return (n10 == 1 && n100 != 11) ? 'one'
	   * >         : (n10 == 2 && n100 != 12) ? 'two'
	   * >         : (n10 == 3 && n100 != 13) ? 'few'
	   * >         : 'other';
	   * >     return (n == 1 && v0) ? 'one' : 'other';
	   * >   }
	   * > };
	   * > var fmt = {};
	   * > var number = function (value, offset) {
	   * >   if (isNaN(value)) throw new Error("'" + value + "' isn't a number.");
	   * >   return value - (offset || 0);
	   * > };
	   * > var plural = function (value, offset, lcfunc, data, isOrdinal) {
	   * >   if ({}.hasOwnProperty.call(data, value)) return data[value]();
	   * >   if (offset) value -= offset;
	   * >   var key = lcfunc(value, isOrdinal);
	   * >   if (key in data) return data[key]();
	   * >   return data.other();
	   * > };
	   * > var select = function (value, data) {
	   * >   if ({}.hasOwnProperty.call(data, value)) return data[value]();
	   * >   return data.other()
	   * > };  */
	  toString: function () {
	    var _stringify = function(o, level) {
	      if (typeof o != 'object') {
	        var funcStr = o.toString().replace(/^(function )\w*/, '$1');
	        var indent = /([ \t]*)\S.*$/.exec(funcStr);
	        return indent ? funcStr.replace(new RegExp('^' + indent[1], 'mg'), '') : funcStr;
	      }
	      var s = [];
	      for (var i in o) if (i != 'toString') {
	        if (level == 0) s.push('var ' + i + ' = ' + _stringify(o[i], level + 1) + ';\n');
	        else s.push(propname(i) + ': ' + _stringify(o[i], level + 1));
	      }
	      if (level == 0) return s.join('');
	      if (s.length == 0) return '{}';
	      var indent = '  '; while (--level) indent += '  ';
	      return '{\n' + s.join(',\n').replace(/^/gm, indent) + '\n}';
	    };
	    return _stringify(this, 0);
	  }
	};


	/** Recursively map an AST to its resulting string
	 *
	 * @memberof MessageFormat
	 * @param ast - the Ast node for which the JS code should be generated
	 * @private  */
	MessageFormat.prototype._precompile = function(ast, data) {
	  data = data || { keys: {}, offset: {} };
	  var r = [], i, tmp, args = [];

	  switch ( ast.type ) {
	    case 'messageFormatPattern':
	      for ( i = 0; i < ast.statements.length; ++i ) {
	        r.push(this._precompile( ast.statements[i], data ));
	      }
	      tmp = r.join(' + ') || '""';
	      return data.pf_count ? tmp : 'function(d) { return ' + tmp + '; }';

	    case 'messageFormatElement':
	      data.pf_count = data.pf_count || 0;
	      if ( ast.output ) {
	        var ret = propname(ast.argumentIndex, 'd');
	        return this.bidiSupport ? bidiMarkText(ret, this.lc) : ret;
	      }
	      else {
	        data.keys[data.pf_count] = ast.argumentIndex;
	        return this._precompile( ast.elementFormat, data );
	      }
	      return '';

	    case 'elementFormat':
	      args = [ propname(data.keys[data.pf_count], 'd') ];
	      switch (ast.key) {
	        case 'select':
	          args.push(this._precompile(ast.val, data));
	          return 'select(' + args.join(', ') + ')';
	        case 'selectordinal':
	          args = args.concat([ 0, propname(this.lc[0], 'pluralFuncs'), this._precompile(ast.val, data), 1 ]);
	          return 'plural(' + args.join(', ') + ')';
	        case 'plural':
	          data.offset[data.pf_count || 0] = ast.val.offset || 0;
	          args = args.concat([ data.offset[data.pf_count] || 0, propname(this.lc[0], 'pluralFuncs'), this._precompile(ast.val, data) ]);
	          return 'plural(' + args.join(', ') + ')';
	        default:
	          if (this.withIntlSupport && !(ast.key in this.runtime.fmt) && (ast.key in MessageFormat.formatters)) {
	            tmp = MessageFormat.formatters[ast.key];
	            this.runtime.fmt[ast.key] = (typeof tmp(this) == 'function') ? tmp(this) : tmp;
	          }
	          args.push(JSON.stringify(this.lc));
	          if (ast.val && ast.val.length) args.push(JSON.stringify(ast.val.length == 1 ? ast.val[0] : ast.val));
	          return 'fmt.' + ast.key + '(' + args.join(', ') + ')';
	      }

	    case 'pluralFormatPattern':
	    case 'selectFormatPattern':
	      data.pf_count = data.pf_count || 0;
	      if (ast.type == 'selectFormatPattern') data.offset[data.pf_count] = 0;
	      var needOther = true;
	      for (i = 0; i < ast.pluralForms.length; ++i) {
	        var key = ast.pluralForms[i].key;
	        if (key === 'other') needOther = false;
	        var data_copy = JSON.parse(JSON.stringify(data));
	        data_copy.pf_count++;
	        r.push(propname(key) + ': function() { return ' + this._precompile(ast.pluralForms[i].val, data_copy) + ';}');
	      }
	      if (needOther) throw new Error("No 'other' form found in " + ast.type + " " + data.pf_count);
	      return '{ ' + r.join(', ') + ' }';

	    case 'string':
	      return JSON.stringify(ast.val || "");

	    case 'octothorpe':
	      if (!data.pf_count) return '"#"';
	      args = [ propname(data.keys[data.pf_count-1], 'd') ];
	      if (data.offset[data.pf_count-1]) args.push(data.offset[data.pf_count-1]);
	      return 'number(' + args.join(', ') + ')';

	    default:
	      throw new Error( 'Bad AST type: ' + ast.type );
	  }
	};

	/** Compile messages into an executable function with clean string
	 *  representation.
	 *
	 *  If `messages` is a single string including ICU MessageFormat declarations,
	 *  `opt` is ignored and the returned function takes a single Object parameter
	 *  `d` representing each of the input's defined variables. The returned
	 *  function will be defined in a local scope that includes all the required
	 *  runtime variables.
	 *
	 *  If `messages` is a map of keys to strings, or a map of namespace keys to
	 *  such key/string maps, the returned function will fill the specified global
	 *  with javascript functions matching the structure of the input. In such use,
	 *  the result of `compile()` may be serialized using its `toString()` method,
	 *  including all required runtime function definitions. If `opt.global` is
	 *  null, calling the output function will return the object itself.
	 *
	 *  Together, the input parameters should match the following patterns:
	 *  ```js
	 *  messages = "string" || { key0: "string0", key1: "string1", ... } || {
	 *    ns0: { key0: "string0", key1: "string1", ...  },
	 *    ns1: { key0: "string0", key1: "string1", ...  },
	 *    ...
	 *  }
	 *
	 *  opt = null || {
	 *    locale: null || {
	 *      ns0: "lc0" || [ "lc0", ... ],
	 *      ns1: "lc1" || [ "lc1", ... ],
	 *      ...
	 *    },
	 *    global: null || "module.exports" || "exports" || "i18n" || ...
	 *  }
	 *  ```
	 *
	 * @memberof MessageFormat
	 * @param {string|Object}
	 *     messages - The input message(s) to be compiled, in ICU MessageFormat
	 * @param {Object} [opt={}] - Options controlling output for non-simple intput
	 * @param {Object} [opt.locale] - The locales to use for the messages, with a
	 *     structure matching that of `messages`
	 * @param {string} [opt.global=""] - The global variable that the output
	 *     function should use, or a null string for none. "exports" and
	 *     "module.exports" are recognised as special cases.
	 * @returns {function} The first match found for the given locale(s)
	 *
	 * @example
	 * var mf = new MessageFormat('en');
	 * var cf = mf.compile('A {TYPE} example.');
	 *
	 * cf({ TYPE: 'simple' })
	 * // 'A simple example.'
	 *
	 * cf.toString()
	 * // 'function (d) { return "A " + d.TYPE + " example."; }'
	 *
	 * @example
	 * var fs = require('fs');
	 * var mf = new MessageFormat('en');
	 * var msgSet = {
	 *   a: 'A {TYPE} example.',
	 *   b: 'This has {COUNT, plural, one{one member} other{# members}}.'
	 * };
	 * var cfSet = mf.compile(msgSet, { global: 'module.exports' });
	 * var str = cfSet.toString().replace(/^[^{]*{/, '').replace(/}\s*$/, '').trim();
	 * fs.writeFileSync('messages.js', str);
	 * ...
	 * var messages = require('./messages');
	 *
	 * messages.a({ TYPE: 'more complex' })
	 * // 'A more complex example.'
	 *
	 * messages.b({ COUNT: 2 })
	 * // 'This has 2 members.'
	 *
	 * @example
	 * var mf = new MessageFormat('en');
	 * mf.runtime.pluralFuncs.fi = MessageFormat.plurals.fi;
	 * mf.compile({
	 *   en: { a: 'A {TYPE} example.',
	 *         b: 'This is the {COUNT, selectordinal, one{#st} two{#nd} few{#rd} other{#th}} example.' },
	 *   fi: { a: '{TYPE} esimerkki.',
	 *         b: 'Tämä on {COUNT, selectordinal, other{#.}} esimerkki.' }
	 * }, {
	 *   locale: { en: 'en', fi: 'fi' },
	 *   global: 'i18n'
	 * })(this);
	 *
	 * i18n.en.b({ COUNT: 3 })
	 * // 'This is the 3rd example.'
	 *
	 * i18n.fi.b({ COUNT: 3 })
	 * // 'Tämä on 3. esimerkki.'  */
	MessageFormat.prototype.compile = function ( messages, opt ) {
	  var r = {}, lc0 = this.lc,
	      compileMsg = function(self, msg) {
	        try {
	          var ast = MessageFormat._parse(msg);
	          return self._precompile(ast);
	        } catch (e) {
	          throw new Error((ast ? 'Precompiler' : 'Parser') + ' error: ' + e.toString());
	        }
	      },
	      stringify = function(r, level) {
	        if (!level) level = 0;
	        if (typeof r != 'object') return r;
	        var o = [], indent = '';
	        for (var i = 0; i < level; ++i) indent += '  ';
	        for (var k in r) o.push('\n' + indent + '  ' + propname(k) + ': ' + stringify(r[k], level + 1));
	        return '{' + o.join(',') + '\n' + indent + '}';
	      };

	  if (typeof messages == 'string') {
	    var f = new Function(
	        'number, plural, select, pluralFuncs, fmt',
	        'return ' + compileMsg(this, messages));
	    return f(this.runtime.number, this.runtime.plural, this.runtime.select,
	        this.runtime.pluralFuncs, this.runtime.fmt);
	  }

	  opt = opt || {};

	  for (var ns in messages) {
	    if (opt.locale) this.lc = opt.locale[ns] && [].concat(opt.locale[ns]) || lc0;
	    if (typeof messages[ns] == 'string') {
	      try { r[ns] = compileMsg(this, messages[ns]); }
	      catch (e) { e.message = e.message.replace(':', ' with `' + ns + '`:'); throw e; }
	    } else {
	      r[ns] = {};
	      for (var key in messages[ns]) {
	        try { r[ns][key] = compileMsg(this, messages[ns][key]); }
	        catch (e) { e.message = e.message.replace(':', ' with `' + key + '` in `' + ns + '`:'); throw e; }
	      }
	    }
	  }

	  this.lc = lc0;
	  var s = this.runtime.toString() + '\n';
	  switch (opt.global || '') {
	    case 'exports':
	      var o = [];
	      for (var k in r) o.push(propname(k, 'exports') + ' = ' + stringify(r[k]));
	      return new Function(s + o.join(';\n'));
	    case 'module.exports':
	      return new Function(s + 'module.exports = ' + stringify(r));
	    case '':
	      return new Function(s + 'return ' + stringify(r));
	    default:
	      return new Function('G', s + propname(opt.global, 'G') + ' = ' + stringify(r));
	  }
	};


/***/ },
/* 20 */
/***/ function(module, exports) {

	module.exports = (function() {
	  "use strict";

	  /*
	   * Generated by PEG.js 0.9.0.
	   *
	   * http://pegjs.org/
	   */

	  function peg$subclass(child, parent) {
	    function ctor() { this.constructor = child; }
	    ctor.prototype = parent.prototype;
	    child.prototype = new ctor();
	  }

	  function peg$SyntaxError(message, expected, found, location) {
	    this.message  = message;
	    this.expected = expected;
	    this.found    = found;
	    this.location = location;
	    this.name     = "SyntaxError";

	    if (typeof Error.captureStackTrace === "function") {
	      Error.captureStackTrace(this, peg$SyntaxError);
	    }
	  }

	  peg$subclass(peg$SyntaxError, Error);

	  function peg$parse(input) {
	    var options = arguments.length > 1 ? arguments[1] : {},
	        parser  = this,

	        peg$FAILED = {},

	        peg$startRuleFunctions = { start: peg$parsestart },
	        peg$startRuleFunction  = peg$parsestart,

	        peg$c0 = function(st) {
	              return { type: 'messageFormatPattern', statements: st };
	            },
	        peg$c1 = "{",
	        peg$c2 = { type: "literal", value: "{", description: "\"{\"" },
	        peg$c3 = ",",
	        peg$c4 = { type: "literal", value: ",", description: "\",\"" },
	        peg$c5 = "}",
	        peg$c6 = { type: "literal", value: "}", description: "\"}\"" },
	        peg$c7 = function(argIdx, efmt) {
	              var res = {
	                type: "messageFormatElement",
	                argumentIndex: argIdx
	              };
	              if (efmt && efmt.length) {
	                res.elementFormat = efmt[1];
	              } else {
	                res.output = true;
	              }
	              return res;
	            },
	        peg$c8 = "plural",
	        peg$c9 = { type: "literal", value: "plural", description: "\"plural\"" },
	        peg$c10 = function(t, s) {
	              return { type: "elementFormat", key: t, val: s };
	            },
	        peg$c11 = "selectordinal",
	        peg$c12 = { type: "literal", value: "selectordinal", description: "\"selectordinal\"" },
	        peg$c13 = "select",
	        peg$c14 = { type: "literal", value: "select", description: "\"select\"" },
	        peg$c15 = function(t, p) {
	              return { type: "elementFormat", key: t, val: p };
	            },
	        peg$c16 = function(op, pf) {
	              return { type: "pluralFormatPattern", pluralForms: pf, offset: op || 0 };
	            },
	        peg$c17 = "offset",
	        peg$c18 = { type: "literal", value: "offset", description: "\"offset\"" },
	        peg$c19 = ":",
	        peg$c20 = { type: "literal", value: ":", description: "\":\"" },
	        peg$c21 = function(d) { return d; },
	        peg$c22 = function(k, mfp) {
	              return { key: k, val: mfp };
	            },
	        peg$c23 = function(i) { return i; },
	        peg$c24 = "=",
	        peg$c25 = { type: "literal", value: "=", description: "\"=\"" },
	        peg$c26 = function(pf) { return { type: "selectFormatPattern", pluralForms: pf }; },
	        peg$c27 = function(p) { return p; },
	        peg$c28 = "#",
	        peg$c29 = { type: "literal", value: "#", description: "\"#\"" },
	        peg$c30 = function() { return {type: 'octothorpe'}; },
	        peg$c31 = function(s) { return { type: "string", val: s.join('') }; },
	        peg$c32 = { type: "other", description: "identifier" },
	        peg$c33 = /^[0-9a-zA-Z$_]/,
	        peg$c34 = { type: "class", value: "[0-9a-zA-Z$_]", description: "[0-9a-zA-Z$_]" },
	        peg$c35 = /^[^ \t\n\r,.+={}]/,
	        peg$c36 = { type: "class", value: "[^ \\t\\n\\r,.+={}]", description: "[^ \\t\\n\\r,.+={}]" },
	        peg$c37 = function(s) { return s; },
	        peg$c38 = function(chars) { return chars.join(''); },
	        peg$c39 = /^[^{}#\\\0-\x1F \t\n\r]/,
	        peg$c40 = { type: "class", value: "[^{}#\\\\\\0-\\x1F\\x7f \\t\\n\\r]", description: "[^{}#\\\\\\0-\\x1F\\x7f \\t\\n\\r]" },
	        peg$c41 = function(x) { return x; },
	        peg$c42 = "\\\\",
	        peg$c43 = { type: "literal", value: "\\\\", description: "\"\\\\\\\\\"" },
	        peg$c44 = function() { return "\\"; },
	        peg$c45 = "\\#",
	        peg$c46 = { type: "literal", value: "\\#", description: "\"\\\\#\"" },
	        peg$c47 = function() { return "#"; },
	        peg$c48 = "\\{",
	        peg$c49 = { type: "literal", value: "\\{", description: "\"\\\\{\"" },
	        peg$c50 = function() { return "\u007B"; },
	        peg$c51 = "\\}",
	        peg$c52 = { type: "literal", value: "\\}", description: "\"\\\\}\"" },
	        peg$c53 = function() { return "\u007D"; },
	        peg$c54 = "\\u",
	        peg$c55 = { type: "literal", value: "\\u", description: "\"\\\\u\"" },
	        peg$c56 = function(h1, h2, h3, h4) {
	              return String.fromCharCode(parseInt("0x" + h1 + h2 + h3 + h4));
	            },
	        peg$c57 = /^[0-9]/,
	        peg$c58 = { type: "class", value: "[0-9]", description: "[0-9]" },
	        peg$c59 = function(ds) {
	            //the number might start with 0 but must not be interpreted as an octal number
	            //Hence, the base is passed to parseInt explicitely
	            return parseInt((ds.join('')), 10);
	          },
	        peg$c60 = /^[0-9a-fA-F]/,
	        peg$c61 = { type: "class", value: "[0-9a-fA-F]", description: "[0-9a-fA-F]" },
	        peg$c62 = { type: "other", description: "whitespace" },
	        peg$c63 = function(w) { return w.join(''); },
	        peg$c64 = /^[ \t\n\r]/,
	        peg$c65 = { type: "class", value: "[ \\t\\n\\r]", description: "[ \\t\\n\\r]" },

	        peg$currPos          = 0,
	        peg$savedPos         = 0,
	        peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],
	        peg$maxFailPos       = 0,
	        peg$maxFailExpected  = [],
	        peg$silentFails      = 0,

	        peg$result;

	    if ("startRule" in options) {
	      if (!(options.startRule in peg$startRuleFunctions)) {
	        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
	      }

	      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
	    }

	    function text() {
	      return input.substring(peg$savedPos, peg$currPos);
	    }

	    function location() {
	      return peg$computeLocation(peg$savedPos, peg$currPos);
	    }

	    function expected(description) {
	      throw peg$buildException(
	        null,
	        [{ type: "other", description: description }],
	        input.substring(peg$savedPos, peg$currPos),
	        peg$computeLocation(peg$savedPos, peg$currPos)
	      );
	    }

	    function error(message) {
	      throw peg$buildException(
	        message,
	        null,
	        input.substring(peg$savedPos, peg$currPos),
	        peg$computeLocation(peg$savedPos, peg$currPos)
	      );
	    }

	    function peg$computePosDetails(pos) {
	      var details = peg$posDetailsCache[pos],
	          p, ch;

	      if (details) {
	        return details;
	      } else {
	        p = pos - 1;
	        while (!peg$posDetailsCache[p]) {
	          p--;
	        }

	        details = peg$posDetailsCache[p];
	        details = {
	          line:   details.line,
	          column: details.column,
	          seenCR: details.seenCR
	        };

	        while (p < pos) {
	          ch = input.charAt(p);
	          if (ch === "\n") {
	            if (!details.seenCR) { details.line++; }
	            details.column = 1;
	            details.seenCR = false;
	          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
	            details.line++;
	            details.column = 1;
	            details.seenCR = true;
	          } else {
	            details.column++;
	            details.seenCR = false;
	          }

	          p++;
	        }

	        peg$posDetailsCache[pos] = details;
	        return details;
	      }
	    }

	    function peg$computeLocation(startPos, endPos) {
	      var startPosDetails = peg$computePosDetails(startPos),
	          endPosDetails   = peg$computePosDetails(endPos);

	      return {
	        start: {
	          offset: startPos,
	          line:   startPosDetails.line,
	          column: startPosDetails.column
	        },
	        end: {
	          offset: endPos,
	          line:   endPosDetails.line,
	          column: endPosDetails.column
	        }
	      };
	    }

	    function peg$fail(expected) {
	      if (peg$currPos < peg$maxFailPos) { return; }

	      if (peg$currPos > peg$maxFailPos) {
	        peg$maxFailPos = peg$currPos;
	        peg$maxFailExpected = [];
	      }

	      peg$maxFailExpected.push(expected);
	    }

	    function peg$buildException(message, expected, found, location) {
	      function cleanupExpected(expected) {
	        var i = 1;

	        expected.sort(function(a, b) {
	          if (a.description < b.description) {
	            return -1;
	          } else if (a.description > b.description) {
	            return 1;
	          } else {
	            return 0;
	          }
	        });

	        while (i < expected.length) {
	          if (expected[i - 1] === expected[i]) {
	            expected.splice(i, 1);
	          } else {
	            i++;
	          }
	        }
	      }

	      function buildMessage(expected, found) {
	        function stringEscape(s) {
	          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

	          return s
	            .replace(/\\/g,   '\\\\')
	            .replace(/"/g,    '\\"')
	            .replace(/\x08/g, '\\b')
	            .replace(/\t/g,   '\\t')
	            .replace(/\n/g,   '\\n')
	            .replace(/\f/g,   '\\f')
	            .replace(/\r/g,   '\\r')
	            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
	            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
	            .replace(/[\u0100-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
	            .replace(/[\u1000-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
	        }

	        var expectedDescs = new Array(expected.length),
	            expectedDesc, foundDesc, i;

	        for (i = 0; i < expected.length; i++) {
	          expectedDescs[i] = expected[i].description;
	        }

	        expectedDesc = expected.length > 1
	          ? expectedDescs.slice(0, -1).join(", ")
	              + " or "
	              + expectedDescs[expected.length - 1]
	          : expectedDescs[0];

	        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

	        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
	      }

	      if (expected !== null) {
	        cleanupExpected(expected);
	      }

	      return new peg$SyntaxError(
	        message !== null ? message : buildMessage(expected, found),
	        expected,
	        found,
	        location
	      );
	    }

	    function peg$parsestart() {
	      var s0;

	      s0 = peg$parsemessageFormatPattern();

	      return s0;
	    }

	    function peg$parsemessageFormatPattern() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = [];
	      s2 = peg$parsemessageFormatElement();
	      if (s2 === peg$FAILED) {
	        s2 = peg$parsestring();
	        if (s2 === peg$FAILED) {
	          s2 = peg$parseoctothorpe();
	        }
	      }
	      while (s2 !== peg$FAILED) {
	        s1.push(s2);
	        s2 = peg$parsemessageFormatElement();
	        if (s2 === peg$FAILED) {
	          s2 = peg$parsestring();
	          if (s2 === peg$FAILED) {
	            s2 = peg$parseoctothorpe();
	          }
	        }
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c0(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parsemessageFormatElement() {
	      var s0, s1, s2, s3, s4, s5, s6;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 123) {
	        s1 = peg$c1;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c2); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parseid();
	          if (s3 !== peg$FAILED) {
	            s4 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 44) {
	              s5 = peg$c3;
	              peg$currPos++;
	            } else {
	              s5 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c4); }
	            }
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parseelementFormat();
	              if (s6 !== peg$FAILED) {
	                s5 = [s5, s6];
	                s4 = s5;
	              } else {
	                peg$currPos = s4;
	                s4 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s4;
	              s4 = peg$FAILED;
	            }
	            if (s4 === peg$FAILED) {
	              s4 = null;
	            }
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parse_();
	              if (s5 !== peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 125) {
	                  s6 = peg$c5;
	                  peg$currPos++;
	                } else {
	                  s6 = peg$FAILED;
	                  if (peg$silentFails === 0) { peg$fail(peg$c6); }
	                }
	                if (s6 !== peg$FAILED) {
	                  peg$savedPos = s0;
	                  s1 = peg$c7(s3, s4);
	                  s0 = s1;
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseelementFormat() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parse_();
	      if (s1 !== peg$FAILED) {
	        if (input.substr(peg$currPos, 6) === peg$c8) {
	          s2 = peg$c8;
	          peg$currPos += 6;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c9); }
	        }
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parse_();
	          if (s3 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 44) {
	              s4 = peg$c3;
	              peg$currPos++;
	            } else {
	              s4 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c4); }
	            }
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parse_();
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parsepluralFormatPattern();
	                if (s6 !== peg$FAILED) {
	                  s7 = peg$parse_();
	                  if (s7 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c10(s2, s6);
	                    s0 = s1;
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        s1 = peg$parse_();
	        if (s1 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 13) === peg$c11) {
	            s2 = peg$c11;
	            peg$currPos += 13;
	          } else {
	            s2 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c12); }
	          }
	          if (s2 !== peg$FAILED) {
	            s3 = peg$parse_();
	            if (s3 !== peg$FAILED) {
	              if (input.charCodeAt(peg$currPos) === 44) {
	                s4 = peg$c3;
	                peg$currPos++;
	              } else {
	                s4 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c4); }
	              }
	              if (s4 !== peg$FAILED) {
	                s5 = peg$parse_();
	                if (s5 !== peg$FAILED) {
	                  s6 = peg$parsepluralFormatPattern();
	                  if (s6 !== peg$FAILED) {
	                    s7 = peg$parse_();
	                    if (s7 !== peg$FAILED) {
	                      peg$savedPos = s0;
	                      s1 = peg$c10(s2, s6);
	                      s0 = s1;
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	        if (s0 === peg$FAILED) {
	          s0 = peg$currPos;
	          s1 = peg$parse_();
	          if (s1 !== peg$FAILED) {
	            if (input.substr(peg$currPos, 6) === peg$c13) {
	              s2 = peg$c13;
	              peg$currPos += 6;
	            } else {
	              s2 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c14); }
	            }
	            if (s2 !== peg$FAILED) {
	              s3 = peg$parse_();
	              if (s3 !== peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 44) {
	                  s4 = peg$c3;
	                  peg$currPos++;
	                } else {
	                  s4 = peg$FAILED;
	                  if (peg$silentFails === 0) { peg$fail(peg$c4); }
	                }
	                if (s4 !== peg$FAILED) {
	                  s5 = peg$parse_();
	                  if (s5 !== peg$FAILED) {
	                    s6 = peg$parseselectFormatPattern();
	                    if (s6 !== peg$FAILED) {
	                      s7 = peg$parse_();
	                      if (s7 !== peg$FAILED) {
	                        peg$savedPos = s0;
	                        s1 = peg$c10(s2, s6);
	                        s0 = s1;
	                      } else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	          if (s0 === peg$FAILED) {
	            s0 = peg$currPos;
	            s1 = peg$parse_();
	            if (s1 !== peg$FAILED) {
	              s2 = peg$parseid();
	              if (s2 !== peg$FAILED) {
	                s3 = [];
	                s4 = peg$parseargStylePattern();
	                while (s4 !== peg$FAILED) {
	                  s3.push(s4);
	                  s4 = peg$parseargStylePattern();
	                }
	                if (s3 !== peg$FAILED) {
	                  peg$savedPos = s0;
	                  s1 = peg$c15(s2, s3);
	                  s0 = s1;
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parsepluralFormatPattern() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      s1 = peg$parseoffsetPattern();
	      if (s1 === peg$FAILED) {
	        s1 = null;
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$parsepluralForm();
	        if (s3 !== peg$FAILED) {
	          while (s3 !== peg$FAILED) {
	            s2.push(s3);
	            s3 = peg$parsepluralForm();
	          }
	        } else {
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c16(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseoffsetPattern() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parse_();
	      if (s1 !== peg$FAILED) {
	        if (input.substr(peg$currPos, 6) === peg$c17) {
	          s2 = peg$c17;
	          peg$currPos += 6;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c18); }
	        }
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parse_();
	          if (s3 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 58) {
	              s4 = peg$c19;
	              peg$currPos++;
	            } else {
	              s4 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c20); }
	            }
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parse_();
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parsedigits();
	                if (s6 !== peg$FAILED) {
	                  s7 = peg$parse_();
	                  if (s7 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c21(s6);
	                    s0 = s1;
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parsepluralForm() {
	      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

	      s0 = peg$currPos;
	      s1 = peg$parse_();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parsepluralKey();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parse_();
	          if (s3 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 123) {
	              s4 = peg$c1;
	              peg$currPos++;
	            } else {
	              s4 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c2); }
	            }
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parse_();
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parsemessageFormatPattern();
	                if (s6 !== peg$FAILED) {
	                  s7 = peg$parse_();
	                  if (s7 !== peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 125) {
	                      s8 = peg$c5;
	                      peg$currPos++;
	                    } else {
	                      s8 = peg$FAILED;
	                      if (peg$silentFails === 0) { peg$fail(peg$c6); }
	                    }
	                    if (s8 !== peg$FAILED) {
	                      peg$savedPos = s0;
	                      s1 = peg$c22(s2, s6);
	                      s0 = s1;
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parsepluralKey() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = peg$parseid();
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c23(s1);
	      }
	      s0 = s1;
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 61) {
	          s1 = peg$c24;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c25); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = peg$parsedigits();
	          if (s2 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c21(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      }

	      return s0;
	    }

	    function peg$parseselectFormatPattern() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = [];
	      s2 = peg$parseselectForm();
	      if (s2 !== peg$FAILED) {
	        while (s2 !== peg$FAILED) {
	          s1.push(s2);
	          s2 = peg$parseselectForm();
	        }
	      } else {
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c26(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseselectForm() {
	      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

	      s0 = peg$currPos;
	      s1 = peg$parse_();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseid();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parse_();
	          if (s3 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 123) {
	              s4 = peg$c1;
	              peg$currPos++;
	            } else {
	              s4 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c2); }
	            }
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parse_();
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parsemessageFormatPattern();
	                if (s6 !== peg$FAILED) {
	                  s7 = peg$parse_();
	                  if (s7 !== peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 125) {
	                      s8 = peg$c5;
	                      peg$currPos++;
	                    } else {
	                      s8 = peg$FAILED;
	                      if (peg$silentFails === 0) { peg$fail(peg$c6); }
	                    }
	                    if (s8 !== peg$FAILED) {
	                      peg$savedPos = s0;
	                      s1 = peg$c22(s2, s6);
	                      s0 = s1;
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseargStylePattern() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      s1 = peg$parse_();
	      if (s1 !== peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 44) {
	          s2 = peg$c3;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c4); }
	        }
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parse_();
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parseid();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parse_();
	              if (s5 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c27(s4);
	                s0 = s1;
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseoctothorpe() {
	      var s0, s1;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 35) {
	        s1 = peg$c28;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c29); }
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c30();
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parsestring() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = [];
	      s2 = peg$parsechars();
	      if (s2 === peg$FAILED) {
	        s2 = peg$parsewhitespace();
	      }
	      if (s2 !== peg$FAILED) {
	        while (s2 !== peg$FAILED) {
	          s1.push(s2);
	          s2 = peg$parsechars();
	          if (s2 === peg$FAILED) {
	            s2 = peg$parsewhitespace();
	          }
	        }
	      } else {
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c31(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseid() {
	      var s0, s1, s2, s3, s4, s5, s6;

	      peg$silentFails++;
	      s0 = peg$currPos;
	      s1 = peg$parse_();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        s3 = peg$currPos;
	        if (peg$c33.test(input.charAt(peg$currPos))) {
	          s4 = input.charAt(peg$currPos);
	          peg$currPos++;
	        } else {
	          s4 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c34); }
	        }
	        if (s4 !== peg$FAILED) {
	          s5 = [];
	          if (peg$c35.test(input.charAt(peg$currPos))) {
	            s6 = input.charAt(peg$currPos);
	            peg$currPos++;
	          } else {
	            s6 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c36); }
	          }
	          while (s6 !== peg$FAILED) {
	            s5.push(s6);
	            if (peg$c35.test(input.charAt(peg$currPos))) {
	              s6 = input.charAt(peg$currPos);
	              peg$currPos++;
	            } else {
	              s6 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c36); }
	            }
	          }
	          if (s5 !== peg$FAILED) {
	            s4 = [s4, s5];
	            s3 = s4;
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        if (s3 !== peg$FAILED) {
	          s2 = input.substring(s2, peg$currPos);
	        } else {
	          s2 = s3;
	        }
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parse_();
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c37(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      peg$silentFails--;
	      if (s0 === peg$FAILED) {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c32); }
	      }

	      return s0;
	    }

	    function peg$parsechars() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = [];
	      s2 = peg$parsechar();
	      if (s2 !== peg$FAILED) {
	        while (s2 !== peg$FAILED) {
	          s1.push(s2);
	          s2 = peg$parsechar();
	        }
	      } else {
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c38(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parsechar() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      if (peg$c39.test(input.charAt(peg$currPos))) {
	        s1 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c40); }
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c41(s1);
	      }
	      s0 = s1;
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 2) === peg$c42) {
	          s1 = peg$c42;
	          peg$currPos += 2;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c43); }
	        }
	        if (s1 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c44();
	        }
	        s0 = s1;
	        if (s0 === peg$FAILED) {
	          s0 = peg$currPos;
	          if (input.substr(peg$currPos, 2) === peg$c45) {
	            s1 = peg$c45;
	            peg$currPos += 2;
	          } else {
	            s1 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c46); }
	          }
	          if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c47();
	          }
	          s0 = s1;
	          if (s0 === peg$FAILED) {
	            s0 = peg$currPos;
	            if (input.substr(peg$currPos, 2) === peg$c48) {
	              s1 = peg$c48;
	              peg$currPos += 2;
	            } else {
	              s1 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c49); }
	            }
	            if (s1 !== peg$FAILED) {
	              peg$savedPos = s0;
	              s1 = peg$c50();
	            }
	            s0 = s1;
	            if (s0 === peg$FAILED) {
	              s0 = peg$currPos;
	              if (input.substr(peg$currPos, 2) === peg$c51) {
	                s1 = peg$c51;
	                peg$currPos += 2;
	              } else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c52); }
	              }
	              if (s1 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c53();
	              }
	              s0 = s1;
	              if (s0 === peg$FAILED) {
	                s0 = peg$currPos;
	                if (input.substr(peg$currPos, 2) === peg$c54) {
	                  s1 = peg$c54;
	                  peg$currPos += 2;
	                } else {
	                  s1 = peg$FAILED;
	                  if (peg$silentFails === 0) { peg$fail(peg$c55); }
	                }
	                if (s1 !== peg$FAILED) {
	                  s2 = peg$parsehexDigit();
	                  if (s2 !== peg$FAILED) {
	                    s3 = peg$parsehexDigit();
	                    if (s3 !== peg$FAILED) {
	                      s4 = peg$parsehexDigit();
	                      if (s4 !== peg$FAILED) {
	                        s5 = peg$parsehexDigit();
	                        if (s5 !== peg$FAILED) {
	                          peg$savedPos = s0;
	                          s1 = peg$c56(s2, s3, s4, s5);
	                          s0 = s1;
	                        } else {
	                          peg$currPos = s0;
	                          s0 = peg$FAILED;
	                        }
	                      } else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              }
	            }
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parsedigits() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = [];
	      if (peg$c57.test(input.charAt(peg$currPos))) {
	        s2 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c58); }
	      }
	      if (s2 !== peg$FAILED) {
	        while (s2 !== peg$FAILED) {
	          s1.push(s2);
	          if (peg$c57.test(input.charAt(peg$currPos))) {
	            s2 = input.charAt(peg$currPos);
	            peg$currPos++;
	          } else {
	            s2 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c58); }
	          }
	        }
	      } else {
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c59(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parsehexDigit() {
	      var s0;

	      if (peg$c60.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c61); }
	      }

	      return s0;
	    }

	    function peg$parse_() {
	      var s0, s1, s2;

	      peg$silentFails++;
	      s0 = peg$currPos;
	      s1 = [];
	      s2 = peg$parsewhitespace();
	      while (s2 !== peg$FAILED) {
	        s1.push(s2);
	        s2 = peg$parsewhitespace();
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c63(s1);
	      }
	      s0 = s1;
	      peg$silentFails--;
	      if (s0 === peg$FAILED) {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c62); }
	      }

	      return s0;
	    }

	    function peg$parsewhitespace() {
	      var s0;

	      if (peg$c64.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c65); }
	      }

	      return s0;
	    }

	    peg$result = peg$startRuleFunction();

	    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
	      return peg$result;
	    } else {
	      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
	        peg$fail({ type: "end", description: "end of input" });
	      }

	      throw peg$buildException(
	        null,
	        peg$maxFailExpected,
	        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
	        peg$maxFailPos < input.length
	          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
	          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
	      );
	    }
	  }

	  return {
	    SyntaxError: peg$SyntaxError,
	    parse:       peg$parse
	  };
	})();


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var _cp = [
	function(n, ord) {
	  if (ord) return 'other';
	  return 'other';
	},
	function(n, ord) {
	  if (ord) return 'other';
	  return (n == 1) ? 'one' : 'other';
	},
	function(n, ord) {
	  if (ord) return 'other';
	  return ((n == 0
	          || n == 1)) ? 'one' : 'other';
	},
	function(n, ord) {
	  var s = String(n).split('.'), v0 = !s[1];
	  if (ord) return 'other';
	  return (n == 1 && v0) ? 'one' : 'other';
	}
	];

	(function (root, plurals) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (plurals), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    module.exports = plurals;
	  } else {
	    root.plurals = plurals;
	  }
	}(this, {
	af: _cp[1],

	ak: _cp[2],

	am: function(n, ord) {
	  if (ord) return 'other';
	  return (n >= 0 && n <= 1) ? 'one' : 'other';
	},

	ar: function(n, ord) {
	  var s = String(n).split('.'), t0 = Number(s[0]) == n,
	      n100 = t0 && s[0].slice(-2);
	  if (ord) return 'other';
	  return (n == 0) ? 'zero'
	      : (n == 1) ? 'one'
	      : (n == 2) ? 'two'
	      : ((n100 >= 3 && n100 <= 10)) ? 'few'
	      : ((n100 >= 11 && n100 <= 99)) ? 'many'
	      : 'other';
	},

	as: function(n, ord) {
	  if (ord) return ((n == 1 || n == 5 || n == 7 || n == 8 || n == 9
	          || n == 10)) ? 'one'
	      : ((n == 2
	          || n == 3)) ? 'two'
	      : (n == 4) ? 'few'
	      : (n == 6) ? 'many'
	      : 'other';
	  return (n >= 0 && n <= 1) ? 'one' : 'other';
	},

	asa: _cp[1],

	ast: _cp[3],

	az: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], i10 = i.slice(-1),
	      i100 = i.slice(-2), i1000 = i.slice(-3);
	  if (ord) return ((i10 == 1 || i10 == 2 || i10 == 5 || i10 == 7 || i10 == 8)
	          || (i100 == 20 || i100 == 50 || i100 == 70
	          || i100 == 80)) ? 'one'
	      : ((i10 == 3 || i10 == 4) || (i1000 == 100 || i1000 == 200
	          || i1000 == 300 || i1000 == 400 || i1000 == 500 || i1000 == 600 || i1000 == 700
	          || i1000 == 800
	          || i1000 == 900)) ? 'few'
	      : (i == 0 || i10 == 6 || (i100 == 40 || i100 == 60
	          || i100 == 90)) ? 'many'
	      : 'other';
	  return (n == 1) ? 'one' : 'other';
	},

	be: function(n, ord) {
	  var s = String(n).split('.'), t0 = Number(s[0]) == n,
	      n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
	  if (ord) return ((n10 == 2
	          || n10 == 3) && n100 != 12 && n100 != 13) ? 'few' : 'other';
	  return (n10 == 1 && n100 != 11) ? 'one'
	      : ((n10 >= 2 && n10 <= 4) && (n100 < 12
	          || n100 > 14)) ? 'few'
	      : (t0 && n10 == 0 || (n10 >= 5 && n10 <= 9)
	          || (n100 >= 11 && n100 <= 14)) ? 'many'
	      : 'other';
	},

	bem: _cp[1],

	bez: _cp[1],

	bg: _cp[1],

	bh: _cp[2],

	bm: _cp[0],

	bn: function(n, ord) {
	  if (ord) return ((n == 1 || n == 5 || n == 7 || n == 8 || n == 9
	          || n == 10)) ? 'one'
	      : ((n == 2
	          || n == 3)) ? 'two'
	      : (n == 4) ? 'few'
	      : (n == 6) ? 'many'
	      : 'other';
	  return (n >= 0 && n <= 1) ? 'one' : 'other';
	},

	bo: _cp[0],

	br: function(n, ord) {
	  var s = String(n).split('.'), t0 = Number(s[0]) == n,
	      n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2),
	      n1000000 = t0 && s[0].slice(-6);
	  if (ord) return 'other';
	  return (n10 == 1 && n100 != 11 && n100 != 71 && n100 != 91) ? 'one'
	      : (n10 == 2 && n100 != 12 && n100 != 72 && n100 != 92) ? 'two'
	      : (((n10 == 3 || n10 == 4) || n10 == 9) && (n100 < 10
	          || n100 > 19) && (n100 < 70 || n100 > 79) && (n100 < 90
	          || n100 > 99)) ? 'few'
	      : (n != 0 && t0 && n1000000 == 0) ? 'many'
	      : 'other';
	},

	brx: _cp[1],

	bs: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],
	      i10 = i.slice(-1), i100 = i.slice(-2), f10 = f.slice(-1), f100 = f.slice(-2);
	  if (ord) return 'other';
	  return (v0 && i10 == 1 && i100 != 11
	          || f10 == 1 && f100 != 11) ? 'one'
	      : (v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12 || i100 > 14)
	          || (f10 >= 2 && f10 <= 4) && (f100 < 12
	          || f100 > 14)) ? 'few'
	      : 'other';
	},

	ca: function(n, ord) {
	  var s = String(n).split('.'), v0 = !s[1];
	  if (ord) return ((n == 1
	          || n == 3)) ? 'one'
	      : (n == 2) ? 'two'
	      : (n == 4) ? 'few'
	      : 'other';
	  return (n == 1 && v0) ? 'one' : 'other';
	},

	ce: _cp[1],

	cgg: _cp[1],

	chr: _cp[1],

	ckb: _cp[1],

	cs: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], v0 = !s[1];
	  if (ord) return 'other';
	  return (n == 1 && v0) ? 'one'
	      : ((i >= 2 && i <= 4) && v0) ? 'few'
	      : (!v0) ? 'many'
	      : 'other';
	},

	cy: function(n, ord) {
	  if (ord) return ((n == 0 || n == 7 || n == 8
	          || n == 9)) ? 'zero'
	      : (n == 1) ? 'one'
	      : (n == 2) ? 'two'
	      : ((n == 3
	          || n == 4)) ? 'few'
	      : ((n == 5
	          || n == 6)) ? 'many'
	      : 'other';
	  return (n == 0) ? 'zero'
	      : (n == 1) ? 'one'
	      : (n == 2) ? 'two'
	      : (n == 3) ? 'few'
	      : (n == 6) ? 'many'
	      : 'other';
	},

	da: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], t0 = Number(s[0]) == n;
	  if (ord) return 'other';
	  return (n == 1 || !t0 && (i == 0
	          || i == 1)) ? 'one' : 'other';
	},

	de: _cp[3],

	dsb: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],
	      i100 = i.slice(-2), f100 = f.slice(-2);
	  if (ord) return 'other';
	  return (v0 && i100 == 1
	          || f100 == 1) ? 'one'
	      : (v0 && i100 == 2
	          || f100 == 2) ? 'two'
	      : (v0 && (i100 == 3 || i100 == 4) || (f100 == 3
	          || f100 == 4)) ? 'few'
	      : 'other';
	},

	dv: _cp[1],

	dz: _cp[0],

	ee: _cp[1],

	el: _cp[1],

	en: function(n, ord) {
	  var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,
	      n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
	  if (ord) return (n10 == 1 && n100 != 11) ? 'one'
	      : (n10 == 2 && n100 != 12) ? 'two'
	      : (n10 == 3 && n100 != 13) ? 'few'
	      : 'other';
	  return (n == 1 && v0) ? 'one' : 'other';
	},

	eo: _cp[1],

	es: _cp[1],

	et: _cp[3],

	eu: _cp[1],

	fa: function(n, ord) {
	  if (ord) return 'other';
	  return (n >= 0 && n <= 1) ? 'one' : 'other';
	},

	ff: function(n, ord) {
	  if (ord) return 'other';
	  return (n >= 0 && n < 2) ? 'one' : 'other';
	},

	fi: _cp[3],

	fil: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],
	      i10 = i.slice(-1), f10 = f.slice(-1);
	  if (ord) return (n == 1) ? 'one' : 'other';
	  return (v0 && (i == 1 || i == 2 || i == 3)
	          || v0 && i10 != 4 && i10 != 6 && i10 != 9
	          || !v0 && f10 != 4 && f10 != 6 && f10 != 9) ? 'one' : 'other';
	},

	fo: _cp[1],

	fr: function(n, ord) {
	  if (ord) return (n == 1) ? 'one' : 'other';
	  return (n >= 0 && n < 2) ? 'one' : 'other';
	},

	fur: _cp[1],

	fy: _cp[3],

	ga: function(n, ord) {
	  var s = String(n).split('.'), t0 = Number(s[0]) == n;
	  if (ord) return (n == 1) ? 'one' : 'other';
	  return (n == 1) ? 'one'
	      : (n == 2) ? 'two'
	      : ((t0 && n >= 3 && n <= 6)) ? 'few'
	      : ((t0 && n >= 7 && n <= 10)) ? 'many'
	      : 'other';
	},

	gd: function(n, ord) {
	  var s = String(n).split('.'), t0 = Number(s[0]) == n;
	  if (ord) return 'other';
	  return ((n == 1
	          || n == 11)) ? 'one'
	      : ((n == 2
	          || n == 12)) ? 'two'
	      : (((t0 && n >= 3 && n <= 10)
	          || (t0 && n >= 13 && n <= 19))) ? 'few'
	      : 'other';
	},

	gl: _cp[3],

	gsw: _cp[1],

	gu: function(n, ord) {
	  if (ord) return (n == 1) ? 'one'
	      : ((n == 2
	          || n == 3)) ? 'two'
	      : (n == 4) ? 'few'
	      : (n == 6) ? 'many'
	      : 'other';
	  return (n >= 0 && n <= 1) ? 'one' : 'other';
	},

	guw: _cp[2],

	gv: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], v0 = !s[1], i10 = i.slice(-1),
	      i100 = i.slice(-2);
	  if (ord) return 'other';
	  return (v0 && i10 == 1) ? 'one'
	      : (v0 && i10 == 2) ? 'two'
	      : (v0 && (i100 == 0 || i100 == 20 || i100 == 40 || i100 == 60
	          || i100 == 80)) ? 'few'
	      : (!v0) ? 'many'
	      : 'other';
	},

	ha: _cp[1],

	haw: _cp[1],

	he: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], v0 = !s[1], t0 = Number(s[0]) == n,
	      n10 = t0 && s[0].slice(-1);
	  if (ord) return 'other';
	  return (n == 1 && v0) ? 'one'
	      : (i == 2 && v0) ? 'two'
	      : (v0 && (n < 0
	          || n > 10) && t0 && n10 == 0) ? 'many'
	      : 'other';
	},

	hi: function(n, ord) {
	  if (ord) return (n == 1) ? 'one'
	      : ((n == 2
	          || n == 3)) ? 'two'
	      : (n == 4) ? 'few'
	      : (n == 6) ? 'many'
	      : 'other';
	  return (n >= 0 && n <= 1) ? 'one' : 'other';
	},

	hr: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],
	      i10 = i.slice(-1), i100 = i.slice(-2), f10 = f.slice(-1), f100 = f.slice(-2);
	  if (ord) return 'other';
	  return (v0 && i10 == 1 && i100 != 11
	          || f10 == 1 && f100 != 11) ? 'one'
	      : (v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12 || i100 > 14)
	          || (f10 >= 2 && f10 <= 4) && (f100 < 12
	          || f100 > 14)) ? 'few'
	      : 'other';
	},

	hsb: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],
	      i100 = i.slice(-2), f100 = f.slice(-2);
	  if (ord) return 'other';
	  return (v0 && i100 == 1
	          || f100 == 1) ? 'one'
	      : (v0 && i100 == 2
	          || f100 == 2) ? 'two'
	      : (v0 && (i100 == 3 || i100 == 4) || (f100 == 3
	          || f100 == 4)) ? 'few'
	      : 'other';
	},

	hu: function(n, ord) {
	  if (ord) return ((n == 1
	          || n == 5)) ? 'one' : 'other';
	  return (n == 1) ? 'one' : 'other';
	},

	hy: function(n, ord) {
	  if (ord) return (n == 1) ? 'one' : 'other';
	  return (n >= 0 && n < 2) ? 'one' : 'other';
	},

	id: _cp[0],

	ig: _cp[0],

	ii: _cp[0],

	"in": _cp[0],

	is: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], t0 = Number(s[0]) == n,
	      i10 = i.slice(-1), i100 = i.slice(-2);
	  if (ord) return 'other';
	  return (t0 && i10 == 1 && i100 != 11
	          || !t0) ? 'one' : 'other';
	},

	it: function(n, ord) {
	  var s = String(n).split('.'), v0 = !s[1];
	  if (ord) return ((n == 11 || n == 8 || n == 80
	          || n == 800)) ? 'many' : 'other';
	  return (n == 1 && v0) ? 'one' : 'other';
	},

	iu: function(n, ord) {
	  if (ord) return 'other';
	  return (n == 1) ? 'one'
	      : (n == 2) ? 'two'
	      : 'other';
	},

	iw: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], v0 = !s[1], t0 = Number(s[0]) == n,
	      n10 = t0 && s[0].slice(-1);
	  if (ord) return 'other';
	  return (n == 1 && v0) ? 'one'
	      : (i == 2 && v0) ? 'two'
	      : (v0 && (n < 0
	          || n > 10) && t0 && n10 == 0) ? 'many'
	      : 'other';
	},

	ja: _cp[0],

	jbo: _cp[0],

	jgo: _cp[1],

	ji: _cp[3],

	jmc: _cp[1],

	jv: _cp[0],

	jw: _cp[0],

	ka: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], i100 = i.slice(-2);
	  if (ord) return (i == 1) ? 'one'
	      : (i == 0 || ((i100 >= 2 && i100 <= 20) || i100 == 40 || i100 == 60
	          || i100 == 80)) ? 'many'
	      : 'other';
	  return (n == 1) ? 'one' : 'other';
	},

	kab: function(n, ord) {
	  if (ord) return 'other';
	  return (n >= 0 && n < 2) ? 'one' : 'other';
	},

	kaj: _cp[1],

	kcg: _cp[1],

	kde: _cp[0],

	kea: _cp[0],

	kk: function(n, ord) {
	  var s = String(n).split('.'), t0 = Number(s[0]) == n,
	      n10 = t0 && s[0].slice(-1);
	  if (ord) return (n10 == 6 || n10 == 9
	          || t0 && n10 == 0 && n != 0) ? 'many' : 'other';
	  return (n == 1) ? 'one' : 'other';
	},

	kkj: _cp[1],

	kl: _cp[1],

	km: _cp[0],

	kn: function(n, ord) {
	  if (ord) return 'other';
	  return (n >= 0 && n <= 1) ? 'one' : 'other';
	},

	ko: _cp[0],

	ks: _cp[1],

	ksb: _cp[1],

	ksh: function(n, ord) {
	  if (ord) return 'other';
	  return (n == 0) ? 'zero'
	      : (n == 1) ? 'one'
	      : 'other';
	},

	ku: _cp[1],

	kw: function(n, ord) {
	  if (ord) return 'other';
	  return (n == 1) ? 'one'
	      : (n == 2) ? 'two'
	      : 'other';
	},

	ky: _cp[1],

	lag: function(n, ord) {
	  var s = String(n).split('.'), i = s[0];
	  if (ord) return 'other';
	  return (n == 0) ? 'zero'
	      : ((i == 0
	          || i == 1) && n != 0) ? 'one'
	      : 'other';
	},

	lb: _cp[1],

	lg: _cp[1],

	lkt: _cp[0],

	ln: _cp[2],

	lo: function(n, ord) {
	  if (ord) return (n == 1) ? 'one' : 'other';
	  return 'other';
	},

	lt: function(n, ord) {
	  var s = String(n).split('.'), f = s[1] || '', t0 = Number(s[0]) == n,
	      n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
	  if (ord) return 'other';
	  return (n10 == 1 && (n100 < 11
	          || n100 > 19)) ? 'one'
	      : ((n10 >= 2 && n10 <= 9) && (n100 < 11
	          || n100 > 19)) ? 'few'
	      : (f != 0) ? 'many'
	      : 'other';
	},

	lv: function(n, ord) {
	  var s = String(n).split('.'), f = s[1] || '', v = f.length,
	      t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1),
	      n100 = t0 && s[0].slice(-2), f100 = f.slice(-2), f10 = f.slice(-1);
	  if (ord) return 'other';
	  return (t0 && n10 == 0 || (n100 >= 11 && n100 <= 19)
	          || v == 2 && (f100 >= 11 && f100 <= 19)) ? 'zero'
	      : (n10 == 1 && n100 != 11 || v == 2 && f10 == 1 && f100 != 11
	          || v != 2 && f10 == 1) ? 'one'
	      : 'other';
	},

	mas: _cp[1],

	mg: _cp[2],

	mgo: _cp[1],

	mk: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],
	      i10 = i.slice(-1), i100 = i.slice(-2), f10 = f.slice(-1);
	  if (ord) return (i10 == 1 && i100 != 11) ? 'one'
	      : (i10 == 2 && i100 != 12) ? 'two'
	      : ((i10 == 7
	          || i10 == 8) && i100 != 17 && i100 != 18) ? 'many'
	      : 'other';
	  return (v0 && i10 == 1
	          || f10 == 1) ? 'one' : 'other';
	},

	ml: _cp[1],

	mn: _cp[1],

	mo: function(n, ord) {
	  var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,
	      n100 = t0 && s[0].slice(-2);
	  if (ord) return (n == 1) ? 'one' : 'other';
	  return (n == 1 && v0) ? 'one'
	      : (!v0 || n == 0
	          || n != 1 && (n100 >= 1 && n100 <= 19)) ? 'few'
	      : 'other';
	},

	mr: function(n, ord) {
	  if (ord) return (n == 1) ? 'one'
	      : ((n == 2
	          || n == 3)) ? 'two'
	      : (n == 4) ? 'few'
	      : 'other';
	  return (n >= 0 && n <= 1) ? 'one' : 'other';
	},

	ms: function(n, ord) {
	  if (ord) return (n == 1) ? 'one' : 'other';
	  return 'other';
	},

	mt: function(n, ord) {
	  var s = String(n).split('.'), t0 = Number(s[0]) == n,
	      n100 = t0 && s[0].slice(-2);
	  if (ord) return 'other';
	  return (n == 1) ? 'one'
	      : (n == 0
	          || (n100 >= 2 && n100 <= 10)) ? 'few'
	      : ((n100 >= 11 && n100 <= 19)) ? 'many'
	      : 'other';
	},

	my: _cp[0],

	nah: _cp[1],

	naq: function(n, ord) {
	  if (ord) return 'other';
	  return (n == 1) ? 'one'
	      : (n == 2) ? 'two'
	      : 'other';
	},

	nb: _cp[1],

	nd: _cp[1],

	ne: function(n, ord) {
	  var s = String(n).split('.'), t0 = Number(s[0]) == n;
	  if (ord) return ((t0 && n >= 1 && n <= 4)) ? 'one' : 'other';
	  return (n == 1) ? 'one' : 'other';
	},

	nl: _cp[3],

	nn: _cp[1],

	nnh: _cp[1],

	no: _cp[1],

	nqo: _cp[0],

	nr: _cp[1],

	nso: _cp[2],

	ny: _cp[1],

	nyn: _cp[1],

	om: _cp[1],

	or: _cp[1],

	os: _cp[1],

	pa: _cp[2],

	pap: _cp[1],

	pl: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], v0 = !s[1], i10 = i.slice(-1),
	      i100 = i.slice(-2);
	  if (ord) return 'other';
	  return (n == 1 && v0) ? 'one'
	      : (v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12
	          || i100 > 14)) ? 'few'
	      : (v0 && i != 1 && (i10 == 0 || i10 == 1)
	          || v0 && (i10 >= 5 && i10 <= 9)
	          || v0 && (i100 >= 12 && i100 <= 14)) ? 'many'
	      : 'other';
	},

	prg: function(n, ord) {
	  var s = String(n).split('.'), f = s[1] || '', v = f.length,
	      t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1),
	      n100 = t0 && s[0].slice(-2), f100 = f.slice(-2), f10 = f.slice(-1);
	  if (ord) return 'other';
	  return (t0 && n10 == 0 || (n100 >= 11 && n100 <= 19)
	          || v == 2 && (f100 >= 11 && f100 <= 19)) ? 'zero'
	      : (n10 == 1 && n100 != 11 || v == 2 && f10 == 1 && f100 != 11
	          || v != 2 && f10 == 1) ? 'one'
	      : 'other';
	},

	ps: _cp[1],

	pt: function(n, ord) {
	  var s = String(n).split('.'), t0 = Number(s[0]) == n;
	  if (ord) return 'other';
	  return ((t0 && n >= 0 && n <= 2) && n != 2) ? 'one' : 'other';
	},

	"pt-PT": _cp[3],

	rm: _cp[1],

	ro: function(n, ord) {
	  var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,
	      n100 = t0 && s[0].slice(-2);
	  if (ord) return (n == 1) ? 'one' : 'other';
	  return (n == 1 && v0) ? 'one'
	      : (!v0 || n == 0
	          || n != 1 && (n100 >= 1 && n100 <= 19)) ? 'few'
	      : 'other';
	},

	rof: _cp[1],

	root: _cp[0],

	ru: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], v0 = !s[1], i10 = i.slice(-1),
	      i100 = i.slice(-2);
	  if (ord) return 'other';
	  return (v0 && i10 == 1 && i100 != 11) ? 'one'
	      : (v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12
	          || i100 > 14)) ? 'few'
	      : (v0 && i10 == 0 || v0 && (i10 >= 5 && i10 <= 9)
	          || v0 && (i100 >= 11 && i100 <= 14)) ? 'many'
	      : 'other';
	},

	rwk: _cp[1],

	sah: _cp[0],

	saq: _cp[1],

	sdh: _cp[1],

	se: function(n, ord) {
	  if (ord) return 'other';
	  return (n == 1) ? 'one'
	      : (n == 2) ? 'two'
	      : 'other';
	},

	seh: _cp[1],

	ses: _cp[0],

	sg: _cp[0],

	sh: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],
	      i10 = i.slice(-1), i100 = i.slice(-2), f10 = f.slice(-1), f100 = f.slice(-2);
	  if (ord) return 'other';
	  return (v0 && i10 == 1 && i100 != 11
	          || f10 == 1 && f100 != 11) ? 'one'
	      : (v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12 || i100 > 14)
	          || (f10 >= 2 && f10 <= 4) && (f100 < 12
	          || f100 > 14)) ? 'few'
	      : 'other';
	},

	shi: function(n, ord) {
	  var s = String(n).split('.'), t0 = Number(s[0]) == n;
	  if (ord) return 'other';
	  return (n >= 0 && n <= 1) ? 'one'
	      : ((t0 && n >= 2 && n <= 10)) ? 'few'
	      : 'other';
	},

	si: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], f = s[1] || '';
	  if (ord) return 'other';
	  return ((n == 0 || n == 1)
	          || i == 0 && f == 1) ? 'one' : 'other';
	},

	sk: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], v0 = !s[1];
	  if (ord) return 'other';
	  return (n == 1 && v0) ? 'one'
	      : ((i >= 2 && i <= 4) && v0) ? 'few'
	      : (!v0) ? 'many'
	      : 'other';
	},

	sl: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], v0 = !s[1], i100 = i.slice(-2);
	  if (ord) return 'other';
	  return (v0 && i100 == 1) ? 'one'
	      : (v0 && i100 == 2) ? 'two'
	      : (v0 && (i100 == 3 || i100 == 4)
	          || !v0) ? 'few'
	      : 'other';
	},

	sma: function(n, ord) {
	  if (ord) return 'other';
	  return (n == 1) ? 'one'
	      : (n == 2) ? 'two'
	      : 'other';
	},

	smi: function(n, ord) {
	  if (ord) return 'other';
	  return (n == 1) ? 'one'
	      : (n == 2) ? 'two'
	      : 'other';
	},

	smj: function(n, ord) {
	  if (ord) return 'other';
	  return (n == 1) ? 'one'
	      : (n == 2) ? 'two'
	      : 'other';
	},

	smn: function(n, ord) {
	  if (ord) return 'other';
	  return (n == 1) ? 'one'
	      : (n == 2) ? 'two'
	      : 'other';
	},

	sms: function(n, ord) {
	  if (ord) return 'other';
	  return (n == 1) ? 'one'
	      : (n == 2) ? 'two'
	      : 'other';
	},

	sn: _cp[1],

	so: _cp[1],

	sq: function(n, ord) {
	  var s = String(n).split('.'), t0 = Number(s[0]) == n,
	      n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
	  if (ord) return (n == 1) ? 'one'
	      : (n10 == 4 && n100 != 14) ? 'many'
	      : 'other';
	  return (n == 1) ? 'one' : 'other';
	},

	sr: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],
	      i10 = i.slice(-1), i100 = i.slice(-2), f10 = f.slice(-1), f100 = f.slice(-2);
	  if (ord) return 'other';
	  return (v0 && i10 == 1 && i100 != 11
	          || f10 == 1 && f100 != 11) ? 'one'
	      : (v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12 || i100 > 14)
	          || (f10 >= 2 && f10 <= 4) && (f100 < 12
	          || f100 > 14)) ? 'few'
	      : 'other';
	},

	ss: _cp[1],

	ssy: _cp[1],

	st: _cp[1],

	sv: function(n, ord) {
	  var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,
	      n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
	  if (ord) return ((n10 == 1
	          || n10 == 2) && n100 != 11 && n100 != 12) ? 'one' : 'other';
	  return (n == 1 && v0) ? 'one' : 'other';
	},

	sw: _cp[3],

	syr: _cp[1],

	ta: _cp[1],

	te: _cp[1],

	teo: _cp[1],

	th: _cp[0],

	ti: _cp[2],

	tig: _cp[1],

	tk: _cp[1],

	tl: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], f = s[1] || '', v0 = !s[1],
	      i10 = i.slice(-1), f10 = f.slice(-1);
	  if (ord) return (n == 1) ? 'one' : 'other';
	  return (v0 && (i == 1 || i == 2 || i == 3)
	          || v0 && i10 != 4 && i10 != 6 && i10 != 9
	          || !v0 && f10 != 4 && f10 != 6 && f10 != 9) ? 'one' : 'other';
	},

	tn: _cp[1],

	to: _cp[0],

	tr: _cp[1],

	ts: _cp[1],

	tzm: function(n, ord) {
	  var s = String(n).split('.'), t0 = Number(s[0]) == n;
	  if (ord) return 'other';
	  return ((n == 0 || n == 1)
	          || (t0 && n >= 11 && n <= 99)) ? 'one' : 'other';
	},

	ug: _cp[1],

	uk: function(n, ord) {
	  var s = String(n).split('.'), i = s[0], v0 = !s[1], t0 = Number(s[0]) == n,
	      n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2), i10 = i.slice(-1),
	      i100 = i.slice(-2);
	  if (ord) return (n10 == 3 && n100 != 13) ? 'few' : 'other';
	  return (v0 && i10 == 1 && i100 != 11) ? 'one'
	      : (v0 && (i10 >= 2 && i10 <= 4) && (i100 < 12
	          || i100 > 14)) ? 'few'
	      : (v0 && i10 == 0 || v0 && (i10 >= 5 && i10 <= 9)
	          || v0 && (i100 >= 11 && i100 <= 14)) ? 'many'
	      : 'other';
	},

	ur: _cp[3],

	uz: _cp[1],

	ve: _cp[1],

	vi: function(n, ord) {
	  if (ord) return (n == 1) ? 'one' : 'other';
	  return 'other';
	},

	vo: _cp[1],

	vun: _cp[1],

	wa: _cp[2],

	wae: _cp[1],

	wo: _cp[0],

	xh: _cp[1],

	xog: _cp[1],

	yi: _cp[3],

	yo: _cp[0],

	zh: _cp[0],

	zu: function(n, ord) {
	  if (ord) return 'other';
	  return (n >= 0 && n <= 1) ? 'one' : 'other';
	}
	}));


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.MakePlural = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * make-plural.js -- https://github.com/eemeli/make-plural.js/
	 * Copyright (c) 2014-2016 by Eemeli Aro <eemeli@gmail.com>
	 *
	 * Permission to use, copy, modify, and/or distribute this software for any
	 * purpose with or without fee is hereby granted, provided that the above
	 * copyright notice and this permission notice appear in all copies.
	 *
	 * The software is provided "as is" and the author disclaims all warranties
	 * with regard to this software including all implied warranties of
	 * merchantability and fitness. In no event shall the author be liable for
	 * any special, direct, indirect, or consequential damages or any damages
	 * whatsoever resulting from loss of use, data or profits, whether in an
	 * action of contract, negligence or other tortious action, arising out of
	 * or in connection with the use or performance of this software.
	 */

	var Parser = function () {
	    function Parser() {
	        _classCallCheck(this, Parser);
	    }

	    _createClass(Parser, [{
	        key: 'parse',
	        value: function parse(cond) {
	            var _this = this;

	            if (cond === 'i = 0 or n = 1') return 'n >= 0 && n <= 1';
	            if (cond === 'i = 0,1') return 'n >= 0 && n < 2';
	            if (cond === 'i = 1 and v = 0') {
	                this.v0 = 1;
	                return 'n == 1 && v0';
	            }
	            return cond.replace(/([tv]) (!?)= 0/g, function (m, sym, noteq) {
	                var sn = sym + '0';
	                _this[sn] = 1;
	                return noteq ? '!' + sn : sn;
	            }).replace(/\b[fintv]\b/g, function (m) {
	                _this[m] = 1;
	                return m;
	            }).replace(/([fin]) % (10+)/g, function (m, sym, num) {
	                var sn = sym + num;
	                _this[sn] = 1;
	                return sn;
	            }).replace(/n10+ = 0/g, 't0 && $&').replace(/(\w+ (!?)= )([0-9.]+,[0-9.,]+)/g, function (m, se, noteq, x) {
	                if (m === 'n = 0,1') return '(n == 0 || n == 1)';
	                if (noteq) return se + x.split(',').join(' && ' + se);
	                return '(' + se + x.split(',').join(' || ' + se) + ')';
	            }).replace(/(\w+) (!?)= ([0-9]+)\.\.([0-9]+)/g, function (m, sym, noteq, x0, x1) {
	                if (Number(x0) + 1 === Number(x1)) {
	                    if (noteq) return sym + ' != ' + x0 + ' && ' + sym + ' != ' + x1;
	                    return '(' + sym + ' == ' + x0 + ' || ' + sym + ' == ' + x1 + ')';
	                }
	                if (noteq) return '(' + sym + ' < ' + x0 + ' || ' + sym + ' > ' + x1 + ')';
	                if (sym === 'n') {
	                    _this.t0 = 1;return '(t0 && n >= ' + x0 + ' && n <= ' + x1 + ')';
	                }
	                return '(' + sym + ' >= ' + x0 + ' && ' + sym + ' <= ' + x1 + ')';
	            }).replace(/ and /g, ' && ').replace(/ or /g, ' || ').replace(/ = /g, ' == ');
	        }
	    }, {
	        key: 'vars',
	        value: function vars() {
	            var vars = [];
	            if (this.i) vars.push('i = s[0]');
	            if (this.f || this.v) vars.push("f = s[1] || ''");
	            if (this.t) vars.push("t = (s[1] || '').replace(/0+$/, '')");
	            if (this.v) vars.push('v = f.length');
	            if (this.v0) vars.push('v0 = !s[1]');
	            if (this.t0 || this.n10 || this.n100) vars.push('t0 = Number(s[0]) == n');
	            for (var k in this) {
	                if (/^.10+$/.test(k)) {
	                    var k0 = k[0] === 'n' ? 't0 && s[0]' : k[0];
	                    vars.push(k + ' = ' + k0 + '.slice(-' + k.substr(2).length + ')');
	                }
	            }
	            if (!vars.length) return '';
	            return 'var ' + ["s = String(n).split('.')"].concat(vars).join(', ');
	        }
	    }]);

	    return Parser;
	}();

	var Tests = function () {
	    function Tests(obj) {
	        _classCallCheck(this, Tests);

	        this.obj = obj;
	        this.ordinal = {};
	        this.cardinal = {};
	    }

	    _createClass(Tests, [{
	        key: 'add',
	        value: function add(type, cat, examples) {
	            this[type][cat] = examples.join(' ').replace(/^[ ,]+|[ ,…]+$/g, '').replace(/(0\.[0-9])~(1\.[1-9])/g, '$1 1.0 $2').split(/[ ,~…]+/);
	        }
	    }, {
	        key: 'testCond',
	        value: function testCond(n, type, expResult, fn) {
	            try {
	                var r = (fn || this.obj.fn)(n, type === 'ordinal');
	            } catch (e) {
	                r = e.toString();
	            }
	            if (r !== expResult) {
	                throw new Error('Locale ' + JSON.stringify(this.obj.lc) + type + ' rule self-test failed for v = ' + JSON.stringify(n) + ' (was ' + JSON.stringify(r) + ', expected ' + JSON.stringify(expResult) + ')');
	            }
	            return true;
	        }
	    }, {
	        key: 'testCat',
	        value: function testCat(type, cat, fn) {
	            var _this2 = this;

	            this[type][cat].forEach(function (n) {
	                _this2.testCond(n, type, cat, fn);
	                if (!/\.0+$/.test(n)) _this2.testCond(Number(n), type, cat, fn);
	            });
	            return true;
	        }
	    }, {
	        key: 'testAll',
	        value: function testAll() {
	            for (var cat in this.cardinal) {
	                this.testCat('cardinal', cat);
	            }for (var _cat in this.ordinal) {
	                this.testCat('ordinal', _cat);
	            }return true;
	        }
	    }]);

	    return Tests;
	}();

	var MakePlural = function () {
	    function MakePlural(lc) {
	        var _ref = arguments.length <= 1 || arguments[1] === undefined ? MakePlural : arguments[1];

	        var cardinals = _ref.cardinals;
	        var ordinals = _ref.ordinals;

	        _classCallCheck(this, MakePlural);

	        if (!cardinals && !ordinals) throw new Error('At least one type of plural is required');
	        this.lc = lc;
	        this.categories = { cardinal: [], ordinal: [] };
	        this.parser = new Parser();
	        this.tests = new Tests(this);
	        this.fn = this.buildFunction(cardinals, ordinals);
	        this.fn._obj = this;
	        this.fn.categories = this.categories;
	        this.fn.test = function () {
	            return this.tests.testAll() && this.fn;
	        }.bind(this);
	        this.fn.toString = this.fnToString.bind(this);
	        return this.fn;
	    }

	    _createClass(MakePlural, [{
	        key: 'compile',
	        value: function compile(type, req) {
	            var cases = [];
	            var rules = MakePlural.rules[type][this.lc];
	            if (!rules) {
	                if (req) throw new Error('Locale "' + this.lc + '" ' + type + ' rules not found');
	                this.categories[type] = ['other'];
	                return "'other'";
	            }
	            for (var r in rules) {
	                var _rules$r$trim$split = rules[r].trim().split(/\s*@\w*/);

	                var _rules$r$trim$split2 = _toArray(_rules$r$trim$split);

	                var cond = _rules$r$trim$split2[0];
	                var examples = _rules$r$trim$split2.slice(1);
	                var cat = r.replace('pluralRule-count-', '');
	                if (cond) cases.push([this.parser.parse(cond), cat]);
	                this.tests.add(type, cat, examples);
	            }
	            this.categories[type] = cases.map(function (c) {
	                return c[1];
	            }).concat('other');
	            if (cases.length === 1) {
	                return '(' + cases[0][0] + ') ? \'' + cases[0][1] + '\' : \'other\'';
	            } else {
	                return [].concat(_toConsumableArray(cases.map(function (c) {
	                    return '(' + c[0] + ') ? \'' + c[1] + '\'';
	                })), ["'other'"]).join('\n      : ');
	            }
	        }
	    }, {
	        key: 'buildFunction',
	        value: function buildFunction(cardinals, ordinals) {
	            var _this3 = this;

	            var compile = function compile(c) {
	                return c ? (c[1] ? 'return ' : 'if (ord) return ') + _this3.compile.apply(_this3, _toConsumableArray(c)) : '';
	            },
	                fold = { vars: function vars(str) {
	                    return ('  ' + str + ';').replace(/(.{1,78})(,|$) ?/g, '$1$2\n      ');
	                },
	                cond: function cond(str) {
	                    return ('  ' + str + ';').replace(/(.{1,78}) (\|\| |$) ?/gm, '$1\n          $2');
	                } },
	                cond = [ordinals && ['ordinal', !cardinals], cardinals && ['cardinal', true]].map(compile).map(fold.cond),
	                body = [fold.vars(this.parser.vars())].concat(_toConsumableArray(cond)).filter(function (line) {
	                return !/^[\s;]*$/.test(line);
	            }).map(function (line) {
	                return line.replace(/\s+$/gm, '');
	            }).join('\n'),
	                args = ordinals && cardinals ? 'n, ord' : 'n';
	            return new Function(args, body);
	        }
	    }, {
	        key: 'fnToString',
	        value: function fnToString(name) {
	            return Function.prototype.toString.call(this.fn).replace(/^function( \w+)?/, name ? 'function ' + name : 'function').replace('\n/**/', '');
	        }
	    }], [{
	        key: 'load',
	        value: function load() {
	            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	                args[_key] = arguments[_key];
	            }

	            args.forEach(function (cldr) {
	                var data = cldr && cldr.supplemental || null;
	                if (!data) throw new Error('Data does not appear to be CLDR data');
	                MakePlural.rules = {
	                    cardinal: data['plurals-type-cardinal'] || MakePlural.rules.cardinal,
	                    ordinal: data['plurals-type-ordinal'] || MakePlural.rules.ordinal
	                };
	            });
	            return MakePlural;
	        }
	    }]);

	    return MakePlural;
	}();

	exports.default = MakePlural;


	MakePlural.cardinals = true;
	MakePlural.ordinals = false;
	MakePlural.rules = { cardinal: {}, ordinal: {} };
	module.exports = exports['default'];

	},{}]},{},[1])(1)
	});

/***/ },
/* 23 */
/***/ function(module, exports) {

	module.exports = {
		"supplemental": {
			"version": {
				"_number": "$Revision: 12002 $",
				"_unicodeVersion": "8.0.0",
				"_cldrVersion": "29"
			},
			"plurals-type-cardinal": {
				"af": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ak": {
					"pluralRule-count-one": "n = 0..1 @integer 0, 1 @decimal 0.0, 1.0, 0.00, 1.00, 0.000, 1.000, 0.0000, 1.0000",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.1~0.9, 1.1~1.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"am": {
					"pluralRule-count-one": "i = 0 or n = 1 @integer 0, 1 @decimal 0.0~1.0, 0.00~0.04",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 1.1~2.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ar": {
					"pluralRule-count-zero": "n = 0 @integer 0 @decimal 0.0, 0.00, 0.000, 0.0000",
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-two": "n = 2 @integer 2 @decimal 2.0, 2.00, 2.000, 2.0000",
					"pluralRule-count-few": "n % 100 = 3..10 @integer 3~10, 103~110, 1003, … @decimal 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 103.0, 1003.0, …",
					"pluralRule-count-many": "n % 100 = 11..99 @integer 11~26, 111, 1011, … @decimal 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 111.0, 1011.0, …",
					"pluralRule-count-other": " @integer 100~102, 200~202, 300~302, 400~402, 500~502, 600, 1000, 10000, 100000, 1000000, … @decimal 0.1~0.9, 1.1~1.7, 10.1, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"as": {
					"pluralRule-count-one": "i = 0 or n = 1 @integer 0, 1 @decimal 0.0~1.0, 0.00~0.04",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 1.1~2.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"asa": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ast": {
					"pluralRule-count-one": "i = 1 and v = 0 @integer 1",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"az": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"be": {
					"pluralRule-count-one": "n % 10 = 1 and n % 100 != 11 @integer 1, 21, 31, 41, 51, 61, 71, 81, 101, 1001, … @decimal 1.0, 21.0, 31.0, 41.0, 51.0, 61.0, 71.0, 81.0, 101.0, 1001.0, …",
					"pluralRule-count-few": "n % 10 = 2..4 and n % 100 != 12..14 @integer 2~4, 22~24, 32~34, 42~44, 52~54, 62, 102, 1002, … @decimal 2.0, 3.0, 4.0, 22.0, 23.0, 24.0, 32.0, 33.0, 102.0, 1002.0, …",
					"pluralRule-count-many": "n % 10 = 0 or n % 10 = 5..9 or n % 100 = 11..14 @integer 0, 5~19, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …",
					"pluralRule-count-other": "   @decimal 0.1~0.9, 1.1~1.7, 10.1, 100.1, 1000.1, …"
				},
				"bem": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"bez": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"bg": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"bh": {
					"pluralRule-count-one": "n = 0..1 @integer 0, 1 @decimal 0.0, 1.0, 0.00, 1.00, 0.000, 1.000, 0.0000, 1.0000",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.1~0.9, 1.1~1.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"bm": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"bn": {
					"pluralRule-count-one": "i = 0 or n = 1 @integer 0, 1 @decimal 0.0~1.0, 0.00~0.04",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 1.1~2.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"bo": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"br": {
					"pluralRule-count-one": "n % 10 = 1 and n % 100 != 11,71,91 @integer 1, 21, 31, 41, 51, 61, 81, 101, 1001, … @decimal 1.0, 21.0, 31.0, 41.0, 51.0, 61.0, 81.0, 101.0, 1001.0, …",
					"pluralRule-count-two": "n % 10 = 2 and n % 100 != 12,72,92 @integer 2, 22, 32, 42, 52, 62, 82, 102, 1002, … @decimal 2.0, 22.0, 32.0, 42.0, 52.0, 62.0, 82.0, 102.0, 1002.0, …",
					"pluralRule-count-few": "n % 10 = 3..4,9 and n % 100 != 10..19,70..79,90..99 @integer 3, 4, 9, 23, 24, 29, 33, 34, 39, 43, 44, 49, 103, 1003, … @decimal 3.0, 4.0, 9.0, 23.0, 24.0, 29.0, 33.0, 34.0, 103.0, 1003.0, …",
					"pluralRule-count-many": "n != 0 and n % 1000000 = 0 @integer 1000000, … @decimal 1000000.0, 1000000.00, 1000000.000, …",
					"pluralRule-count-other": " @integer 0, 5~8, 10~20, 100, 1000, 10000, 100000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, …"
				},
				"brx": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"bs": {
					"pluralRule-count-one": "v = 0 and i % 10 = 1 and i % 100 != 11 or f % 10 = 1 and f % 100 != 11 @integer 1, 21, 31, 41, 51, 61, 71, 81, 101, 1001, … @decimal 0.1, 1.1, 2.1, 3.1, 4.1, 5.1, 6.1, 7.1, 10.1, 100.1, 1000.1, …",
					"pluralRule-count-few": "v = 0 and i % 10 = 2..4 and i % 100 != 12..14 or f % 10 = 2..4 and f % 100 != 12..14 @integer 2~4, 22~24, 32~34, 42~44, 52~54, 62, 102, 1002, … @decimal 0.2~0.4, 1.2~1.4, 2.2~2.4, 3.2~3.4, 4.2~4.4, 5.2, 10.2, 100.2, 1000.2, …",
					"pluralRule-count-other": " @integer 0, 5~19, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0, 0.5~1.0, 1.5~2.0, 2.5~2.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ca": {
					"pluralRule-count-one": "i = 1 and v = 0 @integer 1",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ce": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"cgg": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"chr": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ckb": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"cs": {
					"pluralRule-count-one": "i = 1 and v = 0 @integer 1",
					"pluralRule-count-few": "i = 2..4 and v = 0 @integer 2~4",
					"pluralRule-count-many": "v != 0   @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …",
					"pluralRule-count-other": " @integer 0, 5~19, 100, 1000, 10000, 100000, 1000000, …"
				},
				"cy": {
					"pluralRule-count-zero": "n = 0 @integer 0 @decimal 0.0, 0.00, 0.000, 0.0000",
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-two": "n = 2 @integer 2 @decimal 2.0, 2.00, 2.000, 2.0000",
					"pluralRule-count-few": "n = 3 @integer 3 @decimal 3.0, 3.00, 3.000, 3.0000",
					"pluralRule-count-many": "n = 6 @integer 6 @decimal 6.0, 6.00, 6.000, 6.0000",
					"pluralRule-count-other": " @integer 4, 5, 7~20, 100, 1000, 10000, 100000, 1000000, … @decimal 0.1~0.9, 1.1~1.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"da": {
					"pluralRule-count-one": "n = 1 or t != 0 and i = 0,1 @integer 1 @decimal 0.1~1.6",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0, 2.0~3.4, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"de": {
					"pluralRule-count-one": "i = 1 and v = 0 @integer 1",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"dsb": {
					"pluralRule-count-one": "v = 0 and i % 100 = 1 or f % 100 = 1 @integer 1, 101, 201, 301, 401, 501, 601, 701, 1001, … @decimal 0.1, 1.1, 2.1, 3.1, 4.1, 5.1, 6.1, 7.1, 10.1, 100.1, 1000.1, …",
					"pluralRule-count-two": "v = 0 and i % 100 = 2 or f % 100 = 2 @integer 2, 102, 202, 302, 402, 502, 602, 702, 1002, … @decimal 0.2, 1.2, 2.2, 3.2, 4.2, 5.2, 6.2, 7.2, 10.2, 100.2, 1000.2, …",
					"pluralRule-count-few": "v = 0 and i % 100 = 3..4 or f % 100 = 3..4 @integer 3, 4, 103, 104, 203, 204, 303, 304, 403, 404, 503, 504, 603, 604, 703, 704, 1003, … @decimal 0.3, 0.4, 1.3, 1.4, 2.3, 2.4, 3.3, 3.4, 4.3, 4.4, 5.3, 5.4, 6.3, 6.4, 7.3, 7.4, 10.3, 100.3, 1000.3, …",
					"pluralRule-count-other": " @integer 0, 5~19, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0, 0.5~1.0, 1.5~2.0, 2.5~2.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"dv": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"dz": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ee": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"el": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"en": {
					"pluralRule-count-one": "i = 1 and v = 0 @integer 1",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"eo": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"es": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"et": {
					"pluralRule-count-one": "i = 1 and v = 0 @integer 1",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"eu": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"fa": {
					"pluralRule-count-one": "i = 0 or n = 1 @integer 0, 1 @decimal 0.0~1.0, 0.00~0.04",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 1.1~2.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ff": {
					"pluralRule-count-one": "i = 0,1 @integer 0, 1 @decimal 0.0~1.5",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 2.0~3.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"fi": {
					"pluralRule-count-one": "i = 1 and v = 0 @integer 1",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"fil": {
					"pluralRule-count-one": "v = 0 and i = 1,2,3 or v = 0 and i % 10 != 4,6,9 or v != 0 and f % 10 != 4,6,9 @integer 0~3, 5, 7, 8, 10~13, 15, 17, 18, 20, 21, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.3, 0.5, 0.7, 0.8, 1.0~1.3, 1.5, 1.7, 1.8, 2.0, 2.1, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …",
					"pluralRule-count-other": " @integer 4, 6, 9, 14, 16, 19, 24, 26, 104, 1004, … @decimal 0.4, 0.6, 0.9, 1.4, 1.6, 1.9, 2.4, 2.6, 10.4, 100.4, 1000.4, …"
				},
				"fo": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"fr": {
					"pluralRule-count-one": "i = 0,1 @integer 0, 1 @decimal 0.0~1.5",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 2.0~3.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"fur": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"fy": {
					"pluralRule-count-one": "i = 1 and v = 0 @integer 1",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ga": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-two": "n = 2 @integer 2 @decimal 2.0, 2.00, 2.000, 2.0000",
					"pluralRule-count-few": "n = 3..6 @integer 3~6 @decimal 3.0, 4.0, 5.0, 6.0, 3.00, 4.00, 5.00, 6.00, 3.000, 4.000, 5.000, 6.000, 3.0000, 4.0000, 5.0000, 6.0000",
					"pluralRule-count-many": "n = 7..10 @integer 7~10 @decimal 7.0, 8.0, 9.0, 10.0, 7.00, 8.00, 9.00, 10.00, 7.000, 8.000, 9.000, 10.000, 7.0000, 8.0000, 9.0000, 10.0000",
					"pluralRule-count-other": " @integer 0, 11~25, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.1, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"gd": {
					"pluralRule-count-one": "n = 1,11 @integer 1, 11 @decimal 1.0, 11.0, 1.00, 11.00, 1.000, 11.000, 1.0000",
					"pluralRule-count-two": "n = 2,12 @integer 2, 12 @decimal 2.0, 12.0, 2.00, 12.00, 2.000, 12.000, 2.0000",
					"pluralRule-count-few": "n = 3..10,13..19 @integer 3~10, 13~19 @decimal 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 3.00",
					"pluralRule-count-other": " @integer 0, 20~34, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.1, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"gl": {
					"pluralRule-count-one": "i = 1 and v = 0 @integer 1",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"gsw": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"gu": {
					"pluralRule-count-one": "i = 0 or n = 1 @integer 0, 1 @decimal 0.0~1.0, 0.00~0.04",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 1.1~2.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"guw": {
					"pluralRule-count-one": "n = 0..1 @integer 0, 1 @decimal 0.0, 1.0, 0.00, 1.00, 0.000, 1.000, 0.0000, 1.0000",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.1~0.9, 1.1~1.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"gv": {
					"pluralRule-count-one": "v = 0 and i % 10 = 1 @integer 1, 11, 21, 31, 41, 51, 61, 71, 101, 1001, …",
					"pluralRule-count-two": "v = 0 and i % 10 = 2 @integer 2, 12, 22, 32, 42, 52, 62, 72, 102, 1002, …",
					"pluralRule-count-few": "v = 0 and i % 100 = 0,20,40,60,80 @integer 0, 20, 40, 60, 80, 100, 120, 140, 1000, 10000, 100000, 1000000, …",
					"pluralRule-count-many": "v != 0   @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …",
					"pluralRule-count-other": " @integer 3~10, 13~19, 23, 103, 1003, …"
				},
				"ha": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"haw": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"he": {
					"pluralRule-count-one": "i = 1 and v = 0 @integer 1",
					"pluralRule-count-two": "i = 2 and v = 0 @integer 2",
					"pluralRule-count-many": "v = 0 and n != 0..10 and n % 10 = 0 @integer 20, 30, 40, 50, 60, 70, 80, 90, 100, 1000, 10000, 100000, 1000000, …",
					"pluralRule-count-other": " @integer 0, 3~17, 101, 1001, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"hi": {
					"pluralRule-count-one": "i = 0 or n = 1 @integer 0, 1 @decimal 0.0~1.0, 0.00~0.04",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 1.1~2.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"hr": {
					"pluralRule-count-one": "v = 0 and i % 10 = 1 and i % 100 != 11 or f % 10 = 1 and f % 100 != 11 @integer 1, 21, 31, 41, 51, 61, 71, 81, 101, 1001, … @decimal 0.1, 1.1, 2.1, 3.1, 4.1, 5.1, 6.1, 7.1, 10.1, 100.1, 1000.1, …",
					"pluralRule-count-few": "v = 0 and i % 10 = 2..4 and i % 100 != 12..14 or f % 10 = 2..4 and f % 100 != 12..14 @integer 2~4, 22~24, 32~34, 42~44, 52~54, 62, 102, 1002, … @decimal 0.2~0.4, 1.2~1.4, 2.2~2.4, 3.2~3.4, 4.2~4.4, 5.2, 10.2, 100.2, 1000.2, …",
					"pluralRule-count-other": " @integer 0, 5~19, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0, 0.5~1.0, 1.5~2.0, 2.5~2.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"hsb": {
					"pluralRule-count-one": "v = 0 and i % 100 = 1 or f % 100 = 1 @integer 1, 101, 201, 301, 401, 501, 601, 701, 1001, … @decimal 0.1, 1.1, 2.1, 3.1, 4.1, 5.1, 6.1, 7.1, 10.1, 100.1, 1000.1, …",
					"pluralRule-count-two": "v = 0 and i % 100 = 2 or f % 100 = 2 @integer 2, 102, 202, 302, 402, 502, 602, 702, 1002, … @decimal 0.2, 1.2, 2.2, 3.2, 4.2, 5.2, 6.2, 7.2, 10.2, 100.2, 1000.2, …",
					"pluralRule-count-few": "v = 0 and i % 100 = 3..4 or f % 100 = 3..4 @integer 3, 4, 103, 104, 203, 204, 303, 304, 403, 404, 503, 504, 603, 604, 703, 704, 1003, … @decimal 0.3, 0.4, 1.3, 1.4, 2.3, 2.4, 3.3, 3.4, 4.3, 4.4, 5.3, 5.4, 6.3, 6.4, 7.3, 7.4, 10.3, 100.3, 1000.3, …",
					"pluralRule-count-other": " @integer 0, 5~19, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0, 0.5~1.0, 1.5~2.0, 2.5~2.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"hu": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"hy": {
					"pluralRule-count-one": "i = 0,1 @integer 0, 1 @decimal 0.0~1.5",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 2.0~3.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"id": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ig": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ii": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"in": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"is": {
					"pluralRule-count-one": "t = 0 and i % 10 = 1 and i % 100 != 11 or t != 0 @integer 1, 21, 31, 41, 51, 61, 71, 81, 101, 1001, … @decimal 0.1~1.6, 10.1, 100.1, 1000.1, …",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"it": {
					"pluralRule-count-one": "i = 1 and v = 0 @integer 1",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"iu": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-two": "n = 2 @integer 2 @decimal 2.0, 2.00, 2.000, 2.0000",
					"pluralRule-count-other": " @integer 0, 3~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"iw": {
					"pluralRule-count-one": "i = 1 and v = 0 @integer 1",
					"pluralRule-count-two": "i = 2 and v = 0 @integer 2",
					"pluralRule-count-many": "v = 0 and n != 0..10 and n % 10 = 0 @integer 20, 30, 40, 50, 60, 70, 80, 90, 100, 1000, 10000, 100000, 1000000, …",
					"pluralRule-count-other": " @integer 0, 3~17, 101, 1001, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ja": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"jbo": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"jgo": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ji": {
					"pluralRule-count-one": "i = 1 and v = 0 @integer 1",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"jmc": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"jv": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"jw": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ka": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"kab": {
					"pluralRule-count-one": "i = 0,1 @integer 0, 1 @decimal 0.0~1.5",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 2.0~3.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"kaj": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"kcg": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"kde": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"kea": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"kk": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"kkj": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"kl": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"km": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"kn": {
					"pluralRule-count-one": "i = 0 or n = 1 @integer 0, 1 @decimal 0.0~1.0, 0.00~0.04",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 1.1~2.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ko": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ks": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ksb": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ksh": {
					"pluralRule-count-zero": "n = 0 @integer 0 @decimal 0.0, 0.00, 0.000, 0.0000",
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.1~0.9, 1.1~1.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ku": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"kw": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-two": "n = 2 @integer 2 @decimal 2.0, 2.00, 2.000, 2.0000",
					"pluralRule-count-other": " @integer 0, 3~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ky": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"lag": {
					"pluralRule-count-zero": "n = 0 @integer 0 @decimal 0.0, 0.00, 0.000, 0.0000",
					"pluralRule-count-one": "i = 0,1 and n != 0 @integer 1 @decimal 0.1~1.6",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 2.0~3.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"lb": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"lg": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"lkt": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ln": {
					"pluralRule-count-one": "n = 0..1 @integer 0, 1 @decimal 0.0, 1.0, 0.00, 1.00, 0.000, 1.000, 0.0000, 1.0000",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.1~0.9, 1.1~1.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"lo": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"lt": {
					"pluralRule-count-one": "n % 10 = 1 and n % 100 != 11..19 @integer 1, 21, 31, 41, 51, 61, 71, 81, 101, 1001, … @decimal 1.0, 21.0, 31.0, 41.0, 51.0, 61.0, 71.0, 81.0, 101.0, 1001.0, …",
					"pluralRule-count-few": "n % 10 = 2..9 and n % 100 != 11..19 @integer 2~9, 22~29, 102, 1002, … @decimal 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 22.0, 102.0, 1002.0, …",
					"pluralRule-count-many": "f != 0   @decimal 0.1~0.9, 1.1~1.7, 10.1, 100.1, 1000.1, …",
					"pluralRule-count-other": " @integer 0, 10~20, 30, 40, 50, 60, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"lv": {
					"pluralRule-count-zero": "n % 10 = 0 or n % 100 = 11..19 or v = 2 and f % 100 = 11..19 @integer 0, 10~20, 30, 40, 50, 60, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …",
					"pluralRule-count-one": "n % 10 = 1 and n % 100 != 11 or v = 2 and f % 10 = 1 and f % 100 != 11 or v != 2 and f % 10 = 1 @integer 1, 21, 31, 41, 51, 61, 71, 81, 101, 1001, … @decimal 0.1, 1.0, 1.1, 2.1, 3.1, 4.1, 5.1, 6.1, 7.1, 10.1, 100.1, 1000.1, …",
					"pluralRule-count-other": " @integer 2~9, 22~29, 102, 1002, … @decimal 0.2~0.9, 1.2~1.9, 10.2, 100.2, 1000.2, …"
				},
				"mas": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"mg": {
					"pluralRule-count-one": "n = 0..1 @integer 0, 1 @decimal 0.0, 1.0, 0.00, 1.00, 0.000, 1.000, 0.0000, 1.0000",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.1~0.9, 1.1~1.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"mgo": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"mk": {
					"pluralRule-count-one": "v = 0 and i % 10 = 1 or f % 10 = 1 @integer 1, 11, 21, 31, 41, 51, 61, 71, 101, 1001, … @decimal 0.1, 1.1, 2.1, 3.1, 4.1, 5.1, 6.1, 7.1, 10.1, 100.1, 1000.1, …",
					"pluralRule-count-other": " @integer 0, 2~10, 12~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0, 0.2~1.0, 1.2~1.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ml": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"mn": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"mo": {
					"pluralRule-count-one": "i = 1 and v = 0 @integer 1",
					"pluralRule-count-few": "v != 0 or n = 0 or n != 1 and n % 100 = 1..19 @integer 0, 2~16, 101, 1001, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …",
					"pluralRule-count-other": " @integer 20~35, 100, 1000, 10000, 100000, 1000000, …"
				},
				"mr": {
					"pluralRule-count-one": "i = 0 or n = 1 @integer 0, 1 @decimal 0.0~1.0, 0.00~0.04",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 1.1~2.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ms": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"mt": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-few": "n = 0 or n % 100 = 2..10 @integer 0, 2~10, 102~107, 1002, … @decimal 0.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 10.0, 102.0, 1002.0, …",
					"pluralRule-count-many": "n % 100 = 11..19 @integer 11~19, 111~117, 1011, … @decimal 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 111.0, 1011.0, …",
					"pluralRule-count-other": " @integer 20~35, 100, 1000, 10000, 100000, 1000000, … @decimal 0.1~0.9, 1.1~1.7, 10.1, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"my": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"nah": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"naq": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-two": "n = 2 @integer 2 @decimal 2.0, 2.00, 2.000, 2.0000",
					"pluralRule-count-other": " @integer 0, 3~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"nb": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"nd": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ne": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"nl": {
					"pluralRule-count-one": "i = 1 and v = 0 @integer 1",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"nn": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"nnh": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"no": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"nqo": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"nr": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"nso": {
					"pluralRule-count-one": "n = 0..1 @integer 0, 1 @decimal 0.0, 1.0, 0.00, 1.00, 0.000, 1.000, 0.0000, 1.0000",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.1~0.9, 1.1~1.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ny": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"nyn": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"om": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"or": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"os": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"pa": {
					"pluralRule-count-one": "n = 0..1 @integer 0, 1 @decimal 0.0, 1.0, 0.00, 1.00, 0.000, 1.000, 0.0000, 1.0000",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.1~0.9, 1.1~1.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"pap": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"pl": {
					"pluralRule-count-one": "i = 1 and v = 0 @integer 1",
					"pluralRule-count-few": "v = 0 and i % 10 = 2..4 and i % 100 != 12..14 @integer 2~4, 22~24, 32~34, 42~44, 52~54, 62, 102, 1002, …",
					"pluralRule-count-many": "v = 0 and i != 1 and i % 10 = 0..1 or v = 0 and i % 10 = 5..9 or v = 0 and i % 100 = 12..14 @integer 0, 5~19, 100, 1000, 10000, 100000, 1000000, …",
					"pluralRule-count-other": "   @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"prg": {
					"pluralRule-count-zero": "n % 10 = 0 or n % 100 = 11..19 or v = 2 and f % 100 = 11..19 @integer 0, 10~20, 30, 40, 50, 60, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …",
					"pluralRule-count-one": "n % 10 = 1 and n % 100 != 11 or v = 2 and f % 10 = 1 and f % 100 != 11 or v != 2 and f % 10 = 1 @integer 1, 21, 31, 41, 51, 61, 71, 81, 101, 1001, … @decimal 0.1, 1.0, 1.1, 2.1, 3.1, 4.1, 5.1, 6.1, 7.1, 10.1, 100.1, 1000.1, …",
					"pluralRule-count-other": " @integer 2~9, 22~29, 102, 1002, … @decimal 0.2~0.9, 1.2~1.9, 10.2, 100.2, 1000.2, …"
				},
				"ps": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"pt": {
					"pluralRule-count-one": "n = 0..2 and n != 2 @integer 0, 1 @decimal 0.0, 1.0, 0.00, 1.00, 0.000, 1.000, 0.0000, 1.0000",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.1~0.9, 1.1~1.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"pt-PT": {
					"pluralRule-count-one": "n = 1 and v = 0 @integer 1",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"rm": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ro": {
					"pluralRule-count-one": "i = 1 and v = 0 @integer 1",
					"pluralRule-count-few": "v != 0 or n = 0 or n != 1 and n % 100 = 1..19 @integer 0, 2~16, 101, 1001, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …",
					"pluralRule-count-other": " @integer 20~35, 100, 1000, 10000, 100000, 1000000, …"
				},
				"rof": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"root": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ru": {
					"pluralRule-count-one": "v = 0 and i % 10 = 1 and i % 100 != 11 @integer 1, 21, 31, 41, 51, 61, 71, 81, 101, 1001, …",
					"pluralRule-count-few": "v = 0 and i % 10 = 2..4 and i % 100 != 12..14 @integer 2~4, 22~24, 32~34, 42~44, 52~54, 62, 102, 1002, …",
					"pluralRule-count-many": "v = 0 and i % 10 = 0 or v = 0 and i % 10 = 5..9 or v = 0 and i % 100 = 11..14 @integer 0, 5~19, 100, 1000, 10000, 100000, 1000000, …",
					"pluralRule-count-other": "   @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"rwk": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"sah": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"saq": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"sdh": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"se": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-two": "n = 2 @integer 2 @decimal 2.0, 2.00, 2.000, 2.0000",
					"pluralRule-count-other": " @integer 0, 3~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"seh": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ses": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"sg": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"sh": {
					"pluralRule-count-one": "v = 0 and i % 10 = 1 and i % 100 != 11 or f % 10 = 1 and f % 100 != 11 @integer 1, 21, 31, 41, 51, 61, 71, 81, 101, 1001, … @decimal 0.1, 1.1, 2.1, 3.1, 4.1, 5.1, 6.1, 7.1, 10.1, 100.1, 1000.1, …",
					"pluralRule-count-few": "v = 0 and i % 10 = 2..4 and i % 100 != 12..14 or f % 10 = 2..4 and f % 100 != 12..14 @integer 2~4, 22~24, 32~34, 42~44, 52~54, 62, 102, 1002, … @decimal 0.2~0.4, 1.2~1.4, 2.2~2.4, 3.2~3.4, 4.2~4.4, 5.2, 10.2, 100.2, 1000.2, …",
					"pluralRule-count-other": " @integer 0, 5~19, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0, 0.5~1.0, 1.5~2.0, 2.5~2.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"shi": {
					"pluralRule-count-one": "i = 0 or n = 1 @integer 0, 1 @decimal 0.0~1.0, 0.00~0.04",
					"pluralRule-count-few": "n = 2..10 @integer 2~10 @decimal 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 2.00, 3.00, 4.00, 5.00, 6.00, 7.00, 8.00",
					"pluralRule-count-other": " @integer 11~26, 100, 1000, 10000, 100000, 1000000, … @decimal 1.1~1.9, 2.1~2.7, 10.1, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"si": {
					"pluralRule-count-one": "n = 0,1 or i = 0 and f = 1 @integer 0, 1 @decimal 0.0, 0.1, 1.0, 0.00, 0.01, 1.00, 0.000, 0.001, 1.000, 0.0000, 0.0001, 1.0000",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.2~0.9, 1.1~1.8, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"sk": {
					"pluralRule-count-one": "i = 1 and v = 0 @integer 1",
					"pluralRule-count-few": "i = 2..4 and v = 0 @integer 2~4",
					"pluralRule-count-many": "v != 0   @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …",
					"pluralRule-count-other": " @integer 0, 5~19, 100, 1000, 10000, 100000, 1000000, …"
				},
				"sl": {
					"pluralRule-count-one": "v = 0 and i % 100 = 1 @integer 1, 101, 201, 301, 401, 501, 601, 701, 1001, …",
					"pluralRule-count-two": "v = 0 and i % 100 = 2 @integer 2, 102, 202, 302, 402, 502, 602, 702, 1002, …",
					"pluralRule-count-few": "v = 0 and i % 100 = 3..4 or v != 0 @integer 3, 4, 103, 104, 203, 204, 303, 304, 403, 404, 503, 504, 603, 604, 703, 704, 1003, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …",
					"pluralRule-count-other": " @integer 0, 5~19, 100, 1000, 10000, 100000, 1000000, …"
				},
				"sma": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-two": "n = 2 @integer 2 @decimal 2.0, 2.00, 2.000, 2.0000",
					"pluralRule-count-other": " @integer 0, 3~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"smi": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-two": "n = 2 @integer 2 @decimal 2.0, 2.00, 2.000, 2.0000",
					"pluralRule-count-other": " @integer 0, 3~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"smj": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-two": "n = 2 @integer 2 @decimal 2.0, 2.00, 2.000, 2.0000",
					"pluralRule-count-other": " @integer 0, 3~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"smn": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-two": "n = 2 @integer 2 @decimal 2.0, 2.00, 2.000, 2.0000",
					"pluralRule-count-other": " @integer 0, 3~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"sms": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-two": "n = 2 @integer 2 @decimal 2.0, 2.00, 2.000, 2.0000",
					"pluralRule-count-other": " @integer 0, 3~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"sn": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"so": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"sq": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"sr": {
					"pluralRule-count-one": "v = 0 and i % 10 = 1 and i % 100 != 11 or f % 10 = 1 and f % 100 != 11 @integer 1, 21, 31, 41, 51, 61, 71, 81, 101, 1001, … @decimal 0.1, 1.1, 2.1, 3.1, 4.1, 5.1, 6.1, 7.1, 10.1, 100.1, 1000.1, …",
					"pluralRule-count-few": "v = 0 and i % 10 = 2..4 and i % 100 != 12..14 or f % 10 = 2..4 and f % 100 != 12..14 @integer 2~4, 22~24, 32~34, 42~44, 52~54, 62, 102, 1002, … @decimal 0.2~0.4, 1.2~1.4, 2.2~2.4, 3.2~3.4, 4.2~4.4, 5.2, 10.2, 100.2, 1000.2, …",
					"pluralRule-count-other": " @integer 0, 5~19, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0, 0.5~1.0, 1.5~2.0, 2.5~2.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ss": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ssy": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"st": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"sv": {
					"pluralRule-count-one": "i = 1 and v = 0 @integer 1",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"sw": {
					"pluralRule-count-one": "i = 1 and v = 0 @integer 1",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"syr": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ta": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"te": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"teo": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"th": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ti": {
					"pluralRule-count-one": "n = 0..1 @integer 0, 1 @decimal 0.0, 1.0, 0.00, 1.00, 0.000, 1.000, 0.0000, 1.0000",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.1~0.9, 1.1~1.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"tig": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"tk": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"tl": {
					"pluralRule-count-one": "v = 0 and i = 1,2,3 or v = 0 and i % 10 != 4,6,9 or v != 0 and f % 10 != 4,6,9 @integer 0~3, 5, 7, 8, 10~13, 15, 17, 18, 20, 21, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.3, 0.5, 0.7, 0.8, 1.0~1.3, 1.5, 1.7, 1.8, 2.0, 2.1, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …",
					"pluralRule-count-other": " @integer 4, 6, 9, 14, 16, 19, 24, 26, 104, 1004, … @decimal 0.4, 0.6, 0.9, 1.4, 1.6, 1.9, 2.4, 2.6, 10.4, 100.4, 1000.4, …"
				},
				"tn": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"to": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"tr": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ts": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"tzm": {
					"pluralRule-count-one": "n = 0..1 or n = 11..99 @integer 0, 1, 11~24 @decimal 0.0, 1.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0",
					"pluralRule-count-other": " @integer 2~10, 100~106, 1000, 10000, 100000, 1000000, … @decimal 0.1~0.9, 1.1~1.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ug": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"uk": {
					"pluralRule-count-one": "v = 0 and i % 10 = 1 and i % 100 != 11 @integer 1, 21, 31, 41, 51, 61, 71, 81, 101, 1001, …",
					"pluralRule-count-few": "v = 0 and i % 10 = 2..4 and i % 100 != 12..14 @integer 2~4, 22~24, 32~34, 42~44, 52~54, 62, 102, 1002, …",
					"pluralRule-count-many": "v = 0 and i % 10 = 0 or v = 0 and i % 10 = 5..9 or v = 0 and i % 100 = 11..14 @integer 0, 5~19, 100, 1000, 10000, 100000, 1000000, …",
					"pluralRule-count-other": "   @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ur": {
					"pluralRule-count-one": "i = 1 and v = 0 @integer 1",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"uz": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"ve": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"vi": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"vo": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"vun": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"wa": {
					"pluralRule-count-one": "n = 0..1 @integer 0, 1 @decimal 0.0, 1.0, 0.00, 1.00, 0.000, 1.000, 0.0000, 1.0000",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.1~0.9, 1.1~1.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"wae": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"wo": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"xh": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"xog": {
					"pluralRule-count-one": "n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"yi": {
					"pluralRule-count-one": "i = 1 and v = 0 @integer 1",
					"pluralRule-count-other": " @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"yo": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"zh": {
					"pluralRule-count-other": " @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				},
				"zu": {
					"pluralRule-count-one": "i = 0 or n = 1 @integer 0, 1 @decimal 0.0~1.0, 0.00~0.04",
					"pluralRule-count-other": " @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 1.1~2.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …"
				}
			}
		}
	};

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../typings/tsd.d.ts" />
	'use strict';
	var xregexp_1 = __webpack_require__(25);
	var value = '[-+]?(?:Infinity|[[0-9]*\\.?\\d*(?:[eE][-+]?\\d+)?)';
	var mathInterval = xregexp_1.XRegExp("(?<leftBrace>  [\\(\\]\\[] )                                (?<fromValue>  " + value + "    )?                               (?<delimeter>  ,           )?                               (?<toValue>    " + value + "    )?                               (?<rightBrace> [\\)\\]\\[] )", 'x');
	function parse(str) {
	    var match = xregexp_1.XRegExp.exec(str, mathInterval);
	    if (!match) {
	        return null;
	    }
	    return {
	        from: {
	            value: match.fromValue !== undefined ?
	                +match.fromValue :
	                -Infinity,
	            included: match.leftBrace === '['
	        },
	        to: {
	            value: match.toValue !== undefined ?
	                +match.toValue :
	                (match.delimeter ?
	                    +Infinity :
	                    +match.fromValue),
	            included: match.rightBrace === ']'
	        }
	    };
	}
	function check(interval) {
	    if (!interval) {
	        return false;
	    }
	    if (interval.from.value === interval.to.value) {
	        return interval.from.included && interval.to.included;
	    }
	    return Math.min(interval.from.value, interval.to.value) === interval.from.value;
	}
	function entry(str) {
	    var interval = parse(str);
	    if (!check(interval)) {
	        return null;
	    }
	    return interval;
	}
	exports.default = entry;
	;


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	
	/***** xregexp.js *****/

	/*!
	 * XRegExp v2.0.0
	 * (c) 2007-2012 Steven Levithan <http://xregexp.com/>
	 * MIT License
	 */

	/**
	 * XRegExp provides augmented, extensible JavaScript regular expressions. You get new syntax,
	 * flags, and methods beyond what browsers support natively. XRegExp is also a regex utility belt
	 * with tools to make your client-side grepping simpler and more powerful, while freeing you from
	 * worrying about pesky cross-browser inconsistencies and the dubious `lastIndex` property. See
	 * XRegExp's documentation (http://xregexp.com/) for more details.
	 * @module xregexp
	 * @requires N/A
	 */
	var XRegExp;

	// Avoid running twice; that would reset tokens and could break references to native globals
	XRegExp = XRegExp || (function (undef) {
	    "use strict";

	/*--------------------------------------
	 *  Private variables
	 *------------------------------------*/

	    var self,
	        addToken,
	        add,

	// Optional features; can be installed and uninstalled
	        features = {
	            natives: false,
	            extensibility: false
	        },

	// Store native methods to use and restore ("native" is an ES3 reserved keyword)
	        nativ = {
	            exec: RegExp.prototype.exec,
	            test: RegExp.prototype.test,
	            match: String.prototype.match,
	            replace: String.prototype.replace,
	            split: String.prototype.split
	        },

	// Storage for fixed/extended native methods
	        fixed = {},

	// Storage for cached regexes
	        cache = {},

	// Storage for addon tokens
	        tokens = [],

	// Token scopes
	        defaultScope = "default",
	        classScope = "class",

	// Regexes that match native regex syntax
	        nativeTokens = {
	            // Any native multicharacter token in default scope (includes octals, excludes character classes)
	            "default": /^(?:\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??)/,
	            // Any native multicharacter token in character class scope (includes octals)
	            "class": /^(?:\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S]))/
	        },

	// Any backreference in replacement strings
	        replacementToken = /\$(?:{([\w$]+)}|(\d\d?|[\s\S]))/g,

	// Any character with a later instance in the string
	        duplicateFlags = /([\s\S])(?=[\s\S]*\1)/g,

	// Any greedy/lazy quantifier
	        quantifier = /^(?:[?*+]|{\d+(?:,\d*)?})\??/,

	// Check for correct `exec` handling of nonparticipating capturing groups
	        compliantExecNpcg = nativ.exec.call(/()??/, "")[1] === undef,

	// Check for flag y support (Firefox 3+)
	        hasNativeY = RegExp.prototype.sticky !== undef,

	// Used to kill infinite recursion during XRegExp construction
	        isInsideConstructor = false,

	// Storage for known flags, including addon flags
	        registeredFlags = "gim" + (hasNativeY ? "y" : "");

	/*--------------------------------------
	 *  Private helper functions
	 *------------------------------------*/

	/**
	 * Attaches XRegExp.prototype properties and named capture supporting data to a regex object.
	 * @private
	 * @param {RegExp} regex Regex to augment.
	 * @param {Array} captureNames Array with capture names, or null.
	 * @param {Boolean} [isNative] Whether the regex was created by `RegExp` rather than `XRegExp`.
	 * @returns {RegExp} Augmented regex.
	 */
	    function augment(regex, captureNames, isNative) {
	        var p;
	        // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value
	        for (p in self.prototype) {
	            if (self.prototype.hasOwnProperty(p)) {
	                regex[p] = self.prototype[p];
	            }
	        }
	        regex.xregexp = {captureNames: captureNames, isNative: !!isNative};
	        return regex;
	    }

	/**
	 * Returns native `RegExp` flags used by a regex object.
	 * @private
	 * @param {RegExp} regex Regex to check.
	 * @returns {String} Native flags in use.
	 */
	    function getNativeFlags(regex) {
	        //return nativ.exec.call(/\/([a-z]*)$/i, String(regex))[1];
	        return (regex.global     ? "g" : "") +
	               (regex.ignoreCase ? "i" : "") +
	               (regex.multiline  ? "m" : "") +
	               (regex.extended   ? "x" : "") + // Proposed for ES6, included in AS3
	               (regex.sticky     ? "y" : ""); // Proposed for ES6, included in Firefox 3+
	    }

	/**
	 * Copies a regex object while preserving special properties for named capture and augmenting with
	 * `XRegExp.prototype` methods. The copy has a fresh `lastIndex` property (set to zero). Allows
	 * adding and removing flags while copying the regex.
	 * @private
	 * @param {RegExp} regex Regex to copy.
	 * @param {String} [addFlags] Flags to be added while copying the regex.
	 * @param {String} [removeFlags] Flags to be removed while copying the regex.
	 * @returns {RegExp} Copy of the provided regex, possibly with modified flags.
	 */
	    function copy(regex, addFlags, removeFlags) {
	        if (!self.isRegExp(regex)) {
	            throw new TypeError("type RegExp expected");
	        }
	        var flags = nativ.replace.call(getNativeFlags(regex) + (addFlags || ""), duplicateFlags, "");
	        if (removeFlags) {
	            // Would need to escape `removeFlags` if this was public
	            flags = nativ.replace.call(flags, new RegExp("[" + removeFlags + "]+", "g"), "");
	        }
	        if (regex.xregexp && !regex.xregexp.isNative) {
	            // Compiling the current (rather than precompilation) source preserves the effects of nonnative source flags
	            regex = augment(self(regex.source, flags),
	                            regex.xregexp.captureNames ? regex.xregexp.captureNames.slice(0) : null);
	        } else {
	            // Augment with `XRegExp.prototype` methods, but use native `RegExp` (avoid searching for special tokens)
	            regex = augment(new RegExp(regex.source, flags), null, true);
	        }
	        return regex;
	    }

	/*
	 * Returns the last index at which a given value can be found in an array, or `-1` if it's not
	 * present. The array is searched backwards.
	 * @private
	 * @param {Array} array Array to search.
	 * @param {*} value Value to locate in the array.
	 * @returns {Number} Last zero-based index at which the item is found, or -1.
	 */
	    function lastIndexOf(array, value) {
	        var i = array.length;
	        if (Array.prototype.lastIndexOf) {
	            return array.lastIndexOf(value); // Use the native method if available
	        }
	        while (i--) {
	            if (array[i] === value) {
	                return i;
	            }
	        }
	        return -1;
	    }

	/**
	 * Determines whether an object is of the specified type.
	 * @private
	 * @param {*} value Object to check.
	 * @param {String} type Type to check for, in lowercase.
	 * @returns {Boolean} Whether the object matches the type.
	 */
	    function isType(value, type) {
	        return Object.prototype.toString.call(value).toLowerCase() === "[object " + type + "]";
	    }

	/**
	 * Prepares an options object from the given value.
	 * @private
	 * @param {String|Object} value Value to convert to an options object.
	 * @returns {Object} Options object.
	 */
	    function prepareOptions(value) {
	        value = value || {};
	        if (value === "all" || value.all) {
	            value = {natives: true, extensibility: true};
	        } else if (isType(value, "string")) {
	            value = self.forEach(value, /[^\s,]+/, function (m) {
	                this[m] = true;
	            }, {});
	        }
	        return value;
	    }

	/**
	 * Runs built-in/custom tokens in reverse insertion order, until a match is found.
	 * @private
	 * @param {String} pattern Original pattern from which an XRegExp object is being built.
	 * @param {Number} pos Position to search for tokens within `pattern`.
	 * @param {Number} scope Current regex scope.
	 * @param {Object} context Context object assigned to token handler functions.
	 * @returns {Object} Object with properties `output` (the substitution string returned by the
	 *   successful token handler) and `match` (the token's match array), or null.
	 */
	    function runTokens(pattern, pos, scope, context) {
	        var i = tokens.length,
	            result = null,
	            match,
	            t;
	        // Protect against constructing XRegExps within token handler and trigger functions
	        isInsideConstructor = true;
	        // Must reset `isInsideConstructor`, even if a `trigger` or `handler` throws
	        try {
	            while (i--) { // Run in reverse order
	                t = tokens[i];
	                if ((t.scope === "all" || t.scope === scope) && (!t.trigger || t.trigger.call(context))) {
	                    t.pattern.lastIndex = pos;
	                    match = fixed.exec.call(t.pattern, pattern); // Fixed `exec` here allows use of named backreferences, etc.
	                    if (match && match.index === pos) {
	                        result = {
	                            output: t.handler.call(context, match, scope),
	                            match: match
	                        };
	                        break;
	                    }
	                }
	            }
	        } catch (err) {
	            throw err;
	        } finally {
	            isInsideConstructor = false;
	        }
	        return result;
	    }

	/**
	 * Enables or disables XRegExp syntax and flag extensibility.
	 * @private
	 * @param {Boolean} on `true` to enable; `false` to disable.
	 */
	    function setExtensibility(on) {
	        self.addToken = addToken[on ? "on" : "off"];
	        features.extensibility = on;
	    }

	/**
	 * Enables or disables native method overrides.
	 * @private
	 * @param {Boolean} on `true` to enable; `false` to disable.
	 */
	    function setNatives(on) {
	        RegExp.prototype.exec = (on ? fixed : nativ).exec;
	        RegExp.prototype.test = (on ? fixed : nativ).test;
	        String.prototype.match = (on ? fixed : nativ).match;
	        String.prototype.replace = (on ? fixed : nativ).replace;
	        String.prototype.split = (on ? fixed : nativ).split;
	        features.natives = on;
	    }

	/*--------------------------------------
	 *  Constructor
	 *------------------------------------*/

	/**
	 * Creates an extended regular expression object for matching text with a pattern. Differs from a
	 * native regular expression in that additional syntax and flags are supported. The returned object
	 * is in fact a native `RegExp` and works with all native methods.
	 * @class XRegExp
	 * @constructor
	 * @param {String|RegExp} pattern Regex pattern string, or an existing `RegExp` object to copy.
	 * @param {String} [flags] Any combination of flags:
	 *   <li>`g` - global
	 *   <li>`i` - ignore case
	 *   <li>`m` - multiline anchors
	 *   <li>`n` - explicit capture
	 *   <li>`s` - dot matches all (aka singleline)
	 *   <li>`x` - free-spacing and line comments (aka extended)
	 *   <li>`y` - sticky (Firefox 3+ only)
	 *   Flags cannot be provided when constructing one `RegExp` from another.
	 * @returns {RegExp} Extended regular expression object.
	 * @example
	 *
	 * // With named capture and flag x
	 * date = XRegExp('(?<year>  [0-9]{4}) -?  # year  \n\
	 *                 (?<month> [0-9]{2}) -?  # month \n\
	 *                 (?<day>   [0-9]{2})     # day   ', 'x');
	 *
	 * // Passing a regex object to copy it. The copy maintains special properties for named capture,
	 * // is augmented with `XRegExp.prototype` methods, and has a fresh `lastIndex` property (set to
	 * // zero). Native regexes are not recompiled using XRegExp syntax.
	 * XRegExp(/regex/);
	 */
	    self = function (pattern, flags) {
	        if (self.isRegExp(pattern)) {
	            if (flags !== undef) {
	                throw new TypeError("can't supply flags when constructing one RegExp from another");
	            }
	            return copy(pattern);
	        }
	        // Tokens become part of the regex construction process, so protect against infinite recursion
	        // when an XRegExp is constructed within a token handler function
	        if (isInsideConstructor) {
	            throw new Error("can't call the XRegExp constructor within token definition functions");
	        }

	        var output = [],
	            scope = defaultScope,
	            tokenContext = {
	                hasNamedCapture: false,
	                captureNames: [],
	                hasFlag: function (flag) {
	                    return flags.indexOf(flag) > -1;
	                }
	            },
	            pos = 0,
	            tokenResult,
	            match,
	            chr;
	        pattern = pattern === undef ? "" : String(pattern);
	        flags = flags === undef ? "" : String(flags);

	        if (nativ.match.call(flags, duplicateFlags)) { // Don't use test/exec because they would update lastIndex
	            throw new SyntaxError("invalid duplicate regular expression flag");
	        }
	        // Strip/apply leading mode modifier with any combination of flags except g or y: (?imnsx)
	        pattern = nativ.replace.call(pattern, /^\(\?([\w$]+)\)/, function ($0, $1) {
	            if (nativ.test.call(/[gy]/, $1)) {
	                throw new SyntaxError("can't use flag g or y in mode modifier");
	            }
	            flags = nativ.replace.call(flags + $1, duplicateFlags, "");
	            return "";
	        });
	        self.forEach(flags, /[\s\S]/, function (m) {
	            if (registeredFlags.indexOf(m[0]) < 0) {
	                throw new SyntaxError("invalid regular expression flag " + m[0]);
	            }
	        });

	        while (pos < pattern.length) {
	            // Check for custom tokens at the current position
	            tokenResult = runTokens(pattern, pos, scope, tokenContext);
	            if (tokenResult) {
	                output.push(tokenResult.output);
	                pos += (tokenResult.match[0].length || 1);
	            } else {
	                // Check for native tokens (except character classes) at the current position
	                match = nativ.exec.call(nativeTokens[scope], pattern.slice(pos));
	                if (match) {
	                    output.push(match[0]);
	                    pos += match[0].length;
	                } else {
	                    chr = pattern.charAt(pos);
	                    if (chr === "[") {
	                        scope = classScope;
	                    } else if (chr === "]") {
	                        scope = defaultScope;
	                    }
	                    // Advance position by one character
	                    output.push(chr);
	                    ++pos;
	                }
	            }
	        }

	        return augment(new RegExp(output.join(""), nativ.replace.call(flags, /[^gimy]+/g, "")),
	                       tokenContext.hasNamedCapture ? tokenContext.captureNames : null);
	    };

	/*--------------------------------------
	 *  Public methods/properties
	 *------------------------------------*/

	// Installed and uninstalled states for `XRegExp.addToken`
	    addToken = {
	        on: function (regex, handler, options) {
	            options = options || {};
	            if (regex) {
	                tokens.push({
	                    pattern: copy(regex, "g" + (hasNativeY ? "y" : "")),
	                    handler: handler,
	                    scope: options.scope || defaultScope,
	                    trigger: options.trigger || null
	                });
	            }
	            // Providing `customFlags` with null `regex` and `handler` allows adding flags that do
	            // nothing, but don't throw an error
	            if (options.customFlags) {
	                registeredFlags = nativ.replace.call(registeredFlags + options.customFlags, duplicateFlags, "");
	            }
	        },
	        off: function () {
	            throw new Error("extensibility must be installed before using addToken");
	        }
	    };

	/**
	 * Extends or changes XRegExp syntax and allows custom flags. This is used internally and can be
	 * used to create XRegExp addons. `XRegExp.install('extensibility')` must be run before calling
	 * this function, or an error is thrown. If more than one token can match the same string, the last
	 * added wins.
	 * @memberOf XRegExp
	 * @param {RegExp} regex Regex object that matches the new token.
	 * @param {Function} handler Function that returns a new pattern string (using native regex syntax)
	 *   to replace the matched token within all future XRegExp regexes. Has access to persistent
	 *   properties of the regex being built, through `this`. Invoked with two arguments:
	 *   <li>The match array, with named backreference properties.
	 *   <li>The regex scope where the match was found.
	 * @param {Object} [options] Options object with optional properties:
	 *   <li>`scope` {String} Scopes where the token applies: 'default', 'class', or 'all'.
	 *   <li>`trigger` {Function} Function that returns `true` when the token should be applied; e.g.,
	 *     if a flag is set. If `false` is returned, the matched string can be matched by other tokens.
	 *     Has access to persistent properties of the regex being built, through `this` (including
	 *     function `this.hasFlag`).
	 *   <li>`customFlags` {String} Nonnative flags used by the token's handler or trigger functions.
	 *     Prevents XRegExp from throwing an invalid flag error when the specified flags are used.
	 * @example
	 *
	 * // Basic usage: Adds \a for ALERT character
	 * XRegExp.addToken(
	 *   /\\a/,
	 *   function () {return '\\x07';},
	 *   {scope: 'all'}
	 * );
	 * XRegExp('\\a[\\a-\\n]+').test('\x07\n\x07'); // -> true
	 */
	    self.addToken = addToken.off;

	/**
	 * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with
	 * the same pattern and flag combination, the cached copy is returned.
	 * @memberOf XRegExp
	 * @param {String} pattern Regex pattern string.
	 * @param {String} [flags] Any combination of XRegExp flags.
	 * @returns {RegExp} Cached XRegExp object.
	 * @example
	 *
	 * while (match = XRegExp.cache('.', 'gs').exec(str)) {
	 *   // The regex is compiled once only
	 * }
	 */
	    self.cache = function (pattern, flags) {
	        var key = pattern + "/" + (flags || "");
	        return cache[key] || (cache[key] = self(pattern, flags));
	    };

	/**
	 * Escapes any regular expression metacharacters, for use when matching literal strings. The result
	 * can safely be used at any point within a regex that uses any flags.
	 * @memberOf XRegExp
	 * @param {String} str String to escape.
	 * @returns {String} String with regex metacharacters escaped.
	 * @example
	 *
	 * XRegExp.escape('Escaped? <.>');
	 * // -> 'Escaped\?\ <\.>'
	 */
	    self.escape = function (str) {
	        return nativ.replace.call(str, /[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
	    };

	/**
	 * Executes a regex search in a specified string. Returns a match array or `null`. If the provided
	 * regex uses named capture, named backreference properties are included on the match array.
	 * Optional `pos` and `sticky` arguments specify the search start position, and whether the match
	 * must start at the specified position only. The `lastIndex` property of the provided regex is not
	 * used, but is updated for compatibility. Also fixes browser bugs compared to the native
	 * `RegExp.prototype.exec` and can be used reliably cross-browser.
	 * @memberOf XRegExp
	 * @param {String} str String to search.
	 * @param {RegExp} regex Regex to search with.
	 * @param {Number} [pos=0] Zero-based index at which to start the search.
	 * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
	 *   only. The string `'sticky'` is accepted as an alternative to `true`.
	 * @returns {Array} Match array with named backreference properties, or null.
	 * @example
	 *
	 * // Basic use, with named backreference
	 * var match = XRegExp.exec('U+2620', XRegExp('U\\+(?<hex>[0-9A-F]{4})'));
	 * match.hex; // -> '2620'
	 *
	 * // With pos and sticky, in a loop
	 * var pos = 2, result = [], match;
	 * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\d)>/, pos, 'sticky')) {
	 *   result.push(match[1]);
	 *   pos = match.index + match[0].length;
	 * }
	 * // result -> ['2', '3', '4']
	 */
	    self.exec = function (str, regex, pos, sticky) {
	        var r2 = copy(regex, "g" + (sticky && hasNativeY ? "y" : ""), (sticky === false ? "y" : "")),
	            match;
	        r2.lastIndex = pos = pos || 0;
	        match = fixed.exec.call(r2, str); // Fixed `exec` required for `lastIndex` fix, etc.
	        if (sticky && match && match.index !== pos) {
	            match = null;
	        }
	        if (regex.global) {
	            regex.lastIndex = match ? r2.lastIndex : 0;
	        }
	        return match;
	    };

	/**
	 * Executes a provided function once per regex match.
	 * @memberOf XRegExp
	 * @param {String} str String to search.
	 * @param {RegExp} regex Regex to search with.
	 * @param {Function} callback Function to execute for each match. Invoked with four arguments:
	 *   <li>The match array, with named backreference properties.
	 *   <li>The zero-based match index.
	 *   <li>The string being traversed.
	 *   <li>The regex object being used to traverse the string.
	 * @param {*} [context] Object to use as `this` when executing `callback`.
	 * @returns {*} Provided `context` object.
	 * @example
	 *
	 * // Extracts every other digit from a string
	 * XRegExp.forEach('1a2345', /\d/, function (match, i) {
	 *   if (i % 2) this.push(+match[0]);
	 * }, []);
	 * // -> [2, 4]
	 */
	    self.forEach = function (str, regex, callback, context) {
	        var pos = 0,
	            i = -1,
	            match;
	        while ((match = self.exec(str, regex, pos))) {
	            callback.call(context, match, ++i, str, regex);
	            pos = match.index + (match[0].length || 1);
	        }
	        return context;
	    };

	/**
	 * Copies a regex object and adds flag `g`. The copy maintains special properties for named
	 * capture, is augmented with `XRegExp.prototype` methods, and has a fresh `lastIndex` property
	 * (set to zero). Native regexes are not recompiled using XRegExp syntax.
	 * @memberOf XRegExp
	 * @param {RegExp} regex Regex to globalize.
	 * @returns {RegExp} Copy of the provided regex with flag `g` added.
	 * @example
	 *
	 * var globalCopy = XRegExp.globalize(/regex/);
	 * globalCopy.global; // -> true
	 */
	    self.globalize = function (regex) {
	        return copy(regex, "g");
	    };

	/**
	 * Installs optional features according to the specified options.
	 * @memberOf XRegExp
	 * @param {Object|String} options Options object or string.
	 * @example
	 *
	 * // With an options object
	 * XRegExp.install({
	 *   // Overrides native regex methods with fixed/extended versions that support named
	 *   // backreferences and fix numerous cross-browser bugs
	 *   natives: true,
	 *
	 *   // Enables extensibility of XRegExp syntax and flags
	 *   extensibility: true
	 * });
	 *
	 * // With an options string
	 * XRegExp.install('natives extensibility');
	 *
	 * // Using a shortcut to install all optional features
	 * XRegExp.install('all');
	 */
	    self.install = function (options) {
	        options = prepareOptions(options);
	        if (!features.natives && options.natives) {
	            setNatives(true);
	        }
	        if (!features.extensibility && options.extensibility) {
	            setExtensibility(true);
	        }
	    };

	/**
	 * Checks whether an individual optional feature is installed.
	 * @memberOf XRegExp
	 * @param {String} feature Name of the feature to check. One of:
	 *   <li>`natives`
	 *   <li>`extensibility`
	 * @returns {Boolean} Whether the feature is installed.
	 * @example
	 *
	 * XRegExp.isInstalled('natives');
	 */
	    self.isInstalled = function (feature) {
	        return !!(features[feature]);
	    };

	/**
	 * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes
	 * created in another frame, when `instanceof` and `constructor` checks would fail.
	 * @memberOf XRegExp
	 * @param {*} value Object to check.
	 * @returns {Boolean} Whether the object is a `RegExp` object.
	 * @example
	 *
	 * XRegExp.isRegExp('string'); // -> false
	 * XRegExp.isRegExp(/regex/i); // -> true
	 * XRegExp.isRegExp(RegExp('^', 'm')); // -> true
	 * XRegExp.isRegExp(XRegExp('(?s).')); // -> true
	 */
	    self.isRegExp = function (value) {
	        return isType(value, "regexp");
	    };

	/**
	 * Retrieves the matches from searching a string using a chain of regexes that successively search
	 * within previous matches. The provided `chain` array can contain regexes and objects with `regex`
	 * and `backref` properties. When a backreference is specified, the named or numbered backreference
	 * is passed forward to the next regex or returned.
	 * @memberOf XRegExp
	 * @param {String} str String to search.
	 * @param {Array} chain Regexes that each search for matches within preceding results.
	 * @returns {Array} Matches by the last regex in the chain, or an empty array.
	 * @example
	 *
	 * // Basic usage; matches numbers within <b> tags
	 * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [
	 *   XRegExp('(?is)<b>.*?</b>'),
	 *   /\d+/
	 * ]);
	 * // -> ['2', '4', '56']
	 *
	 * // Passing forward and returning specific backreferences
	 * html = '<a href="http://xregexp.com/api/">XRegExp</a>\
	 *         <a href="http://www.google.com/">Google</a>';
	 * XRegExp.matchChain(html, [
	 *   {regex: /<a href="([^"]+)">/i, backref: 1},
	 *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}
	 * ]);
	 * // -> ['xregexp.com', 'www.google.com']
	 */
	    self.matchChain = function (str, chain) {
	        return (function recurseChain(values, level) {
	            var item = chain[level].regex ? chain[level] : {regex: chain[level]},
	                matches = [],
	                addMatch = function (match) {
	                    matches.push(item.backref ? (match[item.backref] || "") : match[0]);
	                },
	                i;
	            for (i = 0; i < values.length; ++i) {
	                self.forEach(values[i], item.regex, addMatch);
	            }
	            return ((level === chain.length - 1) || !matches.length) ?
	                    matches :
	                    recurseChain(matches, level + 1);
	        }([str], 0));
	    };

	/**
	 * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string
	 * or regex, and the replacement can be a string or a function to be called for each match. To
	 * perform a global search and replace, use the optional `scope` argument or include flag `g` if
	 * using a regex. Replacement strings can use `${n}` for named and numbered backreferences.
	 * Replacement functions can use named backreferences via `arguments[0].name`. Also fixes browser
	 * bugs compared to the native `String.prototype.replace` and can be used reliably cross-browser.
	 * @memberOf XRegExp
	 * @param {String} str String to search.
	 * @param {RegExp|String} search Search pattern to be replaced.
	 * @param {String|Function} replacement Replacement string or a function invoked to create it.
	 *   Replacement strings can include special replacement syntax:
	 *     <li>$$ - Inserts a literal '$'.
	 *     <li>$&, $0 - Inserts the matched substring.
	 *     <li>$` - Inserts the string that precedes the matched substring (left context).
	 *     <li>$' - Inserts the string that follows the matched substring (right context).
	 *     <li>$n, $nn - Where n/nn are digits referencing an existent capturing group, inserts
	 *       backreference n/nn.
	 *     <li>${n} - Where n is a name or any number of digits that reference an existent capturing
	 *       group, inserts backreference n.
	 *   Replacement functions are invoked with three or more arguments:
	 *     <li>The matched substring (corresponds to $& above). Named backreferences are accessible as
	 *       properties of this first argument.
	 *     <li>0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).
	 *     <li>The zero-based index of the match within the total search string.
	 *     <li>The total string being searched.
	 * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not
	 *   explicitly specified and using a regex with flag `g`, `scope` is 'all'.
	 * @returns {String} New string with one or all matches replaced.
	 * @example
	 *
	 * // Regex search, using named backreferences in replacement string
	 * var name = XRegExp('(?<first>\\w+) (?<last>\\w+)');
	 * XRegExp.replace('John Smith', name, '${last}, ${first}');
	 * // -> 'Smith, John'
	 *
	 * // Regex search, using named backreferences in replacement function
	 * XRegExp.replace('John Smith', name, function (match) {
	 *   return match.last + ', ' + match.first;
	 * });
	 * // -> 'Smith, John'
	 *
	 * // Global string search/replacement
	 * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');
	 * // -> 'XRegExp builds XRegExps'
	 */
	    self.replace = function (str, search, replacement, scope) {
	        var isRegex = self.isRegExp(search),
	            search2 = search,
	            result;
	        if (isRegex) {
	            if (scope === undef && search.global) {
	                scope = "all"; // Follow flag g when `scope` isn't explicit
	            }
	            // Note that since a copy is used, `search`'s `lastIndex` isn't updated *during* replacement iterations
	            search2 = copy(search, scope === "all" ? "g" : "", scope === "all" ? "" : "g");
	        } else if (scope === "all") {
	            search2 = new RegExp(self.escape(String(search)), "g");
	        }
	        result = fixed.replace.call(String(str), search2, replacement); // Fixed `replace` required for named backreferences, etc.
	        if (isRegex && search.global) {
	            search.lastIndex = 0; // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
	        }
	        return result;
	    };

	/**
	 * Splits a string into an array of strings using a regex or string separator. Matches of the
	 * separator are not included in the result array. However, if `separator` is a regex that contains
	 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
	 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
	 * cross-browser.
	 * @memberOf XRegExp
	 * @param {String} str String to split.
	 * @param {RegExp|String} separator Regex or string to use for separating the string.
	 * @param {Number} [limit] Maximum number of items to include in the result array.
	 * @returns {Array} Array of substrings.
	 * @example
	 *
	 * // Basic use
	 * XRegExp.split('a b c', ' ');
	 * // -> ['a', 'b', 'c']
	 *
	 * // With limit
	 * XRegExp.split('a b c', ' ', 2);
	 * // -> ['a', 'b']
	 *
	 * // Backreferences in result array
	 * XRegExp.split('..word1..', /([a-z]+)(\d+)/i);
	 * // -> ['..', 'word', '1', '..']
	 */
	    self.split = function (str, separator, limit) {
	        return fixed.split.call(str, separator, limit);
	    };

	/**
	 * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and
	 * `sticky` arguments specify the search start position, and whether the match must start at the
	 * specified position only. The `lastIndex` property of the provided regex is not used, but is
	 * updated for compatibility. Also fixes browser bugs compared to the native
	 * `RegExp.prototype.test` and can be used reliably cross-browser.
	 * @memberOf XRegExp
	 * @param {String} str String to search.
	 * @param {RegExp} regex Regex to search with.
	 * @param {Number} [pos=0] Zero-based index at which to start the search.
	 * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
	 *   only. The string `'sticky'` is accepted as an alternative to `true`.
	 * @returns {Boolean} Whether the regex matched the provided value.
	 * @example
	 *
	 * // Basic use
	 * XRegExp.test('abc', /c/); // -> true
	 *
	 * // With pos and sticky
	 * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false
	 */
	    self.test = function (str, regex, pos, sticky) {
	        // Do this the easy way :-)
	        return !!self.exec(str, regex, pos, sticky);
	    };

	/**
	 * Uninstalls optional features according to the specified options.
	 * @memberOf XRegExp
	 * @param {Object|String} options Options object or string.
	 * @example
	 *
	 * // With an options object
	 * XRegExp.uninstall({
	 *   // Restores native regex methods
	 *   natives: true,
	 *
	 *   // Disables additional syntax and flag extensions
	 *   extensibility: true
	 * });
	 *
	 * // With an options string
	 * XRegExp.uninstall('natives extensibility');
	 *
	 * // Using a shortcut to uninstall all optional features
	 * XRegExp.uninstall('all');
	 */
	    self.uninstall = function (options) {
	        options = prepareOptions(options);
	        if (features.natives && options.natives) {
	            setNatives(false);
	        }
	        if (features.extensibility && options.extensibility) {
	            setExtensibility(false);
	        }
	    };

	/**
	 * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as
	 * regex objects or strings. Metacharacters are escaped in patterns provided as strings.
	 * Backreferences in provided regex objects are automatically renumbered to work correctly. Native
	 * flags used by provided regexes are ignored in favor of the `flags` argument.
	 * @memberOf XRegExp
	 * @param {Array} patterns Regexes and strings to combine.
	 * @param {String} [flags] Any combination of XRegExp flags.
	 * @returns {RegExp} Union of the provided regexes and strings.
	 * @example
	 *
	 * XRegExp.union(['a+b*c', /(dogs)\1/, /(cats)\1/], 'i');
	 * // -> /a\+b\*c|(dogs)\1|(cats)\2/i
	 *
	 * XRegExp.union([XRegExp('(?<pet>dogs)\\k<pet>'), XRegExp('(?<pet>cats)\\k<pet>')]);
	 * // -> XRegExp('(?<pet>dogs)\\k<pet>|(?<pet>cats)\\k<pet>')
	 */
	    self.union = function (patterns, flags) {
	        var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*]/g,
	            numCaptures = 0,
	            numPriorCaptures,
	            captureNames,
	            rewrite = function (match, paren, backref) {
	                var name = captureNames[numCaptures - numPriorCaptures];
	                if (paren) { // Capturing group
	                    ++numCaptures;
	                    if (name) { // If the current capture has a name
	                        return "(?<" + name + ">";
	                    }
	                } else if (backref) { // Backreference
	                    return "\\" + (+backref + numPriorCaptures);
	                }
	                return match;
	            },
	            output = [],
	            pattern,
	            i;
	        if (!(isType(patterns, "array") && patterns.length)) {
	            throw new TypeError("patterns must be a nonempty array");
	        }
	        for (i = 0; i < patterns.length; ++i) {
	            pattern = patterns[i];
	            if (self.isRegExp(pattern)) {
	                numPriorCaptures = numCaptures;
	                captureNames = (pattern.xregexp && pattern.xregexp.captureNames) || [];
	                // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns
	                // are independently valid; helps keep this simple. Named captures are put back
	                output.push(self(pattern.source).source.replace(parts, rewrite));
	            } else {
	                output.push(self.escape(pattern));
	            }
	        }
	        return self(output.join("|"), flags);
	    };

	/**
	 * The XRegExp version number.
	 * @static
	 * @memberOf XRegExp
	 * @type String
	 */
	    self.version = "2.0.0";

	/*--------------------------------------
	 *  Fixed/extended native methods
	 *------------------------------------*/

	/**
	 * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
	 * bugs in the native `RegExp.prototype.exec`. Calling `XRegExp.install('natives')` uses this to
	 * override the native method. Use via `XRegExp.exec` without overriding natives.
	 * @private
	 * @param {String} str String to search.
	 * @returns {Array} Match array with named backreference properties, or null.
	 */
	    fixed.exec = function (str) {
	        var match, name, r2, origLastIndex, i;
	        if (!this.global) {
	            origLastIndex = this.lastIndex;
	        }
	        match = nativ.exec.apply(this, arguments);
	        if (match) {
	            // Fix browsers whose `exec` methods don't consistently return `undefined` for
	            // nonparticipating capturing groups
	            if (!compliantExecNpcg && match.length > 1 && lastIndexOf(match, "") > -1) {
	                r2 = new RegExp(this.source, nativ.replace.call(getNativeFlags(this), "g", ""));
	                // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed
	                // matching due to characters outside the match
	                nativ.replace.call(String(str).slice(match.index), r2, function () {
	                    var i;
	                    for (i = 1; i < arguments.length - 2; ++i) {
	                        if (arguments[i] === undef) {
	                            match[i] = undef;
	                        }
	                    }
	                });
	            }
	            // Attach named capture properties
	            if (this.xregexp && this.xregexp.captureNames) {
	                for (i = 1; i < match.length; ++i) {
	                    name = this.xregexp.captureNames[i - 1];
	                    if (name) {
	                        match[name] = match[i];
	                    }
	                }
	            }
	            // Fix browsers that increment `lastIndex` after zero-length matches
	            if (this.global && !match[0].length && (this.lastIndex > match.index)) {
	                this.lastIndex = match.index;
	            }
	        }
	        if (!this.global) {
	            this.lastIndex = origLastIndex; // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
	        }
	        return match;
	    };

	/**
	 * Fixes browser bugs in the native `RegExp.prototype.test`. Calling `XRegExp.install('natives')`
	 * uses this to override the native method.
	 * @private
	 * @param {String} str String to search.
	 * @returns {Boolean} Whether the regex matched the provided value.
	 */
	    fixed.test = function (str) {
	        // Do this the easy way :-)
	        return !!fixed.exec.call(this, str);
	    };

	/**
	 * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
	 * bugs in the native `String.prototype.match`. Calling `XRegExp.install('natives')` uses this to
	 * override the native method.
	 * @private
	 * @param {RegExp} regex Regex to search with.
	 * @returns {Array} If `regex` uses flag g, an array of match strings or null. Without flag g, the
	 *   result of calling `regex.exec(this)`.
	 */
	    fixed.match = function (regex) {
	        if (!self.isRegExp(regex)) {
	            regex = new RegExp(regex); // Use native `RegExp`
	        } else if (regex.global) {
	            var result = nativ.match.apply(this, arguments);
	            regex.lastIndex = 0; // Fixes IE bug
	            return result;
	        }
	        return fixed.exec.call(regex, this);
	    };

	/**
	 * Adds support for `${n}` tokens for named and numbered backreferences in replacement text, and
	 * provides named backreferences to replacement functions as `arguments[0].name`. Also fixes
	 * browser bugs in replacement text syntax when performing a replacement using a nonregex search
	 * value, and the value of a replacement regex's `lastIndex` property during replacement iterations
	 * and upon completion. Note that this doesn't support SpiderMonkey's proprietary third (`flags`)
	 * argument. Calling `XRegExp.install('natives')` uses this to override the native method. Use via
	 * `XRegExp.replace` without overriding natives.
	 * @private
	 * @param {RegExp|String} search Search pattern to be replaced.
	 * @param {String|Function} replacement Replacement string or a function invoked to create it.
	 * @returns {String} New string with one or all matches replaced.
	 */
	    fixed.replace = function (search, replacement) {
	        var isRegex = self.isRegExp(search), captureNames, result, str, origLastIndex;
	        if (isRegex) {
	            if (search.xregexp) {
	                captureNames = search.xregexp.captureNames;
	            }
	            if (!search.global) {
	                origLastIndex = search.lastIndex;
	            }
	        } else {
	            search += "";
	        }
	        if (isType(replacement, "function")) {
	            result = nativ.replace.call(String(this), search, function () {
	                var args = arguments, i;
	                if (captureNames) {
	                    // Change the `arguments[0]` string primitive to a `String` object that can store properties
	                    args[0] = new String(args[0]);
	                    // Store named backreferences on the first argument
	                    for (i = 0; i < captureNames.length; ++i) {
	                        if (captureNames[i]) {
	                            args[0][captureNames[i]] = args[i + 1];
	                        }
	                    }
	                }
	                // Update `lastIndex` before calling `replacement`.
	                // Fixes IE, Chrome, Firefox, Safari bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)
	                if (isRegex && search.global) {
	                    search.lastIndex = args[args.length - 2] + args[0].length;
	                }
	                return replacement.apply(null, args);
	            });
	        } else {
	            str = String(this); // Ensure `args[args.length - 1]` will be a string when given nonstring `this`
	            result = nativ.replace.call(str, search, function () {
	                var args = arguments; // Keep this function's `arguments` available through closure
	                return nativ.replace.call(String(replacement), replacementToken, function ($0, $1, $2) {
	                    var n;
	                    // Named or numbered backreference with curly brackets
	                    if ($1) {
	                        /* XRegExp behavior for `${n}`:
	                         * 1. Backreference to numbered capture, where `n` is 1+ digits. `0`, `00`, etc. is the entire match.
	                         * 2. Backreference to named capture `n`, if it exists and is not a number overridden by numbered capture.
	                         * 3. Otherwise, it's an error.
	                         */
	                        n = +$1; // Type-convert; drop leading zeros
	                        if (n <= args.length - 3) {
	                            return args[n] || "";
	                        }
	                        n = captureNames ? lastIndexOf(captureNames, $1) : -1;
	                        if (n < 0) {
	                            throw new SyntaxError("backreference to undefined group " + $0);
	                        }
	                        return args[n + 1] || "";
	                    }
	                    // Else, special variable or numbered backreference (without curly brackets)
	                    if ($2 === "$") return "$";
	                    if ($2 === "&" || +$2 === 0) return args[0]; // $&, $0 (not followed by 1-9), $00
	                    if ($2 === "`") return args[args.length - 1].slice(0, args[args.length - 2]);
	                    if ($2 === "'") return args[args.length - 1].slice(args[args.length - 2] + args[0].length);
	                    // Else, numbered backreference (without curly brackets)
	                    $2 = +$2; // Type-convert; drop leading zero
	                    /* XRegExp behavior:
	                     * - Backreferences without curly brackets end after 1 or 2 digits. Use `${..}` for more digits.
	                     * - `$1` is an error if there are no capturing groups.
	                     * - `$10` is an error if there are less than 10 capturing groups. Use `${1}0` instead.
	                     * - `$01` is equivalent to `$1` if a capturing group exists, otherwise it's an error.
	                     * - `$0` (not followed by 1-9), `$00`, and `$&` are the entire match.
	                     * Native behavior, for comparison:
	                     * - Backreferences end after 1 or 2 digits. Cannot use backreference to capturing group 100+.
	                     * - `$1` is a literal `$1` if there are no capturing groups.
	                     * - `$10` is `$1` followed by a literal `0` if there are less than 10 capturing groups.
	                     * - `$01` is equivalent to `$1` if a capturing group exists, otherwise it's a literal `$01`.
	                     * - `$0` is a literal `$0`. `$&` is the entire match.
	                     */
	                    if (!isNaN($2)) {
	                        if ($2 > args.length - 3) {
	                            throw new SyntaxError("backreference to undefined group " + $0);
	                        }
	                        return args[$2] || "";
	                    }
	                    throw new SyntaxError("invalid token " + $0);
	                });
	            });
	        }
	        if (isRegex) {
	            if (search.global) {
	                search.lastIndex = 0; // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
	            } else {
	                search.lastIndex = origLastIndex; // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
	            }
	        }
	        return result;
	    };

	/**
	 * Fixes browser bugs in the native `String.prototype.split`. Calling `XRegExp.install('natives')`
	 * uses this to override the native method. Use via `XRegExp.split` without overriding natives.
	 * @private
	 * @param {RegExp|String} separator Regex or string to use for separating the string.
	 * @param {Number} [limit] Maximum number of items to include in the result array.
	 * @returns {Array} Array of substrings.
	 */
	    fixed.split = function (separator, limit) {
	        if (!self.isRegExp(separator)) {
	            return nativ.split.apply(this, arguments); // use faster native method
	        }
	        var str = String(this),
	            origLastIndex = separator.lastIndex,
	            output = [],
	            lastLastIndex = 0,
	            lastLength;
	        /* Values for `limit`, per the spec:
	         * If undefined: pow(2,32) - 1
	         * If 0, Infinity, or NaN: 0
	         * If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);
	         * If negative number: pow(2,32) - floor(abs(limit))
	         * If other: Type-convert, then use the above rules
	         */
	        limit = (limit === undef ? -1 : limit) >>> 0;
	        self.forEach(str, separator, function (match) {
	            if ((match.index + match[0].length) > lastLastIndex) { // != `if (match[0].length)`
	                output.push(str.slice(lastLastIndex, match.index));
	                if (match.length > 1 && match.index < str.length) {
	                    Array.prototype.push.apply(output, match.slice(1));
	                }
	                lastLength = match[0].length;
	                lastLastIndex = match.index + lastLength;
	            }
	        });
	        if (lastLastIndex === str.length) {
	            if (!nativ.test.call(separator, "") || lastLength) {
	                output.push("");
	            }
	        } else {
	            output.push(str.slice(lastLastIndex));
	        }
	        separator.lastIndex = origLastIndex;
	        return output.length > limit ? output.slice(0, limit) : output;
	    };

	/*--------------------------------------
	 *  Built-in tokens
	 *------------------------------------*/

	// Shortcut
	    add = addToken.on;

	/* Letter identity escapes that natively match literal characters: \p, \P, etc.
	 * Should be SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-
	 * browser consistency and to reserve their syntax, but lets them be superseded by XRegExp addons.
	 */
	    add(/\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\dA-Fa-f]{4})|x(?![\dA-Fa-f]{2}))/,
	        function (match, scope) {
	            // \B is allowed in default scope only
	            if (match[1] === "B" && scope === defaultScope) {
	                return match[0];
	            }
	            throw new SyntaxError("invalid escape " + match[0]);
	        },
	        {scope: "all"});

	/* Empty character class: [] or [^]
	 * Fixes a critical cross-browser syntax inconsistency. Unless this is standardized (per the spec),
	 * regex syntax can't be accurately parsed because character class endings can't be determined.
	 */
	    add(/\[(\^?)]/,
	        function (match) {
	            // For cross-browser compatibility with ES3, convert [] to \b\B and [^] to [\s\S].
	            // (?!) should work like \b\B, but is unreliable in Firefox
	            return match[1] ? "[\\s\\S]" : "\\b\\B";
	        });

	/* Comment pattern: (?# )
	 * Inline comments are an alternative to the line comments allowed in free-spacing mode (flag x).
	 */
	    add(/(?:\(\?#[^)]*\))+/,
	        function (match) {
	            // Keep tokens separated unless the following token is a quantifier
	            return nativ.test.call(quantifier, match.input.slice(match.index + match[0].length)) ? "" : "(?:)";
	        });

	/* Named backreference: \k<name>
	 * Backreference names can use the characters A-Z, a-z, 0-9, _, and $ only.
	 */
	    add(/\\k<([\w$]+)>/,
	        function (match) {
	            var index = isNaN(match[1]) ? (lastIndexOf(this.captureNames, match[1]) + 1) : +match[1],
	                endIndex = match.index + match[0].length;
	            if (!index || index > this.captureNames.length) {
	                throw new SyntaxError("backreference to undefined group " + match[0]);
	            }
	            // Keep backreferences separate from subsequent literal numbers
	            return "\\" + index + (
	                endIndex === match.input.length || isNaN(match.input.charAt(endIndex)) ? "" : "(?:)"
	            );
	        });

	/* Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.
	 */
	    add(/(?:\s+|#.*)+/,
	        function (match) {
	            // Keep tokens separated unless the following token is a quantifier
	            return nativ.test.call(quantifier, match.input.slice(match.index + match[0].length)) ? "" : "(?:)";
	        },
	        {
	            trigger: function () {
	                return this.hasFlag("x");
	            },
	            customFlags: "x"
	        });

	/* Dot, in dotall mode (aka singleline mode, flag s) only.
	 */
	    add(/\./,
	        function () {
	            return "[\\s\\S]";
	        },
	        {
	            trigger: function () {
	                return this.hasFlag("s");
	            },
	            customFlags: "s"
	        });

	/* Named capturing group; match the opening delimiter only: (?<name>
	 * Capture names can use the characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers.
	 * Supports Python-style (?P<name> as an alternate syntax to avoid issues in recent Opera (which
	 * natively supports the Python-style syntax). Otherwise, XRegExp might treat numbered
	 * backreferences to Python-style named capture as octals.
	 */
	    add(/\(\?P?<([\w$]+)>/,
	        function (match) {
	            if (!isNaN(match[1])) {
	                // Avoid incorrect lookups, since named backreferences are added to match arrays
	                throw new SyntaxError("can't use integer as capture name " + match[0]);
	            }
	            this.captureNames.push(match[1]);
	            this.hasNamedCapture = true;
	            return "(";
	        });

	/* Numbered backreference or octal, plus any following digits: \0, \11, etc.
	 * Octals except \0 not followed by 0-9 and backreferences to unopened capture groups throw an
	 * error. Other matches are returned unaltered. IE <= 8 doesn't support backreferences greater than
	 * \99 in regex syntax.
	 */
	    add(/\\(\d+)/,
	        function (match, scope) {
	            if (!(scope === defaultScope && /^[1-9]/.test(match[1]) && +match[1] <= this.captureNames.length) &&
	                    match[1] !== "0") {
	                throw new SyntaxError("can't use octal escape or backreference to undefined group " + match[0]);
	            }
	            return match[0];
	        },
	        {scope: "all"});

	/* Capturing group; match the opening parenthesis only.
	 * Required for support of named capturing groups. Also adds explicit capture mode (flag n).
	 */
	    add(/\((?!\?)/,
	        function () {
	            if (this.hasFlag("n")) {
	                return "(?:";
	            }
	            this.captureNames.push(null);
	            return "(";
	        },
	        {customFlags: "n"});

	/*--------------------------------------
	 *  Expose XRegExp
	 *------------------------------------*/

	// For CommonJS enviroments
	    if (true) {
	        exports.XRegExp = self;
	    }

	    return self;

	}());


	/***** unicode-base.js *****/

	/*!
	 * XRegExp Unicode Base v1.0.0
	 * (c) 2008-2012 Steven Levithan <http://xregexp.com/>
	 * MIT License
	 * Uses Unicode 6.1 <http://unicode.org/>
	 */

	/**
	 * Adds support for the `\p{L}` or `\p{Letter}` Unicode category. Addon packages for other Unicode
	 * categories, scripts, blocks, and properties are available separately. All Unicode tokens can be
	 * inverted using `\P{..}` or `\p{^..}`. Token names are case insensitive, and any spaces, hyphens,
	 * and underscores are ignored.
	 * @requires XRegExp
	 */
	(function (XRegExp) {
	    "use strict";

	    var unicode = {};

	/*--------------------------------------
	 *  Private helper functions
	 *------------------------------------*/

	// Generates a standardized token name (lowercase, with hyphens, spaces, and underscores removed)
	    function slug(name) {
	        return name.replace(/[- _]+/g, "").toLowerCase();
	    }

	// Expands a list of Unicode code points and ranges to be usable in a regex character class
	    function expand(str) {
	        return str.replace(/\w{4}/g, "\\u$&");
	    }

	// Adds leading zeros if shorter than four characters
	    function pad4(str) {
	        while (str.length < 4) {
	            str = "0" + str;
	        }
	        return str;
	    }

	// Converts a hexadecimal number to decimal
	    function dec(hex) {
	        return parseInt(hex, 16);
	    }

	// Converts a decimal number to hexadecimal
	    function hex(dec) {
	        return parseInt(dec, 10).toString(16);
	    }

	// Inverts a list of Unicode code points and ranges
	    function invert(range) {
	        var output = [],
	            lastEnd = -1,
	            start;
	        XRegExp.forEach(range, /\\u(\w{4})(?:-\\u(\w{4}))?/, function (m) {
	            start = dec(m[1]);
	            if (start > (lastEnd + 1)) {
	                output.push("\\u" + pad4(hex(lastEnd + 1)));
	                if (start > (lastEnd + 2)) {
	                    output.push("-\\u" + pad4(hex(start - 1)));
	                }
	            }
	            lastEnd = dec(m[2] || m[1]);
	        });
	        if (lastEnd < 0xFFFF) {
	            output.push("\\u" + pad4(hex(lastEnd + 1)));
	            if (lastEnd < 0xFFFE) {
	                output.push("-\\uFFFF");
	            }
	        }
	        return output.join("");
	    }

	// Generates an inverted token on first use
	    function cacheInversion(item) {
	        return unicode["^" + item] || (unicode["^" + item] = invert(unicode[item]));
	    }

	/*--------------------------------------
	 *  Core functionality
	 *------------------------------------*/

	    XRegExp.install("extensibility");

	/**
	 * Adds to the list of Unicode properties that XRegExp regexes can match via \p{..} or \P{..}.
	 * @memberOf XRegExp
	 * @param {Object} pack Named sets of Unicode code points and ranges.
	 * @param {Object} [aliases] Aliases for the primary token names.
	 * @example
	 *
	 * XRegExp.addUnicodePackage({
	 *   XDigit: '0030-00390041-00460061-0066' // 0-9A-Fa-f
	 * }, {
	 *   XDigit: 'Hexadecimal'
	 * });
	 */
	    XRegExp.addUnicodePackage = function (pack, aliases) {
	        var p;
	        if (!XRegExp.isInstalled("extensibility")) {
	            throw new Error("extensibility must be installed before adding Unicode packages");
	        }
	        if (pack) {
	            for (p in pack) {
	                if (pack.hasOwnProperty(p)) {
	                    unicode[slug(p)] = expand(pack[p]);
	                }
	            }
	        }
	        if (aliases) {
	            for (p in aliases) {
	                if (aliases.hasOwnProperty(p)) {
	                    unicode[slug(aliases[p])] = unicode[slug(p)];
	                }
	            }
	        }
	    };

	/* Adds data for the Unicode `Letter` category. Addon packages include other categories, scripts,
	 * blocks, and properties.
	 */
	    XRegExp.addUnicodePackage({
	        L: "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05270531-055605590561-058705D0-05EA05F0-05F20620-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280840-085808A008A2-08AC0904-0939093D09500958-09610971-09770979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10CF10CF20D05-0D0C0D0E-0D100D12-0D3A0D3D0D4E0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC-0EDF0F000F40-0F470F49-0F6C0F88-0F8C1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510C710CD10D0-10FA10FC-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1BBA-1BE51C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11CF51CF61D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209C21022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2CF22CF32D00-2D252D272D2D2D30-2D672D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31BA31F0-31FF3400-4DB54E00-9FCCA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78B-A78EA790-A793A7A0-A7AAA7F8-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDAAE0-AAEAAAF2-AAF4AB01-AB06AB09-AB0EAB11-AB16AB20-AB26AB28-AB2EABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC"
	    }, {
	        L: "Letter"
	    });

	/* Adds Unicode property syntax to XRegExp: \p{..}, \P{..}, \p{^..}
	 */
	    XRegExp.addToken(
	        /\\([pP]){(\^?)([^}]*)}/,
	        function (match, scope) {
	            var inv = (match[1] === "P" || match[2]) ? "^" : "",
	                item = slug(match[3]);
	            // The double negative \P{^..} is invalid
	            if (match[1] === "P" && match[2]) {
	                throw new SyntaxError("invalid double negation \\P{^");
	            }
	            if (!unicode.hasOwnProperty(item)) {
	                throw new SyntaxError("invalid or unknown Unicode property " + match[0]);
	            }
	            return scope === "class" ?
	                    (inv ? cacheInversion(item) : unicode[item]) :
	                    "[" + inv + unicode[item] + "]";
	        },
	        {scope: "all"}
	    );

	}(XRegExp));


	/***** unicode-categories.js *****/

	/*!
	 * XRegExp Unicode Categories v1.2.0
	 * (c) 2010-2012 Steven Levithan <http://xregexp.com/>
	 * MIT License
	 * Uses Unicode 6.1 <http://unicode.org/>
	 */

	/**
	 * Adds support for all Unicode categories (aka properties) E.g., `\p{Lu}` or
	 * `\p{Uppercase Letter}`. Token names are case insensitive, and any spaces, hyphens, and
	 * underscores are ignored.
	 * @requires XRegExp, XRegExp Unicode Base
	 */
	(function (XRegExp) {
	    "use strict";

	    if (!XRegExp.addUnicodePackage) {
	        throw new ReferenceError("Unicode Base must be loaded before Unicode Categories");
	    }

	    XRegExp.install("extensibility");

	    XRegExp.addUnicodePackage({
	        //L: "", // Included in the Unicode Base addon
	        Ll: "0061-007A00B500DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F05210523052505270561-05871D00-1D2B1D6B-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7B2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2CF32D00-2D252D272D2DA641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA661A663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CA78EA791A793A7A1A7A3A7A5A7A7A7A9A7FAFB00-FB06FB13-FB17FF41-FF5A",
	        Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E05200522052405260531-055610A0-10C510C710CD1E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CED2CF2A640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA660A662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BA78DA790A792A7A0A7A2A7A4A7A6A7A8A7AAFF21-FF3A",
	        Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
	        Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D6A1D781D9B-1DBF2071207F2090-209C2C7C2C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A7F8A7F9A9CFAA70AADDAAF3AAF4FF70FF9EFF9F",
	        Lo: "00AA00BA01BB01C0-01C3029405D0-05EA05F0-05F20620-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150840-085808A008A2-08AC0904-0939093D09500958-09610972-09770979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10CF10CF20D05-0D0C0D0E-0D100D12-0D3A0D3D0D4E0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC-0EDF0F000F40-0F470F49-0F6C0F88-0F8C1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA10FD-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1BBA-1BE51C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF11CF51CF62135-21382D30-2D672D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31BA31F0-31FF3400-4DB54E00-9FCCA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCAAE0-AAEAAAF2AB01-AB06AB09-AB0EAB11-AB16AB20-AB26AB28-AB2EABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
	        M: "0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065F067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0859-085B08E4-08FE0900-0903093A-093C093E-094F0951-0957096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F8D-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135D-135F1712-17141732-1734175217531772177317B4-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAD1BE6-1BF31C24-1C371CD0-1CD21CD4-1CE81CED1CF2-1CF41DC0-1DE61DFC-1DFF20D0-20F02CEF-2CF12D7F2DE0-2DFF302A-302F3099309AA66F-A672A674-A67DA69FA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1AAEB-AAEFAAF5AAF6ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26",
	        Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065F067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0859-085B08E4-08FE0900-0902093A093C0941-0948094D0951-095709620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F8D-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135D-135F1712-17141732-1734175217531772177317B417B517B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91BAB1BE61BE81BE91BED1BEF-1BF11C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1CF41DC0-1DE61DFC-1DFF20D0-20DC20E120E5-20F02CEF-2CF12D7F2DE0-2DFF302A-302D3099309AA66FA674-A67DA69FA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1AAECAAEDAAF6ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
	        Mc: "0903093B093E-09400949-094C094E094F0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1BAC1BAD1BE71BEA-1BEC1BEE1BF21BF31C24-1C2B1C341C351CE11CF21CF3302E302FA823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BAAEBAAEEAAEFAAF5ABE3ABE4ABE6ABE7ABE9ABEAABEC",
	        Me: "0488048920DD-20E020E2-20E4A670-A672",
	        N: "0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0B72-0B770BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293248-324F3251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
	        Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19D91A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
	        Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
	        No: "00B200B300B900BC-00BE09F4-09F90B72-0B770BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F919DA20702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293248-324F3251-325F3280-328932B1-32BFA830-A835",
	        P: "0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100A700AB00B600B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E085E0964096509700AF00DF40E4F0E5A0E5B0F04-0F120F140F3A-0F3D0F850FD0-0FD40FD90FDA104A-104F10FB1360-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A194419451A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601BFC-1BFF1C3B-1C3F1C7E1C7F1CC0-1CC71CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2D702E00-2E2E2E30-2E3B3001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFAAF0AAF1ABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65",
	        Pd: "002D058A05BE140018062010-20152E172E1A2E3A2E3B301C303030A0FE31FE32FE58FE63FF0D",
	        Ps: "0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62",
	        Pe: "0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63",
	        Pi: "00AB2018201B201C201F20392E022E042E092E0C2E1C2E20",
	        Pf: "00BB2019201D203A2E032E052E0A2E0D2E1D2E21",
	        Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F",
	        Po: "0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100A700B600B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E085E0964096509700AF00DF40E4F0E5A0E5B0F04-0F120F140F850FD0-0FD40FD90FDA104A-104F10FB1360-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A194419451A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601BFC-1BFF1C3B-1C3F1C7E1C7F1CC0-1CC71CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2D702E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E30-2E393001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFAAF0AAF1ABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65",
	        S: "0024002B003C-003E005E0060007C007E00A2-00A600A800A900AC00AE-00B100B400B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F60482058F0606-0608060B060E060F06DE06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0D790E3F0F01-0F030F130F15-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F1390-139917DB194019DE-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B9210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23F32400-24262440-244A249C-24E92500-26FF2701-27672794-27C427C7-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-324732503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FBB2-FBC1FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD",
	        Sm: "002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C21182140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC",
	        Sc: "002400A2-00A5058F060B09F209F309FB0AF10BF90E3F17DB20A0-20B9A838FDFCFE69FF04FFE0FFE1FFE5FFE6",
	        Sk: "005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFBB2-FBC1FF3EFF40FFE3",
	        So: "00A600A900AE00B00482060E060F06DE06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0D790F01-0F030F130F15-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F1390-1399194019DE-19FF1B61-1B6A1B74-1B7C210021012103-210621082109211421162117211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23F32400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26FF2701-27672794-27BF2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-324732503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD",
	        Z: "002000A01680180E2000-200A20282029202F205F3000",
	        Zs: "002000A01680180E2000-200A202F205F3000",
	        Zl: "2028",
	        Zp: "2029",
	        C: "0000-001F007F-009F00AD03780379037F-0383038B038D03A20528-05300557055805600588058B-058E059005C8-05CF05EB-05EF05F5-0605061C061D06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F085C085D085F-089F08A108AD-08E308FF097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B78-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D3B0D3C0D450D490D4F-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EE0-0EFF0F480F6D-0F700F980FBD0FCD0FDB-0FFF10C610C8-10CC10CE10CF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B135C137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BF4-1BFB1C38-1C3A1C4A-1C4C1C80-1CBF1CC8-1CCF1CF7-1CFF1DE7-1DFB1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F209D-209F20BA-20CF20F1-20FF218A-218F23F4-23FF2427-243F244B-245F27002B4D-2B4F2B5A-2BFF2C2F2C5F2CF4-2CF82D262D28-2D2C2D2E2D2F2D68-2D6E2D71-2D7E2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E3C-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31BB-31BF31E4-31EF321F32FF4DB6-4DBF9FCD-9FFFA48D-A48FA4C7-A4CFA62C-A63FA698-A69EA6F8-A6FFA78FA794-A79FA7AB-A7F7A82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAF7-AB00AB07AB08AB0FAB10AB17-AB1FAB27AB2F-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBC2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF",
	        Cc: "0000-001F007F-009F",
	        Cf: "00AD0600-060406DD070F200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB",
	        Co: "E000-F8FF",
	        Cs: "D800-DFFF",
	        Cn: "03780379037F-0383038B038D03A20528-05300557055805600588058B-058E059005C8-05CF05EB-05EF05F5-05FF0605061C061D070E074B074C07B2-07BF07FB-07FF082E082F083F085C085D085F-089F08A108AD-08E308FF097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B78-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D3B0D3C0D450D490D4F-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EE0-0EFF0F480F6D-0F700F980FBD0FCD0FDB-0FFF10C610C8-10CC10CE10CF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B135C137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BF4-1BFB1C38-1C3A1C4A-1C4C1C80-1CBF1CC8-1CCF1CF7-1CFF1DE7-1DFB1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F209D-209F20BA-20CF20F1-20FF218A-218F23F4-23FF2427-243F244B-245F27002B4D-2B4F2B5A-2BFF2C2F2C5F2CF4-2CF82D262D28-2D2C2D2E2D2F2D68-2D6E2D71-2D7E2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E3C-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31BB-31BF31E4-31EF321F32FF4DB6-4DBF9FCD-9FFFA48D-A48FA4C7-A4CFA62C-A63FA698-A69EA6F8-A6FFA78FA794-A79FA7AB-A7F7A82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAF7-AB00AB07AB08AB0FAB10AB17-AB1FAB27AB2F-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBC2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF"
	    }, {
	        //L: "Letter", // Included in the Unicode Base addon
	        Ll: "Lowercase_Letter",
	        Lu: "Uppercase_Letter",
	        Lt: "Titlecase_Letter",
	        Lm: "Modifier_Letter",
	        Lo: "Other_Letter",
	        M: "Mark",
	        Mn: "Nonspacing_Mark",
	        Mc: "Spacing_Mark",
	        Me: "Enclosing_Mark",
	        N: "Number",
	        Nd: "Decimal_Number",
	        Nl: "Letter_Number",
	        No: "Other_Number",
	        P: "Punctuation",
	        Pd: "Dash_Punctuation",
	        Ps: "Open_Punctuation",
	        Pe: "Close_Punctuation",
	        Pi: "Initial_Punctuation",
	        Pf: "Final_Punctuation",
	        Pc: "Connector_Punctuation",
	        Po: "Other_Punctuation",
	        S: "Symbol",
	        Sm: "Math_Symbol",
	        Sc: "Currency_Symbol",
	        Sk: "Modifier_Symbol",
	        So: "Other_Symbol",
	        Z: "Separator",
	        Zs: "Space_Separator",
	        Zl: "Line_Separator",
	        Zp: "Paragraph_Separator",
	        C: "Other",
	        Cc: "Control",
	        Cf: "Format",
	        Co: "Private_Use",
	        Cs: "Surrogate",
	        Cn: "Unassigned"
	    });

	}(XRegExp));


	/***** unicode-scripts.js *****/

	/*!
	 * XRegExp Unicode Scripts v1.2.0
	 * (c) 2010-2012 Steven Levithan <http://xregexp.com/>
	 * MIT License
	 * Uses Unicode 6.1 <http://unicode.org/>
	 */

	/**
	 * Adds support for all Unicode scripts in the Basic Multilingual Plane (U+0000-U+FFFF).
	 * E.g., `\p{Latin}`. Token names are case insensitive, and any spaces, hyphens, and underscores
	 * are ignored.
	 * @requires XRegExp, XRegExp Unicode Base
	 */
	(function (XRegExp) {
	    "use strict";

	    if (!XRegExp.addUnicodePackage) {
	        throw new ReferenceError("Unicode Base must be loaded before Unicode Scripts");
	    }

	    XRegExp.install("extensibility");

	    XRegExp.addUnicodePackage({
	        Arabic: "0600-06040606-060B060D-061A061E0620-063F0641-064A0656-065E066A-066F0671-06DC06DE-06FF0750-077F08A008A2-08AC08E4-08FEFB50-FBC1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFCFE70-FE74FE76-FEFC",
	        Armenian: "0531-05560559-055F0561-0587058A058FFB13-FB17",
	        Balinese: "1B00-1B4B1B50-1B7C",
	        Bamum: "A6A0-A6F7",
	        Batak: "1BC0-1BF31BFC-1BFF",
	        Bengali: "0981-09830985-098C098F09900993-09A809AA-09B009B209B6-09B909BC-09C409C709C809CB-09CE09D709DC09DD09DF-09E309E6-09FB",
	        Bopomofo: "02EA02EB3105-312D31A0-31BA",
	        Braille: "2800-28FF",
	        Buginese: "1A00-1A1B1A1E1A1F",
	        Buhid: "1740-1753",
	        Canadian_Aboriginal: "1400-167F18B0-18F5",
	        Cham: "AA00-AA36AA40-AA4DAA50-AA59AA5C-AA5F",
	        Cherokee: "13A0-13F4",
	        Common: "0000-0040005B-0060007B-00A900AB-00B900BB-00BF00D700F702B9-02DF02E5-02E902EC-02FF0374037E038503870589060C061B061F06400660-066906DD096409650E3F0FD5-0FD810FB16EB-16ED173517361802180318051CD31CE11CE9-1CEC1CEE-1CF31CF51CF62000-200B200E-2064206A-20702074-207E2080-208E20A0-20B92100-21252127-2129212C-21312133-214D214F-215F21892190-23F32400-24262440-244A2460-26FF2701-27FF2900-2B4C2B50-2B592E00-2E3B2FF0-2FFB3000-300430063008-30203030-3037303C-303F309B309C30A030FB30FC3190-319F31C0-31E33220-325F327F-32CF3358-33FF4DC0-4DFFA700-A721A788-A78AA830-A839FD3EFD3FFDFDFE10-FE19FE30-FE52FE54-FE66FE68-FE6BFEFFFF01-FF20FF3B-FF40FF5B-FF65FF70FF9EFF9FFFE0-FFE6FFE8-FFEEFFF9-FFFD",
	        Coptic: "03E2-03EF2C80-2CF32CF9-2CFF",
	        Cyrillic: "0400-04840487-05271D2B1D782DE0-2DFFA640-A697A69F",
	        Devanagari: "0900-09500953-09630966-09770979-097FA8E0-A8FB",
	        Ethiopic: "1200-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A135D-137C1380-13992D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDEAB01-AB06AB09-AB0EAB11-AB16AB20-AB26AB28-AB2E",
	        Georgian: "10A0-10C510C710CD10D0-10FA10FC-10FF2D00-2D252D272D2D",
	        Glagolitic: "2C00-2C2E2C30-2C5E",
	        Greek: "0370-03730375-0377037A-037D038403860388-038A038C038E-03A103A3-03E103F0-03FF1D26-1D2A1D5D-1D611D66-1D6A1DBF1F00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FC41FC6-1FD31FD6-1FDB1FDD-1FEF1FF2-1FF41FF6-1FFE2126",
	        Gujarati: "0A81-0A830A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABC-0AC50AC7-0AC90ACB-0ACD0AD00AE0-0AE30AE6-0AF1",
	        Gurmukhi: "0A01-0A030A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A3C0A3E-0A420A470A480A4B-0A4D0A510A59-0A5C0A5E0A66-0A75",
	        Han: "2E80-2E992E9B-2EF32F00-2FD5300530073021-30293038-303B3400-4DB54E00-9FCCF900-FA6DFA70-FAD9",
	        Hangul: "1100-11FF302E302F3131-318E3200-321E3260-327EA960-A97CAC00-D7A3D7B0-D7C6D7CB-D7FBFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
	        Hanunoo: "1720-1734",
	        Hebrew: "0591-05C705D0-05EA05F0-05F4FB1D-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FB4F",
	        Hiragana: "3041-3096309D-309F",
	        Inherited: "0300-036F04850486064B-0655065F0670095109521CD0-1CD21CD4-1CE01CE2-1CE81CED1CF41DC0-1DE61DFC-1DFF200C200D20D0-20F0302A-302D3099309AFE00-FE0FFE20-FE26",
	        Javanese: "A980-A9CDA9CF-A9D9A9DEA9DF",
	        Kannada: "0C820C830C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBC-0CC40CC6-0CC80CCA-0CCD0CD50CD60CDE0CE0-0CE30CE6-0CEF0CF10CF2",
	        Katakana: "30A1-30FA30FD-30FF31F0-31FF32D0-32FE3300-3357FF66-FF6FFF71-FF9D",
	        Kayah_Li: "A900-A92F",
	        Khmer: "1780-17DD17E0-17E917F0-17F919E0-19FF",
	        Lao: "0E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB90EBB-0EBD0EC0-0EC40EC60EC8-0ECD0ED0-0ED90EDC-0EDF",
	        Latin: "0041-005A0061-007A00AA00BA00C0-00D600D8-00F600F8-02B802E0-02E41D00-1D251D2C-1D5C1D62-1D651D6B-1D771D79-1DBE1E00-1EFF2071207F2090-209C212A212B2132214E2160-21882C60-2C7FA722-A787A78B-A78EA790-A793A7A0-A7AAA7F8-A7FFFB00-FB06FF21-FF3AFF41-FF5A",
	        Lepcha: "1C00-1C371C3B-1C491C4D-1C4F",
	        Limbu: "1900-191C1920-192B1930-193B19401944-194F",
	        Lisu: "A4D0-A4FF",
	        Malayalam: "0D020D030D05-0D0C0D0E-0D100D12-0D3A0D3D-0D440D46-0D480D4A-0D4E0D570D60-0D630D66-0D750D79-0D7F",
	        Mandaic: "0840-085B085E",
	        Meetei_Mayek: "AAE0-AAF6ABC0-ABEDABF0-ABF9",
	        Mongolian: "1800180118041806-180E1810-18191820-18771880-18AA",
	        Myanmar: "1000-109FAA60-AA7B",
	        New_Tai_Lue: "1980-19AB19B0-19C919D0-19DA19DE19DF",
	        Nko: "07C0-07FA",
	        Ogham: "1680-169C",
	        Ol_Chiki: "1C50-1C7F",
	        Oriya: "0B01-0B030B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3C-0B440B470B480B4B-0B4D0B560B570B5C0B5D0B5F-0B630B66-0B77",
	        Phags_Pa: "A840-A877",
	        Rejang: "A930-A953A95F",
	        Runic: "16A0-16EA16EE-16F0",
	        Samaritan: "0800-082D0830-083E",
	        Saurashtra: "A880-A8C4A8CE-A8D9",
	        Sinhala: "0D820D830D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60DCA0DCF-0DD40DD60DD8-0DDF0DF2-0DF4",
	        Sundanese: "1B80-1BBF1CC0-1CC7",
	        Syloti_Nagri: "A800-A82B",
	        Syriac: "0700-070D070F-074A074D-074F",
	        Tagalog: "1700-170C170E-1714",
	        Tagbanwa: "1760-176C176E-177017721773",
	        Tai_Le: "1950-196D1970-1974",
	        Tai_Tham: "1A20-1A5E1A60-1A7C1A7F-1A891A90-1A991AA0-1AAD",
	        Tai_Viet: "AA80-AAC2AADB-AADF",
	        Tamil: "0B820B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BBE-0BC20BC6-0BC80BCA-0BCD0BD00BD70BE6-0BFA",
	        Telugu: "0C01-0C030C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D-0C440C46-0C480C4A-0C4D0C550C560C580C590C60-0C630C66-0C6F0C78-0C7F",
	        Thaana: "0780-07B1",
	        Thai: "0E01-0E3A0E40-0E5B",
	        Tibetan: "0F00-0F470F49-0F6C0F71-0F970F99-0FBC0FBE-0FCC0FCE-0FD40FD90FDA",
	        Tifinagh: "2D30-2D672D6F2D702D7F",
	        Vai: "A500-A62B",
	        Yi: "A000-A48CA490-A4C6"
	    });

	}(XRegExp));


	/***** unicode-blocks.js *****/

	/*!
	 * XRegExp Unicode Blocks v1.2.0
	 * (c) 2010-2012 Steven Levithan <http://xregexp.com/>
	 * MIT License
	 * Uses Unicode 6.1 <http://unicode.org/>
	 */

	/**
	 * Adds support for all Unicode blocks in the Basic Multilingual Plane (U+0000-U+FFFF). Unicode
	 * blocks use the prefix "In". E.g., `\p{InBasicLatin}`. Token names are case insensitive, and any
	 * spaces, hyphens, and underscores are ignored.
	 * @requires XRegExp, XRegExp Unicode Base
	 */
	(function (XRegExp) {
	    "use strict";

	    if (!XRegExp.addUnicodePackage) {
	        throw new ReferenceError("Unicode Base must be loaded before Unicode Blocks");
	    }

	    XRegExp.install("extensibility");

	    XRegExp.addUnicodePackage({
	        InBasic_Latin: "0000-007F",
	        InLatin_1_Supplement: "0080-00FF",
	        InLatin_Extended_A: "0100-017F",
	        InLatin_Extended_B: "0180-024F",
	        InIPA_Extensions: "0250-02AF",
	        InSpacing_Modifier_Letters: "02B0-02FF",
	        InCombining_Diacritical_Marks: "0300-036F",
	        InGreek_and_Coptic: "0370-03FF",
	        InCyrillic: "0400-04FF",
	        InCyrillic_Supplement: "0500-052F",
	        InArmenian: "0530-058F",
	        InHebrew: "0590-05FF",
	        InArabic: "0600-06FF",
	        InSyriac: "0700-074F",
	        InArabic_Supplement: "0750-077F",
	        InThaana: "0780-07BF",
	        InNKo: "07C0-07FF",
	        InSamaritan: "0800-083F",
	        InMandaic: "0840-085F",
	        InArabic_Extended_A: "08A0-08FF",
	        InDevanagari: "0900-097F",
	        InBengali: "0980-09FF",
	        InGurmukhi: "0A00-0A7F",
	        InGujarati: "0A80-0AFF",
	        InOriya: "0B00-0B7F",
	        InTamil: "0B80-0BFF",
	        InTelugu: "0C00-0C7F",
	        InKannada: "0C80-0CFF",
	        InMalayalam: "0D00-0D7F",
	        InSinhala: "0D80-0DFF",
	        InThai: "0E00-0E7F",
	        InLao: "0E80-0EFF",
	        InTibetan: "0F00-0FFF",
	        InMyanmar: "1000-109F",
	        InGeorgian: "10A0-10FF",
	        InHangul_Jamo: "1100-11FF",
	        InEthiopic: "1200-137F",
	        InEthiopic_Supplement: "1380-139F",
	        InCherokee: "13A0-13FF",
	        InUnified_Canadian_Aboriginal_Syllabics: "1400-167F",
	        InOgham: "1680-169F",
	        InRunic: "16A0-16FF",
	        InTagalog: "1700-171F",
	        InHanunoo: "1720-173F",
	        InBuhid: "1740-175F",
	        InTagbanwa: "1760-177F",
	        InKhmer: "1780-17FF",
	        InMongolian: "1800-18AF",
	        InUnified_Canadian_Aboriginal_Syllabics_Extended: "18B0-18FF",
	        InLimbu: "1900-194F",
	        InTai_Le: "1950-197F",
	        InNew_Tai_Lue: "1980-19DF",
	        InKhmer_Symbols: "19E0-19FF",
	        InBuginese: "1A00-1A1F",
	        InTai_Tham: "1A20-1AAF",
	        InBalinese: "1B00-1B7F",
	        InSundanese: "1B80-1BBF",
	        InBatak: "1BC0-1BFF",
	        InLepcha: "1C00-1C4F",
	        InOl_Chiki: "1C50-1C7F",
	        InSundanese_Supplement: "1CC0-1CCF",
	        InVedic_Extensions: "1CD0-1CFF",
	        InPhonetic_Extensions: "1D00-1D7F",
	        InPhonetic_Extensions_Supplement: "1D80-1DBF",
	        InCombining_Diacritical_Marks_Supplement: "1DC0-1DFF",
	        InLatin_Extended_Additional: "1E00-1EFF",
	        InGreek_Extended: "1F00-1FFF",
	        InGeneral_Punctuation: "2000-206F",
	        InSuperscripts_and_Subscripts: "2070-209F",
	        InCurrency_Symbols: "20A0-20CF",
	        InCombining_Diacritical_Marks_for_Symbols: "20D0-20FF",
	        InLetterlike_Symbols: "2100-214F",
	        InNumber_Forms: "2150-218F",
	        InArrows: "2190-21FF",
	        InMathematical_Operators: "2200-22FF",
	        InMiscellaneous_Technical: "2300-23FF",
	        InControl_Pictures: "2400-243F",
	        InOptical_Character_Recognition: "2440-245F",
	        InEnclosed_Alphanumerics: "2460-24FF",
	        InBox_Drawing: "2500-257F",
	        InBlock_Elements: "2580-259F",
	        InGeometric_Shapes: "25A0-25FF",
	        InMiscellaneous_Symbols: "2600-26FF",
	        InDingbats: "2700-27BF",
	        InMiscellaneous_Mathematical_Symbols_A: "27C0-27EF",
	        InSupplemental_Arrows_A: "27F0-27FF",
	        InBraille_Patterns: "2800-28FF",
	        InSupplemental_Arrows_B: "2900-297F",
	        InMiscellaneous_Mathematical_Symbols_B: "2980-29FF",
	        InSupplemental_Mathematical_Operators: "2A00-2AFF",
	        InMiscellaneous_Symbols_and_Arrows: "2B00-2BFF",
	        InGlagolitic: "2C00-2C5F",
	        InLatin_Extended_C: "2C60-2C7F",
	        InCoptic: "2C80-2CFF",
	        InGeorgian_Supplement: "2D00-2D2F",
	        InTifinagh: "2D30-2D7F",
	        InEthiopic_Extended: "2D80-2DDF",
	        InCyrillic_Extended_A: "2DE0-2DFF",
	        InSupplemental_Punctuation: "2E00-2E7F",
	        InCJK_Radicals_Supplement: "2E80-2EFF",
	        InKangxi_Radicals: "2F00-2FDF",
	        InIdeographic_Description_Characters: "2FF0-2FFF",
	        InCJK_Symbols_and_Punctuation: "3000-303F",
	        InHiragana: "3040-309F",
	        InKatakana: "30A0-30FF",
	        InBopomofo: "3100-312F",
	        InHangul_Compatibility_Jamo: "3130-318F",
	        InKanbun: "3190-319F",
	        InBopomofo_Extended: "31A0-31BF",
	        InCJK_Strokes: "31C0-31EF",
	        InKatakana_Phonetic_Extensions: "31F0-31FF",
	        InEnclosed_CJK_Letters_and_Months: "3200-32FF",
	        InCJK_Compatibility: "3300-33FF",
	        InCJK_Unified_Ideographs_Extension_A: "3400-4DBF",
	        InYijing_Hexagram_Symbols: "4DC0-4DFF",
	        InCJK_Unified_Ideographs: "4E00-9FFF",
	        InYi_Syllables: "A000-A48F",
	        InYi_Radicals: "A490-A4CF",
	        InLisu: "A4D0-A4FF",
	        InVai: "A500-A63F",
	        InCyrillic_Extended_B: "A640-A69F",
	        InBamum: "A6A0-A6FF",
	        InModifier_Tone_Letters: "A700-A71F",
	        InLatin_Extended_D: "A720-A7FF",
	        InSyloti_Nagri: "A800-A82F",
	        InCommon_Indic_Number_Forms: "A830-A83F",
	        InPhags_pa: "A840-A87F",
	        InSaurashtra: "A880-A8DF",
	        InDevanagari_Extended: "A8E0-A8FF",
	        InKayah_Li: "A900-A92F",
	        InRejang: "A930-A95F",
	        InHangul_Jamo_Extended_A: "A960-A97F",
	        InJavanese: "A980-A9DF",
	        InCham: "AA00-AA5F",
	        InMyanmar_Extended_A: "AA60-AA7F",
	        InTai_Viet: "AA80-AADF",
	        InMeetei_Mayek_Extensions: "AAE0-AAFF",
	        InEthiopic_Extended_A: "AB00-AB2F",
	        InMeetei_Mayek: "ABC0-ABFF",
	        InHangul_Syllables: "AC00-D7AF",
	        InHangul_Jamo_Extended_B: "D7B0-D7FF",
	        InHigh_Surrogates: "D800-DB7F",
	        InHigh_Private_Use_Surrogates: "DB80-DBFF",
	        InLow_Surrogates: "DC00-DFFF",
	        InPrivate_Use_Area: "E000-F8FF",
	        InCJK_Compatibility_Ideographs: "F900-FAFF",
	        InAlphabetic_Presentation_Forms: "FB00-FB4F",
	        InArabic_Presentation_Forms_A: "FB50-FDFF",
	        InVariation_Selectors: "FE00-FE0F",
	        InVertical_Forms: "FE10-FE1F",
	        InCombining_Half_Marks: "FE20-FE2F",
	        InCJK_Compatibility_Forms: "FE30-FE4F",
	        InSmall_Form_Variants: "FE50-FE6F",
	        InArabic_Presentation_Forms_B: "FE70-FEFF",
	        InHalfwidth_and_Fullwidth_Forms: "FF00-FFEF",
	        InSpecials: "FFF0-FFFF"
	    });

	}(XRegExp));


	/***** unicode-properties.js *****/

	/*!
	 * XRegExp Unicode Properties v1.0.0
	 * (c) 2012 Steven Levithan <http://xregexp.com/>
	 * MIT License
	 * Uses Unicode 6.1 <http://unicode.org/>
	 */

	/**
	 * Adds Unicode properties necessary to meet Level 1 Unicode support (detailed in UTS#18 RL1.2).
	 * Includes code points from the Basic Multilingual Plane (U+0000-U+FFFF) only. Token names are
	 * case insensitive, and any spaces, hyphens, and underscores are ignored.
	 * @requires XRegExp, XRegExp Unicode Base
	 */
	(function (XRegExp) {
	    "use strict";

	    if (!XRegExp.addUnicodePackage) {
	        throw new ReferenceError("Unicode Base must be loaded before Unicode Properties");
	    }

	    XRegExp.install("extensibility");

	    XRegExp.addUnicodePackage({
	        Alphabetic: "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE03450370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05270531-055605590561-058705B0-05BD05BF05C105C205C405C505C705D0-05EA05F0-05F20610-061A0620-06570659-065F066E-06D306D5-06DC06E1-06E806ED-06EF06FA-06FC06FF0710-073F074D-07B107CA-07EA07F407F507FA0800-0817081A-082C0840-085808A008A2-08AC08E4-08E908F0-08FE0900-093B093D-094C094E-09500955-09630971-09770979-097F0981-09830985-098C098F09900993-09A809AA-09B009B209B6-09B909BD-09C409C709C809CB09CC09CE09D709DC09DD09DF-09E309F009F10A01-0A030A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A3E-0A420A470A480A4B0A4C0A510A59-0A5C0A5E0A70-0A750A81-0A830A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD-0AC50AC7-0AC90ACB0ACC0AD00AE0-0AE30B01-0B030B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D-0B440B470B480B4B0B4C0B560B570B5C0B5D0B5F-0B630B710B820B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BBE-0BC20BC6-0BC80BCA-0BCC0BD00BD70C01-0C030C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D-0C440C46-0C480C4A-0C4C0C550C560C580C590C60-0C630C820C830C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD-0CC40CC6-0CC80CCA-0CCC0CD50CD60CDE0CE0-0CE30CF10CF20D020D030D05-0D0C0D0E-0D100D12-0D3A0D3D-0D440D46-0D480D4A-0D4C0D4E0D570D60-0D630D7A-0D7F0D820D830D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60DCF-0DD40DD60DD8-0DDF0DF20DF30E01-0E3A0E40-0E460E4D0E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB90EBB-0EBD0EC0-0EC40EC60ECD0EDC-0EDF0F000F40-0F470F49-0F6C0F71-0F810F88-0F970F99-0FBC1000-10361038103B-103F1050-10621065-1068106E-1086108E109C109D10A0-10C510C710CD10D0-10FA10FC-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A135F1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA16EE-16F01700-170C170E-17131720-17331740-17531760-176C176E-1770177217731780-17B317B6-17C817D717DC1820-18771880-18AA18B0-18F51900-191C1920-192B1930-19381950-196D1970-19741980-19AB19B0-19C91A00-1A1B1A20-1A5E1A61-1A741AA71B00-1B331B35-1B431B45-1B4B1B80-1BA91BAC-1BAF1BBA-1BE51BE7-1BF11C00-1C351C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF31CF51CF61D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209C21022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E2160-218824B6-24E92C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2CF22CF32D00-2D252D272D2D2D30-2D672D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2DE0-2DFF2E2F3005-30073021-30293031-30353038-303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31BA31F0-31FF3400-4DB54E00-9FCCA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A66EA674-A67BA67F-A697A69F-A6EFA717-A71FA722-A788A78B-A78EA790-A793A7A0-A7AAA7F8-A801A803-A805A807-A80AA80C-A827A840-A873A880-A8C3A8F2-A8F7A8FBA90A-A92AA930-A952A960-A97CA980-A9B2A9B4-A9BFA9CFAA00-AA36AA40-AA4DAA60-AA76AA7AAA80-AABEAAC0AAC2AADB-AADDAAE0-AAEFAAF2-AAF5AB01-AB06AB09-AB0EAB11-AB16AB20-AB26AB28-AB2EABC0-ABEAAC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1D-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
	        Uppercase: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E05200522052405260531-055610A0-10C510C710CD1E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F21452160-216F218324B6-24CF2C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CED2CF2A640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA660A662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BA78DA790A792A7A0A7A2A7A4A7A6A7A8A7AAFF21-FF3A",
	        Lowercase: "0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02B802C002C102E0-02E40345037103730377037A-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F05210523052505270561-05871D00-1DBF1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF72071207F2090-209C210A210E210F2113212F21342139213C213D2146-2149214E2170-217F218424D0-24E92C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7D2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2CF32D00-2D252D272D2DA641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA661A663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76F-A778A77AA77CA77FA781A783A785A787A78CA78EA791A793A7A1A7A3A7A5A7A7A7A9A7F8-A7FAFB00-FB06FB13-FB17FF41-FF5A",
	        White_Space: "0009-000D0020008500A01680180E2000-200A20282029202F205F3000",
	        Noncharacter_Code_Point: "FDD0-FDEFFFFEFFFF",
	        Default_Ignorable_Code_Point: "00AD034F115F116017B417B5180B-180D200B-200F202A-202E2060-206F3164FE00-FE0FFEFFFFA0FFF0-FFF8",
	        // \p{Any} matches a code unit. To match any code point via surrogate pairs, use (?:[\0-\uD7FF\uDC00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF])
	        Any: "0000-FFFF", // \p{^Any} compiles to [^\u0000-\uFFFF]; [\p{^Any}] to []
	        Ascii: "0000-007F",
	        // \p{Assigned} is equivalent to \p{^Cn}
	        //Assigned: XRegExp("[\\p{^Cn}]").source.replace(/[[\]]|\\u/g, "") // Negation inside a character class triggers inversion
	        Assigned: "0000-0377037A-037E0384-038A038C038E-03A103A3-05270531-05560559-055F0561-05870589058A058F0591-05C705D0-05EA05F0-05F40600-06040606-061B061E-070D070F-074A074D-07B107C0-07FA0800-082D0830-083E0840-085B085E08A008A2-08AC08E4-08FE0900-09770979-097F0981-09830985-098C098F09900993-09A809AA-09B009B209B6-09B909BC-09C409C709C809CB-09CE09D709DC09DD09DF-09E309E6-09FB0A01-0A030A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A3C0A3E-0A420A470A480A4B-0A4D0A510A59-0A5C0A5E0A66-0A750A81-0A830A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABC-0AC50AC7-0AC90ACB-0ACD0AD00AE0-0AE30AE6-0AF10B01-0B030B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3C-0B440B470B480B4B-0B4D0B560B570B5C0B5D0B5F-0B630B66-0B770B820B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BBE-0BC20BC6-0BC80BCA-0BCD0BD00BD70BE6-0BFA0C01-0C030C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D-0C440C46-0C480C4A-0C4D0C550C560C580C590C60-0C630C66-0C6F0C78-0C7F0C820C830C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBC-0CC40CC6-0CC80CCA-0CCD0CD50CD60CDE0CE0-0CE30CE6-0CEF0CF10CF20D020D030D05-0D0C0D0E-0D100D12-0D3A0D3D-0D440D46-0D480D4A-0D4E0D570D60-0D630D66-0D750D79-0D7F0D820D830D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60DCA0DCF-0DD40DD60DD8-0DDF0DF2-0DF40E01-0E3A0E3F-0E5B0E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB90EBB-0EBD0EC0-0EC40EC60EC8-0ECD0ED0-0ED90EDC-0EDF0F00-0F470F49-0F6C0F71-0F970F99-0FBC0FBE-0FCC0FCE-0FDA1000-10C510C710CD10D0-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A135D-137C1380-139913A0-13F41400-169C16A0-16F01700-170C170E-17141720-17361740-17531760-176C176E-1770177217731780-17DD17E0-17E917F0-17F91800-180E1810-18191820-18771880-18AA18B0-18F51900-191C1920-192B1930-193B19401944-196D1970-19741980-19AB19B0-19C919D0-19DA19DE-1A1B1A1E-1A5E1A60-1A7C1A7F-1A891A90-1A991AA0-1AAD1B00-1B4B1B50-1B7C1B80-1BF31BFC-1C371C3B-1C491C4D-1C7F1CC0-1CC71CD0-1CF61D00-1DE61DFC-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FC41FC6-1FD31FD6-1FDB1FDD-1FEF1FF2-1FF41FF6-1FFE2000-2064206A-20712074-208E2090-209C20A0-20B920D0-20F02100-21892190-23F32400-24262440-244A2460-26FF2701-2B4C2B50-2B592C00-2C2E2C30-2C5E2C60-2CF32CF9-2D252D272D2D2D30-2D672D6F2D702D7F-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2DE0-2E3B2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB3000-303F3041-30963099-30FF3105-312D3131-318E3190-31BA31C0-31E331F0-321E3220-32FE3300-4DB54DC0-9FCCA000-A48CA490-A4C6A4D0-A62BA640-A697A69F-A6F7A700-A78EA790-A793A7A0-A7AAA7F8-A82BA830-A839A840-A877A880-A8C4A8CE-A8D9A8E0-A8FBA900-A953A95F-A97CA980-A9CDA9CF-A9D9A9DEA9DFAA00-AA36AA40-AA4DAA50-AA59AA5C-AA7BAA80-AAC2AADB-AAF6AB01-AB06AB09-AB0EAB11-AB16AB20-AB26AB28-AB2EABC0-ABEDABF0-ABF9AC00-D7A3D7B0-D7C6D7CB-D7FBD800-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1D-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBC1FBD3-FD3FFD50-FD8FFD92-FDC7FDF0-FDFDFE00-FE19FE20-FE26FE30-FE52FE54-FE66FE68-FE6BFE70-FE74FE76-FEFCFEFFFF01-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDCFFE0-FFE6FFE8-FFEEFFF9-FFFD"
	    });

	}(XRegExp));


	/***** matchrecursive.js *****/

	/*!
	 * XRegExp.matchRecursive v0.2.0
	 * (c) 2009-2012 Steven Levithan <http://xregexp.com/>
	 * MIT License
	 */

	(function (XRegExp) {
	    "use strict";

	/**
	 * Returns a match detail object composed of the provided values.
	 * @private
	 */
	    function row(value, name, start, end) {
	        return {value:value, name:name, start:start, end:end};
	    }

	/**
	 * Returns an array of match strings between outermost left and right delimiters, or an array of
	 * objects with detailed match parts and position data. An error is thrown if delimiters are
	 * unbalanced within the data.
	 * @memberOf XRegExp
	 * @param {String} str String to search.
	 * @param {String} left Left delimiter as an XRegExp pattern.
	 * @param {String} right Right delimiter as an XRegExp pattern.
	 * @param {String} [flags] Flags for the left and right delimiters. Use any of: `gimnsxy`.
	 * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.
	 * @returns {Array} Array of matches, or an empty array.
	 * @example
	 *
	 * // Basic usage
	 * var str = '(t((e))s)t()(ing)';
	 * XRegExp.matchRecursive(str, '\\(', '\\)', 'g');
	 * // -> ['t((e))s', '', 'ing']
	 *
	 * // Extended information mode with valueNames
	 * str = 'Here is <div> <div>an</div></div> example';
	 * XRegExp.matchRecursive(str, '<div\\s*>', '</div>', 'gi', {
	 *   valueNames: ['between', 'left', 'match', 'right']
	 * });
	 * // -> [
	 * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},
	 * // {name: 'left',    value: '<div>',          start: 8,  end: 13},
	 * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},
	 * // {name: 'right',   value: '</div>',         start: 27, end: 33},
	 * // {name: 'between', value: ' example',       start: 33, end: 41}
	 * // ]
	 *
	 * // Omitting unneeded parts with null valueNames, and using escapeChar
	 * str = '...{1}\\{{function(x,y){return y+x;}}';
	 * XRegExp.matchRecursive(str, '{', '}', 'g', {
	 *   valueNames: ['literal', null, 'value', null],
	 *   escapeChar: '\\'
	 * });
	 * // -> [
	 * // {name: 'literal', value: '...', start: 0, end: 3},
	 * // {name: 'value',   value: '1',   start: 4, end: 5},
	 * // {name: 'literal', value: '\\{', start: 6, end: 8},
	 * // {name: 'value',   value: 'function(x,y){return y+x;}', start: 9, end: 35}
	 * // ]
	 *
	 * // Sticky mode via flag y
	 * str = '<1><<<2>>><3>4<5>';
	 * XRegExp.matchRecursive(str, '<', '>', 'gy');
	 * // -> ['1', '<<2>>', '3']
	 */
	    XRegExp.matchRecursive = function (str, left, right, flags, options) {
	        flags = flags || "";
	        options = options || {};
	        var global = flags.indexOf("g") > -1,
	            sticky = flags.indexOf("y") > -1,
	            basicFlags = flags.replace(/y/g, ""), // Flag y controlled internally
	            escapeChar = options.escapeChar,
	            vN = options.valueNames,
	            output = [],
	            openTokens = 0,
	            delimStart = 0,
	            delimEnd = 0,
	            lastOuterEnd = 0,
	            outerStart,
	            innerStart,
	            leftMatch,
	            rightMatch,
	            esc;
	        left = XRegExp(left, basicFlags);
	        right = XRegExp(right, basicFlags);

	        if (escapeChar) {
	            if (escapeChar.length > 1) {
	                throw new SyntaxError("can't use more than one escape character");
	            }
	            escapeChar = XRegExp.escape(escapeChar);
	            // Using XRegExp.union safely rewrites backreferences in `left` and `right`
	            esc = new RegExp(
	                "(?:" + escapeChar + "[\\S\\s]|(?:(?!" + XRegExp.union([left, right]).source + ")[^" + escapeChar + "])+)+",
	                flags.replace(/[^im]+/g, "") // Flags gy not needed here; flags nsx handled by XRegExp
	            );
	        }

	        while (true) {
	            // If using an escape character, advance to the delimiter's next starting position,
	            // skipping any escaped characters in between
	            if (escapeChar) {
	                delimEnd += (XRegExp.exec(str, esc, delimEnd, "sticky") || [""])[0].length;
	            }
	            leftMatch = XRegExp.exec(str, left, delimEnd);
	            rightMatch = XRegExp.exec(str, right, delimEnd);
	            // Keep the leftmost match only
	            if (leftMatch && rightMatch) {
	                if (leftMatch.index <= rightMatch.index) {
	                    rightMatch = null;
	                } else {
	                    leftMatch = null;
	                }
	            }
	            /* Paths (LM:leftMatch, RM:rightMatch, OT:openTokens):
	            LM | RM | OT | Result
	            1  | 0  | 1  | loop
	            1  | 0  | 0  | loop
	            0  | 1  | 1  | loop
	            0  | 1  | 0  | throw
	            0  | 0  | 1  | throw
	            0  | 0  | 0  | break
	            * Doesn't include the sticky mode special case
	            * Loop ends after the first completed match if `!global` */
	            if (leftMatch || rightMatch) {
	                delimStart = (leftMatch || rightMatch).index;
	                delimEnd = delimStart + (leftMatch || rightMatch)[0].length;
	            } else if (!openTokens) {
	                break;
	            }
	            if (sticky && !openTokens && delimStart > lastOuterEnd) {
	                break;
	            }
	            if (leftMatch) {
	                if (!openTokens) {
	                    outerStart = delimStart;
	                    innerStart = delimEnd;
	                }
	                ++openTokens;
	            } else if (rightMatch && openTokens) {
	                if (!--openTokens) {
	                    if (vN) {
	                        if (vN[0] && outerStart > lastOuterEnd) {
	                            output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));
	                        }
	                        if (vN[1]) {
	                            output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));
	                        }
	                        if (vN[2]) {
	                            output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));
	                        }
	                        if (vN[3]) {
	                            output.push(row(vN[3], str.slice(delimStart, delimEnd), delimStart, delimEnd));
	                        }
	                    } else {
	                        output.push(str.slice(innerStart, delimStart));
	                    }
	                    lastOuterEnd = delimEnd;
	                    if (!global) {
	                        break;
	                    }
	                }
	            } else {
	                throw new Error("string contains unbalanced delimiters");
	            }
	            // If the delimiter matched an empty string, avoid an infinite loop
	            if (delimStart === delimEnd) {
	                ++delimEnd;
	            }
	        }

	        if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {
	            output.push(row(vN[0], str.slice(lastOuterEnd), lastOuterEnd, str.length));
	        }

	        return output;
	    };

	}(XRegExp));


	/***** build.js *****/

	/*!
	 * XRegExp.build v0.1.0
	 * (c) 2012 Steven Levithan <http://xregexp.com/>
	 * MIT License
	 * Inspired by RegExp.create by Lea Verou <http://lea.verou.me/>
	 */

	(function (XRegExp) {
	    "use strict";

	    var subparts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*]/g,
	        parts = XRegExp.union([/\({{([\w$]+)}}\)|{{([\w$]+)}}/, subparts], "g");

	/**
	 * Strips a leading `^` and trailing unescaped `$`, if both are present.
	 * @private
	 * @param {String} pattern Pattern to process.
	 * @returns {String} Pattern with edge anchors removed.
	 */
	    function deanchor(pattern) {
	        var startAnchor = /^(?:\(\?:\))?\^/, // Leading `^` or `(?:)^` (handles /x cruft)
	            endAnchor = /\$(?:\(\?:\))?$/; // Trailing `$` or `$(?:)` (handles /x cruft)
	        if (endAnchor.test(pattern.replace(/\\[\s\S]/g, ""))) { // Ensure trailing `$` isn't escaped
	            return pattern.replace(startAnchor, "").replace(endAnchor, "");
	        }
	        return pattern;
	    }

	/**
	 * Converts the provided value to an XRegExp.
	 * @private
	 * @param {String|RegExp} value Value to convert.
	 * @returns {RegExp} XRegExp object with XRegExp syntax applied.
	 */
	    function asXRegExp(value) {
	        return XRegExp.isRegExp(value) ?
	                (value.xregexp && !value.xregexp.isNative ? value : XRegExp(value.source)) :
	                XRegExp(value);
	    }

	/**
	 * Builds regexes using named subpatterns, for readability and pattern reuse. Backreferences in the
	 * outer pattern and provided subpatterns are automatically renumbered to work correctly. Native
	 * flags used by provided subpatterns are ignored in favor of the `flags` argument.
	 * @memberOf XRegExp
	 * @param {String} pattern XRegExp pattern using `{{name}}` for embedded subpatterns. Allows
	 *   `({{name}})` as shorthand for `(?<name>{{name}})`. Patterns cannot be embedded within
	 *   character classes.
	 * @param {Object} subs Lookup object for named subpatterns. Values can be strings or regexes. A
	 *   leading `^` and trailing unescaped `$` are stripped from subpatterns, if both are present.
	 * @param {String} [flags] Any combination of XRegExp flags.
	 * @returns {RegExp} Regex with interpolated subpatterns.
	 * @example
	 *
	 * var time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {
	 *   hours: XRegExp.build('{{h12}} : | {{h24}}', {
	 *     h12: /1[0-2]|0?[1-9]/,
	 *     h24: /2[0-3]|[01][0-9]/
	 *   }, 'x'),
	 *   minutes: /^[0-5][0-9]$/
	 * });
	 * time.test('10:59'); // -> true
	 * XRegExp.exec('10:59', time).minutes; // -> '59'
	 */
	    XRegExp.build = function (pattern, subs, flags) {
	        var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern),
	            data = {},
	            numCaps = 0, // Caps is short for captures
	            numPriorCaps,
	            numOuterCaps = 0,
	            outerCapsMap = [0],
	            outerCapNames,
	            sub,
	            p;

	        // Add flags within a leading mode modifier to the overall pattern's flags
	        if (inlineFlags) {
	            flags = flags || "";
	            inlineFlags[1].replace(/./g, function (flag) {
	                flags += (flags.indexOf(flag) > -1 ? "" : flag); // Don't add duplicates
	            });
	        }

	        for (p in subs) {
	            if (subs.hasOwnProperty(p)) {
	                // Passing to XRegExp enables entended syntax for subpatterns provided as strings
	                // and ensures independent validity, lest an unescaped `(`, `)`, `[`, or trailing
	                // `\` breaks the `(?:)` wrapper. For subpatterns provided as regexes, it dies on
	                // octals and adds the `xregexp` property, for simplicity
	                sub = asXRegExp(subs[p]);
	                // Deanchoring allows embedding independently useful anchored regexes. If you
	                // really need to keep your anchors, double them (i.e., `^^...$$`)
	                data[p] = {pattern: deanchor(sub.source), names: sub.xregexp.captureNames || []};
	            }
	        }

	        // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;
	        // helps keep this simple. Named captures will be put back
	        pattern = asXRegExp(pattern);
	        outerCapNames = pattern.xregexp.captureNames || [];
	        pattern = pattern.source.replace(parts, function ($0, $1, $2, $3, $4) {
	            var subName = $1 || $2, capName, intro;
	            if (subName) { // Named subpattern
	                if (!data.hasOwnProperty(subName)) {
	                    throw new ReferenceError("undefined property " + $0);
	                }
	                if ($1) { // Named subpattern was wrapped in a capturing group
	                    capName = outerCapNames[numOuterCaps];
	                    outerCapsMap[++numOuterCaps] = ++numCaps;
	                    // If it's a named group, preserve the name. Otherwise, use the subpattern name
	                    // as the capture name
	                    intro = "(?<" + (capName || subName) + ">";
	                } else {
	                    intro = "(?:";
	                }
	                numPriorCaps = numCaps;
	                return intro + data[subName].pattern.replace(subparts, function (match, paren, backref) {
	                    if (paren) { // Capturing group
	                        capName = data[subName].names[numCaps - numPriorCaps];
	                        ++numCaps;
	                        if (capName) { // If the current capture has a name, preserve the name
	                            return "(?<" + capName + ">";
	                        }
	                    } else if (backref) { // Backreference
	                        return "\\" + (+backref + numPriorCaps); // Rewrite the backreference
	                    }
	                    return match;
	                }) + ")";
	            }
	            if ($3) { // Capturing group
	                capName = outerCapNames[numOuterCaps];
	                outerCapsMap[++numOuterCaps] = ++numCaps;
	                if (capName) { // If the current capture has a name, preserve the name
	                    return "(?<" + capName + ">";
	                }
	            } else if ($4) { // Backreference
	                return "\\" + outerCapsMap[+$4]; // Rewrite the backreference
	            }
	            return $0;
	        });

	        return XRegExp(pattern, flags);
	    };

	}(XRegExp));


	/***** prototypes.js *****/

	/*!
	 * XRegExp Prototype Methods v1.0.0
	 * (c) 2012 Steven Levithan <http://xregexp.com/>
	 * MIT License
	 */

	/**
	 * Adds a collection of methods to `XRegExp.prototype`. RegExp objects copied by XRegExp are also
	 * augmented with any `XRegExp.prototype` methods. Hence, the following work equivalently:
	 *
	 * XRegExp('[a-z]', 'ig').xexec('abc');
	 * XRegExp(/[a-z]/ig).xexec('abc');
	 * XRegExp.globalize(/[a-z]/i).xexec('abc');
	 */
	(function (XRegExp) {
	    "use strict";

	/**
	 * Copy properties of `b` to `a`.
	 * @private
	 * @param {Object} a Object that will receive new properties.
	 * @param {Object} b Object whose properties will be copied.
	 */
	    function extend(a, b) {
	        for (var p in b) {
	            if (b.hasOwnProperty(p)) {
	                a[p] = b[p];
	            }
	        }
	        //return a;
	    }

	    extend(XRegExp.prototype, {

	/**
	 * Implicitly calls the regex's `test` method with the first value in the provided arguments array.
	 * @memberOf XRegExp.prototype
	 * @param {*} context Ignored. Accepted only for congruity with `Function.prototype.apply`.
	 * @param {Array} args Array with the string to search as its first value.
	 * @returns {Boolean} Whether the regex matched the provided value.
	 * @example
	 *
	 * XRegExp('[a-z]').apply(null, ['abc']); // -> true
	 */
	        apply: function (context, args) {
	            return this.test(args[0]);
	        },

	/**
	 * Implicitly calls the regex's `test` method with the provided string.
	 * @memberOf XRegExp.prototype
	 * @param {*} context Ignored. Accepted only for congruity with `Function.prototype.call`.
	 * @param {String} str String to search.
	 * @returns {Boolean} Whether the regex matched the provided value.
	 * @example
	 *
	 * XRegExp('[a-z]').call(null, 'abc'); // -> true
	 */
	        call: function (context, str) {
	            return this.test(str);
	        },

	/**
	 * Implicitly calls {@link #XRegExp.forEach}.
	 * @memberOf XRegExp.prototype
	 * @example
	 *
	 * XRegExp('\\d').forEach('1a2345', function (match, i) {
	 *   if (i % 2) this.push(+match[0]);
	 * }, []);
	 * // -> [2, 4]
	 */
	        forEach: function (str, callback, context) {
	            return XRegExp.forEach(str, this, callback, context);
	        },

	/**
	 * Implicitly calls {@link #XRegExp.globalize}.
	 * @memberOf XRegExp.prototype
	 * @example
	 *
	 * var globalCopy = XRegExp('regex').globalize();
	 * globalCopy.global; // -> true
	 */
	        globalize: function () {
	            return XRegExp.globalize(this);
	        },

	/**
	 * Implicitly calls {@link #XRegExp.exec}.
	 * @memberOf XRegExp.prototype
	 * @example
	 *
	 * var match = XRegExp('U\\+(?<hex>[0-9A-F]{4})').xexec('U+2620');
	 * match.hex; // -> '2620'
	 */
	        xexec: function (str, pos, sticky) {
	            return XRegExp.exec(str, this, pos, sticky);
	        },

	/**
	 * Implicitly calls {@link #XRegExp.test}.
	 * @memberOf XRegExp.prototype
	 * @example
	 *
	 * XRegExp('c').xtest('abc'); // -> true
	 */
	        xtest: function (str, pos, sticky) {
	            return XRegExp.test(str, this, pos, sticky);
	        }

	    });

	}(XRegExp));



/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _path = __webpack_require__(1);

	var _path2 = _interopRequireDefault(_path);

	var _i18n2 = __webpack_require__(7);

	var _i18n3 = _interopRequireDefault(_i18n2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  i18n: function i18n() {
	    _i18n3.default.configure({
	      locales: ['en'],
	      directory: _path2.default.resolve(__dirname, '../../', 'locales'),
	      objectNotation: true,
	      logWarnFn: function logWarnFn(msg) {
	        console.warn('warn', msg);
	      }
	    });
	    _i18n3.default.setLocale('en');
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.allocContainerReq = exports.allocAuthReq = exports.allocCString = exports.allocAppHandlePointer = exports.ContainersReqPointer = exports.FfiResult = exports.ContainersReq = exports.AuthReqPointer = exports.AuthReq = exports.RegisteredAppPointer = exports.RegisteredApp = exports.ContainerPermissions = exports.Permission = exports.AppExchangeInfo = exports.AppHandlePointer = exports.voidPointer = exports.CString = exports.Null = exports.Void = exports.int32 = exports.bool = exports.usize = exports.u32 = exports.u8 = undefined;

	var _ref = __webpack_require__(28);

	var _ref2 = _interopRequireDefault(_ref);

	var _refStruct = __webpack_require__(29);

	var _refStruct2 = _interopRequireDefault(_refStruct);

	var _enum = __webpack_require__(31);

	var _enum2 = _interopRequireDefault(_enum);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var u8 = exports.u8 = _ref2.default.types.uint8;
	var u32 = exports.u32 = _ref2.default.types.uint32;
	var usize = exports.usize = _ref2.default.types.size_t;
	var bool = exports.bool = _ref2.default.types.bool;
	var int32 = exports.int32 = _ref2.default.types.int32;
	var Void = exports.Void = _ref2.default.types.void;
	var Null = exports.Null = _ref2.default.NULL;
	var CString = exports.CString = _ref2.default.types.CString;

	// Pointer Types
	var voidPointer = exports.voidPointer = _ref2.default.refType(Void);
	var AppHandlePointer = exports.AppHandlePointer = _ref2.default.refType(voidPointer);

	var AppExchangeInfo = exports.AppExchangeInfo = (0, _refStruct2.default)({
	  id: CString,
	  scope: CString,
	  name: CString,
	  vendor: CString
	});

	var Permission = exports.Permission = new _enum2.default({
	  Read: 0,
	  Insert: 1,
	  Update: 2,
	  Delete: 3,
	  ManagePermissions: 4
	});

	var ContainerPermissions = exports.ContainerPermissions = (0, _refStruct2.default)({
	  cont_name: CString,
	  access: _ref2.default.refType(Permission),
	  access_len: usize,
	  access_cap: usize
	});

	var RegisteredApp = exports.RegisteredApp = (0, _refStruct2.default)({
	  app_info: AppExchangeInfo,
	  containers: _ref2.default.refType(ContainerPermissions),
	  containers_len: usize,
	  containers_cap: usize
	});

	var RegisteredAppPointer = exports.RegisteredAppPointer = _ref2.default.refType(RegisteredApp);

	var AuthReq = exports.AuthReq = (0, _refStruct2.default)({
	  app: AppExchangeInfo,
	  app_container: bool,
	  containers: _ref2.default.refType(ContainerPermissions),
	  containers_len: usize,
	  containers_cap: usize
	});

	var AuthReqPointer = exports.AuthReqPointer = _ref2.default.refType(AuthReq);

	var ContainersReq = exports.ContainersReq = (0, _refStruct2.default)({
	  app: AppExchangeInfo,
	  containers: _ref2.default.refType(ContainerPermissions),
	  containers_len: usize,
	  containers_cap: usize
	});

	var FfiResult = exports.FfiResult = (0, _refStruct2.default)({
	  error_code: int32,
	  description: CString
	});

	var ContainersReqPointer = exports.ContainersReqPointer = _ref2.default.refType(ContainersReq);

	var allocAppHandlePointer = exports.allocAppHandlePointer = function allocAppHandlePointer() {
	  return _ref2.default.alloc(AppHandlePointer);
	};

	var allocCString = exports.allocCString = function allocCString(str) {
	  return _ref2.default.allocCString(str);
	};

	var allocAuthReq = exports.allocAuthReq = function allocAuthReq(req) {
	  return _ref2.default.alloc(AuthReq, req);
	};

	var allocContainerReq = exports.allocContainerReq = function allocContainerReq(req) {
	  return _ref2.default.alloc(ContainersReq, req);
		};

/***/ },
/* 28 */
/***/ function(module, exports) {

	module.exports = require("ref");

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * An interface for modeling and instantiating C-style data structures. This is
	 * not a constructor per-say, but a constructor generator. It takes an array of
	 * tuples, the left side being the type, and the right side being a field name.
	 * The order should be the same order it would appear in the C-style struct
	 * definition. It returns a function that can be used to construct an object that
	 * reads and writes to the data structure using properties specified by the
	 * initial field list.
	 *
	 * The only verboten field names are "ref", which is used used on struct
	 * instances as a function to retrieve the backing Buffer instance of the
	 * struct, and "ref.buffer" which contains the backing Buffer instance.
	 *
	 *
	 * Example:
	 *
	 * ``` javascript
	 * var ref = require('ref')
	 * var Struct = require('ref-struct')
	 *
	 * // create the `char *` type
	 * var charPtr = ref.refType(ref.types.char)
	 * var int = ref.types.int
	 *
	 * // create the struct "type" / constructor
	 * var PasswordEntry = Struct({
	 *     'username': 'string'
	 *   , 'password': 'string'
	 *   , 'salt':     int
	 * })
	 *
	 * // create an instance of the struct, backed a Buffer instance
	 * var pwd = new PasswordEntry()
	 * pwd.username = 'ricky'
	 * pwd.password = 'rbransonlovesnode.js'
	 * pwd.salt = (Math.random() * 1000000) | 0
	 *
	 * pwd.username // → 'ricky'
	 * pwd.password // → 'rbransonlovesnode.js'
	 * pwd.salt     // → 820088
	 * ```
	 */

	/**
	 * Module dependencies.
	 */

	var ref = __webpack_require__(28)
	var util = __webpack_require__(16)
	var assert = __webpack_require__(30)
	var debug = __webpack_require__(10)('ref:struct')

	/**
	 * Module exports.
	 */

	module.exports = Struct

	/**
	 * The Struct "type" meta-constructor.
	 */

	function Struct () {
	  debug('defining new struct "type"')

	  /**
	   * This is the "constructor" of the Struct type that gets returned.
	   *
	   * Invoke it with `new` to create a new Buffer instance backing the struct.
	   * Pass it an existing Buffer instance to use that as the backing buffer.
	   * Pass in an Object containing the struct fields to auto-populate the
	   * struct with the data.
	   */

	  function StructType (arg, data) {
	    if (!(this instanceof StructType)) {
	      return new StructType(arg, data)
	    }
	    debug('creating new struct instance')
	    var store
	    if (Buffer.isBuffer(arg)) {
	      debug('using passed-in Buffer instance to back the struct', arg)
	      assert(arg.length >= StructType.size, 'Buffer instance must be at least ' +
	          StructType.size + ' bytes to back this struct type')
	      store = arg
	      arg = data
	    } else {
	      debug('creating new Buffer instance to back the struct (size: %d)', StructType.size)
	      store = new Buffer(StructType.size)
	    }

	    // set the backing Buffer store
	    store.type = StructType
	    this['ref.buffer'] = store

	    if (arg) {
	      for (var key in arg) {
	        // hopefully hit the struct setters
	        this[key] = arg[key]
	      }
	    }
	    StructType._instanceCreated = true
	  }

	  // make instances inherit from the `proto`
	  StructType.prototype = Object.create(proto, {
	    constructor: {
	        value: StructType
	      , enumerable: false
	      , writable: true
	      , configurable: true
	    }
	  })

	  StructType.defineProperty = defineProperty
	  StructType.toString = toString
	  StructType.fields = {}

	  var opt = (arguments.length > 0 && arguments[1]) ? arguments[1] : {};
	  // Setup the ref "type" interface. The constructor doubles as the "type" object
	  StructType.size = 0
	  StructType.alignment = 0
	  StructType.indirection = 1
	  StructType.isPacked = opt.packed ? Boolean(opt.packed) : false
	  StructType.get = get
	  StructType.set = set

	  // Read the fields list and apply all the fields to the struct
	  // TODO: Better arg handling... (maybe look at ES6 binary data API?)
	  var arg = arguments[0]
	  if (Array.isArray(arg)) {
	    // legacy API
	    arg.forEach(function (a) {
	      var type = a[0]
	      var name = a[1]
	      StructType.defineProperty(name, type)
	    })
	  } else if (typeof arg === 'object') {
	    Object.keys(arg).forEach(function (name) {
	      var type = arg[name]
	      StructType.defineProperty(name, type)
	    })
	  }

	  return StructType
	}

	/**
	 * The "get" function of the Struct "type" interface
	 */

	function get (buffer, offset) {
	  debug('Struct "type" getter for buffer at offset', buffer, offset)
	  if (offset > 0) {
	    buffer = buffer.slice(offset)
	  }
	  return new this(buffer)
	}

	/**
	 * The "set" function of the Struct "type" interface
	 */

	function set (buffer, offset, value) {
	  debug('Struct "type" setter for buffer at offset', buffer, offset, value)
	  var isStruct = value instanceof this
	  if (isStruct) {
	    // optimization: copy the buffer contents directly rather
	    // than going through the ref-struct constructor
	    value['ref.buffer'].copy(buffer, offset, 0, this.size)
	  } else {
	    if (offset > 0) {
	      buffer = buffer.slice(offset)
	    }
	    new this(buffer, value)
	  }
	}

	/**
	 * Custom `toString()` override for struct type instances.
	 */

	function toString () {
	  return '[StructType]'
	}

	/**
	 * Adds a new field to the struct instance with the given name and type.
	 * Note that this function will throw an Error if any instances of the struct
	 * type have already been created, therefore this function must be called at the
	 * beginning, before any instances are created.
	 */

	function defineProperty (name, type) {
	  debug('defining new struct type field', name)

	  // allow string types for convenience
	  type = ref.coerceType(type)

	  assert(!this._instanceCreated, 'an instance of this Struct type has already ' +
	      'been created, cannot add new "fields" anymore')
	  assert.equal('string', typeof name, 'expected a "string" field name')
	  assert(type && /object|function/i.test(typeof type) && 'size' in type &&
	      'indirection' in type
	      , 'expected a "type" object describing the field type: "' + type + '"')
	  assert(type.indirection > 1 || type.size > 0,
	      '"type" object must have a size greater than 0')
	  assert(!(name in this.prototype), 'the field "' + name +
	      '" already exists in this Struct type')

	  var field = {
	    type: type
	  }
	  this.fields[name] = field

	  // define the getter/setter property
	  var desc = { enumerable: true , configurable: true }
	  desc.get = function () {
	    debug('getting "%s" struct field (offset: %d)', name, field.offset)
	    return ref.get(this['ref.buffer'], field.offset, type)
	  }
	  desc.set = function (value) {
	    debug('setting "%s" struct field (offset: %d)', name, field.offset, value)
	    return ref.set(this['ref.buffer'], field.offset, value, type)
	  }

	  // calculate the new size and field offsets
	  recalc(this)

	  Object.defineProperty(this.prototype, name, desc)
	}

	function recalc (struct) {

	  // reset size and alignment
	  struct.size = 0
	  struct.alignment = 0

	  var fieldNames = Object.keys(struct.fields)

	  // first loop through is to determine the `alignment` of this struct
	  fieldNames.forEach(function (name) {
	    var field = struct.fields[name]
	    var type = field.type
	    var alignment = type.alignment || ref.alignof.pointer
	    if (type.indirection > 1) {
	      alignment = ref.alignof.pointer
	    }
	    if (struct.isPacked) {
	      struct.alignment = Math.min(struct.alignment || alignment, alignment)
	    } else {
	      struct.alignment = Math.max(struct.alignment, alignment)
	    }
	  })

	  // second loop through sets the `offset` property on each "field"
	  // object, and sets the `struct.size` as we go along
	  fieldNames.forEach(function (name) {
	    var field = struct.fields[name]
	    var type = field.type

	    if (null != type.fixedLength) {
	      // "ref-array" types set the "fixedLength" prop. don't treat arrays like one
	      // contiguous entity. instead, treat them like individual elements in the
	      // struct. doing this makes the padding end up being calculated correctly.
	      field.offset = addType(type.type)
	      for (var i = 1; i < type.fixedLength; i++) {
	        addType(type.type)
	      }
	    } else {
	      field.offset = addType(type)
	    }
	  })

	  function addType (type) {
	    var offset = struct.size
	    var align = type.indirection === 1 ? type.alignment : ref.alignof.pointer
	    var padding = struct.isPacked ? 0 : (align - (offset % align)) % align
	    var size = type.indirection === 1 ? type.size : ref.sizeof.pointer

	    offset += padding

	    if (!struct.isPacked) {
	      assert.equal(offset % align, 0, "offset should align")
	    }

	    // adjust the "size" of the struct type
	    struct.size = offset + size

	    // return the calulated offset
	    return offset
	  }

	  // any final padding?
	  var left = struct.size % struct.alignment
	  if (left > 0) {
	    debug('additional padding to the end of struct:', struct.alignment - left)
	    struct.size += struct.alignment - left
	  }
	}

	/**
	 * this is the custom prototype of Struct type instances.
	 */

	var proto = {}

	/**
	 * set a placeholder variable on the prototype so that defineProperty() will
	 * throw an error if you try to define a struct field with the name "buffer".
	 */

	proto['ref.buffer'] = ref.NULL

	/**
	 * Flattens the Struct instance into a regular JavaScript Object. This function
	 * "gets" all the defined properties.
	 *
	 * @api public
	 */

	proto.toObject = function toObject () {
	  var obj = {}
	  Object.keys(this.constructor.fields).forEach(function (k) {
	    obj[k] = this[k]
	  }, this)
	  return obj
	}

	/**
	 * Basic `JSON.stringify(struct)` support.
	 */

	proto.toJSON = function toJSON () {
	  return this.toObject()
	}

	/**
	 * `.inspect()` override. For the REPL.
	 *
	 * @api public
	 */

	proto.inspect = function inspect () {
	  var obj = this.toObject()
	  // add instance's "own properties"
	  Object.keys(this).forEach(function (k) {
	    obj[k] = this[k]
	  }, this)
	  return util.inspect(obj)
	}

	/**
	 * returns a Buffer pointing to this struct data structure.
	 */

	proto.ref = function ref () {
	  return this['ref.buffer']
	}


/***/ },
/* 30 */
/***/ function(module, exports) {

	module.exports = require("assert");

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(32);


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var os = _interopRequire(__webpack_require__(33));

	var EnumItem = _interopRequire(__webpack_require__(34));

	var _isType = __webpack_require__(35);

	var isString = _isType.isString;
	var isNumber = _isType.isNumber;

	var indexOf = __webpack_require__(36).indexOf;

	var isBuffer = _interopRequire(__webpack_require__(37));

	var endianness = os.endianness();

	/**
	 * Represents an Enum with enum items.
	 * @param {Array || Object}  map     This are the enum items.
	 * @param {String || Object} options This are options. [optional]
	 */

	var Enum = (function () {
	  function Enum(map, options) {
	    var _this = this;

	    _classCallCheck(this, Enum);

	    /* implement the "ref type interface", so that Enum types can
	     * be used in `node-ffi` function declarations and invokations.
	     * In C, these Enums act as `uint32_t` types.
	     *
	     * https://github.com/TooTallNate/ref#the-type-interface
	     */
	    this.size = 4;
	    this.indirection = 1;

	    if (options && isString(options)) {
	      options = { name: options };
	    }

	    this._options = options || {};
	    this._options.separator = this._options.separator || " | ";
	    this._options.endianness = this._options.endianness || endianness;
	    this._options.ignoreCase = this._options.ignoreCase || false;
	    this._options.freez = this._options.freez || false;

	    this.enums = [];

	    if (map.length) {
	      this._enumLastIndex = map.length;
	      var array = map;
	      map = {};

	      for (var i = 0; i < array.length; i++) {
	        map[array[i]] = Math.pow(2, i);
	      }
	    }

	    for (var member in map) {
	      guardReservedKeys(this._options.name, member);
	      this[member] = new EnumItem(member, map[member], { ignoreCase: this._options.ignoreCase });
	      this.enums.push(this[member]);
	    }
	    this._enumMap = map;

	    if (this._options.ignoreCase) {
	      this.getLowerCaseEnums = function () {
	        var res = {};
	        for (var i = 0, len = this.enums.length; i < len; i++) {
	          res[this.enums[i].key.toLowerCase()] = this.enums[i];
	        }
	        return res;
	      };
	    }

	    if (this._options.name) {
	      this.name = this._options.name;
	    }

	    var isFlaggable = function () {
	      for (var i = 0, len = _this.enums.length; i < len; i++) {
	        var e = _this.enums[i];

	        if (!(e.value !== 0 && !(e.value & e.value - 1))) {
	          return false;
	        }
	      }
	      return true;
	    };

	    this.isFlaggable = isFlaggable();
	    if (this._options.freez) {
	      this.freezeEnums(); //this will make instances of Enum non-extensible
	    }
	  }

	  /**
	   * Returns the appropriate EnumItem key.
	   * @param  {EnumItem || String || Number} key The object to get with.
	   * @return {String}                           The get result.
	   */

	  Enum.prototype.getKey = function getKey(value) {
	    var item = this.get(value);
	    if (item) {
	      return item.key;
	    }
	  };

	  /**
	   * Returns the appropriate EnumItem value.
	   * @param  {EnumItem || String || Number} key The object to get with.
	   * @return {Number}                           The get result.
	   */

	  Enum.prototype.getValue = function getValue(key) {
	    var item = this.get(key);
	    if (item) {
	      return item.value;
	    }
	  };

	  /**
	   * Returns the appropriate EnumItem.
	   * @param  {EnumItem || String || Number} key The object to get with.
	   * @return {EnumItem}                         The get result.
	   */

	  Enum.prototype.get = function get(key, offset) {
	    if (key === null || key === undefined) {
	      return;
	    } // Buffer instance support, part of the ref Type interface
	    if (isBuffer(key)) {
	      key = key["readUInt32" + this._options.endianness](offset || 0);
	    }

	    if (EnumItem.isEnumItem(key)) {
	      var foundIndex = indexOf.call(this.enums, key);
	      if (foundIndex >= 0) {
	        return key;
	      }
	      if (!this.isFlaggable || this.isFlaggable && key.key.indexOf(this._options.separator) < 0) {
	        return;
	      }
	      return this.get(key.key);
	    } else if (isString(key)) {

	      var enums = this;
	      if (this._options.ignoreCase) {
	        enums = this.getLowerCaseEnums();
	        key = key.toLowerCase();
	      }

	      if (key.indexOf(this._options.separator) > 0) {
	        var parts = key.split(this._options.separator);

	        var value = 0;
	        for (var i = 0; i < parts.length; i++) {
	          var part = parts[i];

	          value |= enums[part].value;
	        }

	        return new EnumItem(key, value);
	      } else {
	        return enums[key];
	      }
	    } else {
	      for (var m in this) {
	        if (this.hasOwnProperty(m)) {
	          if (this[m].value === key) {
	            return this[m];
	          }
	        }
	      }

	      var result = null;

	      if (this.isFlaggable) {
	        for (var n in this) {
	          if (this.hasOwnProperty(n)) {
	            if ((key & this[n].value) !== 0) {
	              if (result) {
	                result += this._options.separator;
	              } else {
	                result = "";
	              }
	              result += n;
	            }
	          }
	        }
	      }

	      return this.get(result || null);
	    }
	  };

	  /**
	   * Sets the Enum "value" onto the give `buffer` at the specified `offset`.
	   * Part of the ref "Type interface".
	   *
	   * @param  {Buffer} buffer The Buffer instance to write to.
	   * @param  {Number} offset The offset in the buffer to write to. Default 0.
	   * @param  {EnumItem || String || Number} value The EnumItem to write.
	   */

	  Enum.prototype.set = function set(buffer, offset, value) {
	    var item = this.get(value);
	    if (item) {
	      return buffer["writeUInt32" + this._options.endianness](item.value, offset || 0);
	    }
	  };

	  /**
	   * Define freezeEnums() as a property of the prototype.
	   * make enumerable items nonconfigurable and deep freeze the properties. Throw Error on property setter.
	   */

	  Enum.prototype.freezeEnums = function freezeEnums() {
	    function envSupportsFreezing() {
	      return Object.isFrozen && Object.isSealed && Object.getOwnPropertyNames && Object.getOwnPropertyDescriptor && Object.defineProperties && Object.__defineGetter__ && Object.__defineSetter__;
	    }

	    function freezer(o) {
	      var props = Object.getOwnPropertyNames(o);
	      props.forEach(function (p) {
	        if (!Object.getOwnPropertyDescriptor(o, p).configurable) {
	          return;
	        }

	        Object.defineProperties(o, p, { writable: false, configurable: false });
	      });
	      return o;
	    }

	    function getPropertyValue(value) {
	      return value;
	    }

	    function deepFreezeEnums(o) {
	      if (typeof o !== "object" || o === null || Object.isFrozen(o) || Object.isSealed(o)) {
	        return;
	      }
	      for (var key in o) {
	        if (o.hasOwnProperty(key)) {
	          o.__defineGetter__(key, getPropertyValue.bind(null, o[key]));
	          o.__defineSetter__(key, function throwPropertySetError(value) {
	            throw TypeError("Cannot redefine property; Enum Type is not extensible.");
	          });
	          deepFreezeEnums(o[key]);
	        }
	      }
	      if (Object.freeze) {
	        Object.freeze(o);
	      } else {
	        freezer(o);
	      }
	    }

	    if (envSupportsFreezing()) {
	      deepFreezeEnums(this);
	    }

	    return this;
	  };

	  /**
	   * Return true whether the enumItem parameter passed in is an EnumItem object and 
	   * has been included as constant of this Enum   
	   * @param  {EnumItem} enumItem
	   */

	  Enum.prototype.isDefined = function isDefined(enumItem) {
	    var condition = function (e) {
	      return e === enumItem;
	    };
	    if (isString(enumItem) || isNumber(enumItem)) {
	      condition = function (e) {
	        return e.is(enumItem);
	      };
	    }
	    return this.enums.some(condition);
	  };

	  /**
	   * Returns JSON object representation of this Enum.
	   * @return {String} JSON object representation of this Enum.
	   */

	  Enum.prototype.toJSON = function toJSON() {
	    return this._enumMap;
	  };

	  /**
	   * Extends the existing Enum with a New Map.
	   * @param  {Array}  map  Map to extend from
	   */

	  Enum.prototype.extend = function extend(map) {
	    if (map.length) {
	      var array = map;
	      map = {};

	      for (var i = 0; i < array.length; i++) {
	        var exponent = this._enumLastIndex + i;
	        map[array[i]] = Math.pow(2, exponent);
	      }

	      for (var member in map) {
	        guardReservedKeys(this._options.name, member);
	        this[member] = new EnumItem(member, map[member], { ignoreCase: this._options.ignoreCase });
	        this.enums.push(this[member]);
	      }

	      for (var key in this._enumMap) {
	        map[key] = this._enumMap[key];
	      }

	      this._enumLastIndex += map.length;
	      this._enumMap = map;

	      if (this._options.freez) {
	        this.freezeEnums(); //this will make instances of new Enum non-extensible
	      }
	    }
	  };

	  /**
	   * Registers the Enum Type globally in node.js.
	   * @param  {String} key Global variable. [optional]
	   */

	  Enum.register = function register() {
	    var key = arguments[0] === undefined ? "Enum" : arguments[0];

	    if (!global[key]) {
	      global[key] = Enum;
	    }
	  };

	  return Enum;
	})();

	module.exports = Enum;

	// private

	var reservedKeys = ["_options", "get", "getKey", "getValue", "enums", "isFlaggable", "_enumMap", "toJSON", "_enumLastIndex"];

	function guardReservedKeys(customName, key) {
	  if (customName && key === "name" || indexOf.call(reservedKeys, key) >= 0) {
	    throw new Error("Enum key " + key + " is a reserved word!");
	  }
	}

/***/ },
/* 33 */
/***/ function(module, exports) {

	module.exports = require("os");

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var _isType = __webpack_require__(35);

	var isObject = _isType.isObject;
	var isString = _isType.isString;

	/**
	 * Represents an Item of an Enum.
	 * @param {String} key   The Enum key.
	 * @param {Number} value The Enum value.
	 */

	var EnumItem = (function () {

	  /*constructor reference so that, this.constructor===EnumItem//=>true */

	  function EnumItem(key, value) {
	    var options = arguments[2] === undefined ? {} : arguments[2];

	    _classCallCheck(this, EnumItem);

	    this.key = key;
	    this.value = value;

	    this._options = options;
	    this._options.ignoreCase = this._options.ignoreCase || false;
	  }

	  /**
	   * Checks if the flagged EnumItem has the passing object.
	   * @param  {EnumItem || String || Number} value The object to check with.
	   * @return {Boolean}                            The check result.
	   */

	  EnumItem.prototype.has = function has(value) {
	    if (EnumItem.isEnumItem(value)) {
	      return (this.value & value.value) !== 0;
	    } else if (isString(value)) {
	      if (this._options.ignoreCase) {
	        return this.key.toLowerCase().indexOf(value.toLowerCase()) >= 0;
	      }
	      return this.key.indexOf(value) >= 0;
	    } else {
	      return (this.value & value) !== 0;
	    }
	  };

	  /**
	   * Checks if the EnumItem is the same as the passing object.
	   * @param  {EnumItem || String || Number} key The object to check with.
	   * @return {Boolean}                          The check result.
	   */

	  EnumItem.prototype.is = function is(key) {
	    if (EnumItem.isEnumItem(key)) {
	      return this.key === key.key;
	    } else if (isString(key)) {
	      if (this._options.ignoreCase) {
	        return this.key.toLowerCase() === key.toLowerCase();
	      }
	      return this.key === key;
	    } else {
	      return this.value === key;
	    }
	  };

	  /**
	   * Returns String representation of this EnumItem.
	   * @return {String} String representation of this EnumItem.
	   */

	  EnumItem.prototype.toString = function toString() {
	    return this.key;
	  };

	  /**
	   * Returns JSON object representation of this EnumItem.
	   * @return {String} JSON object representation of this EnumItem.
	   */

	  EnumItem.prototype.toJSON = function toJSON() {
	    return this.key;
	  };

	  /**
	   * Returns the value to compare with.
	   * @return {String} The value to compare with.
	   */

	  EnumItem.prototype.valueOf = function valueOf() {
	    return this.value;
	  };

	  EnumItem.isEnumItem = function isEnumItem(value) {
	    return value instanceof EnumItem || isObject(value) && value.key !== undefined && value.value !== undefined;
	  };

	  return EnumItem;
	})();

	module.exports = EnumItem;

/***/ },
/* 35 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	var isType = function (type, value) {
	  return typeof value === type;
	};
	exports.isType = isType;
	var isObject = function (value) {
	  return isType("object", value);
	};
	exports.isObject = isObject;
	var isString = function (value) {
	  return isType("string", value);
	};
	exports.isString = isString;
	var isNumber = function (value) {
	  return isType("number", value);
	};
	exports.isNumber = isNumber;

/***/ },
/* 36 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	var indexOf = Array.prototype.indexOf || function (find, i /*opt*/) {
	  if (i === undefined) i = 0;
	  if (i < 0) i += this.length;
	  if (i < 0) i = 0;
	  for (var n = this.length; i < n; i++) if (i in this && this[i] === find) return i;
	  return -1;
	};
	exports.indexOf = indexOf;

/***/ },
/* 37 */
/***/ function(module, exports) {

	/*!
	 * Determine if an object is a Buffer
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */

	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	module.exports = function (obj) {
	  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
	}

	function isBuffer (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}

	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
	}


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.parseContainerReq = exports.parseAuthReq = exports.parseRegisteredAppArray = exports.parseRegisteredApp = exports.parseContainerPermissionsArray = exports.parseContainerPermissions = exports.parsePermissionArray = exports.parseAppExchangeInfo = exports.parseArray = undefined;

	var _ref = __webpack_require__(28);

	var _ref2 = _interopRequireDefault(_ref);

	var _refArray = __webpack_require__(39);

	var _refArray2 = _interopRequireDefault(_refArray);

	var _types = __webpack_require__(27);

	var types = _interopRequireWildcard(_types);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var parseArray = exports.parseArray = function parseArray(type, arrayBuf, len) {
	  if (len === 0) {
	    return [];
	  }
	  var arrPtr = _ref2.default.reinterpret(arrayBuf, type.size * len);
	  var ArrType = (0, _refArray2.default)(type);
	  return ArrType(arrPtr);
	};

	var parseAppExchangeInfo = exports.parseAppExchangeInfo = function parseAppExchangeInfo(appExchangeInfo) {
	  if (!(appExchangeInfo instanceof types.AppExchangeInfo)) {
	    return;
	  }
	  return {
	    id: appExchangeInfo.id,
	    scope: appExchangeInfo.scope,
	    name: appExchangeInfo.name,
	    vendor: appExchangeInfo.vendor
	  };
	};

	var parsePermissionArray = exports.parsePermissionArray = function parsePermissionArray(permissionArray, len) {
	  var res = [];
	  var i = 0;
	  var permissions = parseArray(types.Permission, permissionArray, len);
	  for (i = 0; i < permissions.length; i++) {
	    res.push(permissions[i].key);
	  }
	  return res;
	};

	var parseContainerPermissions = exports.parseContainerPermissions = function parseContainerPermissions(containerPermissions) {
	  if (!(containerPermissions instanceof types.ContainerPermissions)) {
	    return;
	  }
	  return {
	    cont_name: containerPermissions.cont_name,
	    access: parsePermissionArray(containerPermissions.access, containerPermissions.access_len),
	    access_len: containerPermissions.access_len,
	    access_cap: containerPermissions.access_cap
	  };
	};

	var parseContainerPermissionsArray = exports.parseContainerPermissionsArray = function parseContainerPermissionsArray(containerPermissionsArray, len) {
	  var res = [];
	  var i = 0;
	  var contArr = parseArray(types.ContainerPermissions, containerPermissionsArray, len);
	  for (i = 0; i < contArr.length; i++) {
	    res.push(parseContainerPermissions(contArr[i]));
	  }
	  return res;
	};

	var parseRegisteredApp = exports.parseRegisteredApp = function parseRegisteredApp(registeredApp) {
	  if (!(registeredApp instanceof types.RegisteredApp)) {
	    return;
	  }
	  return {
	    app_info: parseAppExchangeInfo(registeredApp.app_info),
	    containers: parseContainerPermissionsArray(registeredApp.containers, registeredApp.containers_len),
	    containers_len: registeredApp.containers_len,
	    containers_cap: registeredApp.containers_cap
	  };
	};

	var parseRegisteredAppArray = exports.parseRegisteredAppArray = function parseRegisteredAppArray(registeredAppArray, len) {
	  var res = [];
	  var i = 0;
	  var registeredApps = parseArray(types.RegisteredApp, registeredAppArray, len);
	  for (i = 0; i < registeredApps.length; i++) {
	    res.push(parseRegisteredApp(registeredApps[i]));
	  }
	  return res;
	};

	var parseAuthReq = exports.parseAuthReq = function parseAuthReq(authReq) {
	  if (!(authReq instanceof types.AuthReq)) {
	    return;
	  }
	  return {
	    app: parseAppExchangeInfo(authReq.app),
	    app_container: authReq.app_container,
	    containers: parseContainerPermissionsArray(authReq.containers, authReq.containers_len),
	    containers_len: authReq.containers_len,
	    containers_cap: authReq.containers_cap
	  };
	};

	var parseContainerReq = exports.parseContainerReq = function parseContainerReq(containersReq) {
	  if (!(containersReq instanceof types.ContainersReq)) {
	    return;
	  }
	  return {
	    app: parseAppExchangeInfo(containersReq.app),
	    containers: parseContainerPermissionsArray(containersReq.containers, containersReq.containers_len),
	    containers_len: containersReq.containers_len,
	    containers_cap: containersReq.containers_cap
	  };
		};

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */

	var _ref = __webpack_require__(28)
	var assert = __webpack_require__(30)
	var debug = __webpack_require__(10)('ref:array')
	var ArrayIndex = __webpack_require__(40)
	var isArray = Array.isArray

	/**
	 * The Array "type" constructor.
	 * The returned constructor's API is highly influenced by the WebGL
	 * TypedArray API.
	 */

	module.exports = function Array (_type, _length) {
	  debug('defining new array "type"')
	  var type = _ref.coerceType(_type)
	  var fixedLength = _length | 0

	  /**
	   * This is the ArrayType "constructor" that gets returned.
	   */

	  function ArrayType (data, length) {
	    if (!(this instanceof ArrayType)) {
	      return new ArrayType(data, length)
	    }
	    debug('creating new array instance')
	    ArrayIndex.call(this)
	    var item_size = ArrayType.BYTES_PER_ELEMENT
	    if (0 === arguments.length) {
	      // new IntArray()
	      // use the "fixedLength" if provided, otherwise throw an Error
	      if (fixedLength > 0) {
	        this.length = fixedLength
	        this.buffer = new Buffer(this.length * item_size)
	      } else {
	        throw new Error('A "length", "array" or "buffer" must be passed as the first argument')
	      }
	    } else if ('number' == typeof data) {
	      // new IntArray(69)
	      this.length = data
	      this.buffer = new Buffer(this.length * item_size)
	    } else if (isArray(data)) {
	      // new IntArray([ 1, 2, 3, 4, 5 ], {len})
	      // use optional "length" if provided, otherwise use "fixedLength, otherwise
	      // use the Array's .length
	      var len = 0
	      if (null != length) {
	        len = length
	      } else if (fixedLength > 0) {
	        len = fixedLength
	      } else {
	        len = data.length
	      }
	      if (data.length < len) {
	        throw new Error('array length must be at least ' + len + ', got ' + data.length)
	      }
	      this.length = len
	      this.buffer = new Buffer(len * item_size)
	      for (var i = 0; i < len; i++) {
	        this[i] = data[i]
	      }
	    } else if (Buffer.isBuffer(data)) {
	      // new IntArray(Buffer(8))
	      var len = 0
	      if (null != length) {
	        len = length
	      } else if (fixedLength > 0) {
	        len = fixedLength
	      } else {
	        len = data.length / item_size | 0
	      }
	      var expectedLength = item_size * len
	      this.length = len
	      if (data.length != expectedLength) {
	        if (data.length < expectedLength) {
	          throw new Error('buffer length must be at least ' + expectedLength + ', got ' + data.length)
	        } else {
	          debug('resizing buffer from %d to %d', data.length, expectedLength)
	          data = data.slice(0, expectedLength)
	        }
	      }
	      this.buffer = data
	    }
	  }

	  // make array instances inherit from our `ArrayIndex.prototype`
	  ArrayType.prototype = Object.create(ArrayIndex.prototype, {
	    constructor: {
	      value: ArrayType,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    },
	    // "buffer" is the backing buffer instance
	    buffer: {
	      value: _ref.NULL,
	      enumerable: true,
	      writable: true,
	      configurable: true
	    },
	    // "node-ffi" calls this when passed an array instance to an ffi'd function
	    ref: {
	      value: ref,
	      enumerable: true,
	      writable: true,
	      configurable: true
	    },
	    // "slice" implementation
	    slice: {
	      value: slice,
	      enumerable: true,
	      writable: true,
	      configurable: true
	    }
	  })

	  // part of the "array-index" interface
	  ArrayType.prototype[ArrayIndex.get] = getter
	  ArrayType.prototype[ArrayIndex.set] = setter

	  // save down the "fixedLength" if specified. "ref-struct" needs this value
	  if (fixedLength > 0) {
	    ArrayType.fixedLength = fixedLength
	  }

	  // keep a reference to the base "type"
	  ArrayType.type = type
	  ArrayType.BYTES_PER_ELEMENT = type.indirection == 1 ? type.size : _ref.sizeof.pointer
	  assert(ArrayType.BYTES_PER_ELEMENT > 0)

	  // the ref "type" interface
	  if (fixedLength > 0) {
	    // this "type" is probably going in a ref-struct or being used manually
	    ArrayType.size = ArrayType.BYTES_PER_ELEMENT * fixedLength
	    ArrayType.alignment = type.alignment
	    ArrayType.indirection = 1
	    ArrayType.get = get
	    ArrayType.set = set
	  } else {
	    // this "type" is probably an argument/return value for a node-ffi function
	    ArrayType.size = _ref.sizeof.pointer
	    ArrayType.alignment = _ref.alignof.pointer
	    ArrayType.indirection = 1
	    ArrayType.get = getRef
	    ArrayType.set = setRef
	  }

	  // untilZeros() function
	  ArrayType.untilZeros = untilZeros

	  return ArrayType
	}

	/**
	 * The "get" function of the Array "type" interface.
	 * Most likely invoked when accessing within a "ref-struct" type.
	 */

	function get (buffer, offset) {
	  debug('Array "type" getter for buffer at offset', offset)
	  if (offset > 0) {
	    buffer = buffer.slice(offset)
	  }
	  return new this(buffer)
	}

	/**
	 * The "set" function of the Array "type" interface.
	 * Most likely invoked when setting within a "ref-struct" type.
	 */

	function set (buffer, offset, value) {
	  debug('Array "type" setter for buffer at offset', buffer, offset, value)
	  var array = this.get(buffer, offset)
	  var isInstance = value instanceof this
	  if (isInstance || isArray(value)) {
	    for (var i = 0; i < value.length; i++) {
	      array[i] = value[i]
	    }
	  } else {
	    throw new Error('not sure how to set into Array: ' + value)
	  }
	}

	/**
	 * Reads a pointer from the given offset and returns a new "array" instance of
	 * this type.
	 * Most likely invoked when getting an array instance back as a return value from
	 * an FFI'd function.
	 */

	function getRef (buffer, offset) {
	  debug('Array reference "type" getter for buffer at offset', offset)
	  return new this(buffer.readPointer(offset))
	}

	/**
	 * Most likely invoked when passing an array instance as an argument to an FFI'd
	 * function.
	 */

	function setRef (buffer, offset, value) {
	  debug('Array reference "type" setter for buffer at offset', offset)
	  var ptr
	  if (value instanceof this) {
	    ptr = value.buffer
	  } else {
	    ptr = new this(value).buffer
	  }
	  _ref.writePointer(buffer, offset, ptr)
	}

	/**
	 * Returns a reference to the backing buffer of this Array instance.
	 *
	 * i.e. if the array represents `int[]` (a.k.a. `int *`),
	 *      then the returned Buffer represents `int (*)[]` (a.k.a. `int **`)
	 */

	function ref () {
	  debug('ref()')
	  var type = this.constructor
	  var origSize = this.buffer.length
	  var r = _ref.ref(this.buffer)
	  r.type = Object.create(_ref.types.CString)
	  r.type.get = function (buf, offset) {
	    return new type(_ref.readPointer(buf, offset | 0, origSize))
	  }
	  r.type.set = function () {
	    assert(0, 'implement!!!')
	  }
	  return r
	}

	/**
	 * The "getter" implementation for the "array-index" interface.
	 */

	function getter (index) {
	  debug('getting array[%d]', index)
	  var size = this.constructor.BYTES_PER_ELEMENT
	  var baseType = this.constructor.type
	  var offset = size * index
	  var end = offset + size
	  var buffer = this.buffer
	  if (buffer.length < end) {
	    debug('reinterpreting buffer from %d to %d', buffer.length, end)
	    buffer = _ref.reinterpret(buffer, end)
	  }
	  return _ref.get(buffer, offset, baseType)
	}

	/**
	 * The "setter" implementation for  the "array-index" interface.
	 */

	function setter (index, value) {
	  debug('setting array[%d]', index)
	  var size = this.constructor.BYTES_PER_ELEMENT
	  var baseType = this.constructor.type
	  var offset = size * index
	  var end = offset + size
	  var buffer = this.buffer
	  if (buffer.length < end) {
	    debug('reinterpreting buffer from %d to %d', buffer.length, end)
	    buffer = _ref.reinterpret(buffer, end)
	  }
	  // TODO: DRY with getter()

	  _ref.set(buffer, offset, value, baseType)
	  return value
	}

	/**
	 * The "slice" implementation.
	 */

	function slice (start, end) {
	  var data

	  if (end) {
	    debug('slicing array from %d to %d', start, end)
	    data = this.buffer.slice(start*this.constructor.BYTES_PER_ELEMENT, end*this.constructor.BYTES_PER_ELEMENT)
	  } else {
	    debug('slicing array from %d', start)
	    data = this.buffer.slice(start*this.constructor.BYTES_PER_ELEMENT)
	  }

	  return new this.constructor(data)
	}

	/**
	 * Accepts a Buffer instance that should be an already-populated with data for the
	 * ArrayType. The "length" of the Array is determined by searching through the
	 * buffer's contents until an aligned NULL pointer is encountered.
	 *
	 * @param {Buffer} buffer the null-terminated buffer to convert into an Array
	 * @api public
	 */

	function untilZeros (buffer) {
	  return new this(_ref.reinterpretUntilZeros(buffer, this.type.size))
	}


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */

	var Symbol = __webpack_require__(41);
	var debug = __webpack_require__(10)('array-index');

	var get = Symbol('get');
	var set = Symbol('set');
	var length = Symbol('length');

	/**
	 * JavaScript Array "length" is bound to an unsigned 32-bit int.
	 * See: http://stackoverflow.com/a/6155063/376773
	 */

	var MAX_LENGTH = Math.pow(2, 32);

	/**
	 * Module exports.
	 */

	module.exports = ArrayIndex;
	ArrayIndex.get = get;
	ArrayIndex.set = set;

	/**
	 * Subclass this.
	 */

	function ArrayIndex (_length) {
	  Object.defineProperty(this, 'length', {
	    get: getLength,
	    set: setLength,
	    enumerable: false,
	    configurable: true
	  });

	  this[length] = 0;

	  if (arguments.length > 0) {
	    setLength.call(this, _length);
	  }
	}

	/**
	 * You overwrite the "get" Symbol in your subclass.
	 */

	ArrayIndex.prototype[ArrayIndex.get] = function () {
	  throw new Error('you must implement the `ArrayIndex.get` Symbol');
	};

	/**
	 * You overwrite the "set" Symbol in your subclass.
	 */

	ArrayIndex.prototype[ArrayIndex.set] = function () {
	  throw new Error('you must implement the `ArrayIndex.set` Symbol');
	};

	/**
	 * Converts this array class into a real JavaScript Array. Note that this
	 * is a "flattened" array and your defined getters and setters won't be invoked
	 * when you interact with the returned Array. This function will call the
	 * getter on every array index of the object.
	 *
	 * @return {Array} The flattened array
	 * @api public
	 */

	ArrayIndex.prototype.toArray = function toArray () {
	  var i = 0;
	  var l = this.length;
	  var array = new Array(l);
	  for (; i < l; i++) {
	    array[i] = this[i];
	  }
	  return array;
	};

	/**
	 * Basic support for `JSON.stringify()`.
	 */

	ArrayIndex.prototype.toJSON = function toJSON () {
	  return this.toArray();
	};

	/**
	 * toString() override. Use Array.prototype.toString().
	 */

	ArrayIndex.prototype.toString = function toString () {
	  var a = this.toArray();
	  return a.toString.apply(a, arguments);
	};

	/**
	 * inspect() override. For the REPL.
	 */

	ArrayIndex.prototype.inspect = function inspect () {
	  var a = this.toArray();
	  Object.keys(this).forEach(function (k) {
	    a[k] = this[k];
	  }, this);
	  return a;
	};

	/**
	 * Getter for the "length" property.
	 * Returns the value of the "length" Symbol.
	 */

	function getLength () {
	  debug('getting "length": %o', this[length]);
	  return this[length];
	};

	/**
	 * Setter for the "length" property.
	 * Calls "ensureLength()", then sets the "length" Symbol.
	 */

	function setLength (v) {
	  debug('setting "length": %o', v);
	  return this[length] = ensureLength(this, v);
	};

	/**
	 * Ensures that getters/setters from 0 up to "_newLength" have been defined
	 * on `Object.getPrototypeOf(this)`.
	 *
	 * @api private
	 */

	function ensureLength (self, _newLength) {
	  var newLength;
	  if (_newLength > MAX_LENGTH) {
	    newLength = MAX_LENGTH;
	  } else {
	    newLength = _newLength | 0;
	  }
	  var proto = Object.getPrototypeOf(self);
	  var cur = proto[length] | 0;
	  var num = newLength - cur;
	  if (num > 0) {
	    var desc = {};
	    debug('creating a descriptor object with %o entries', num);
	    for (var i = cur; i < newLength; i++) {
	      desc[i] = setup(i);
	    }
	    debug('calling `Object.defineProperties()` with %o entries', num);
	    Object.defineProperties(proto, desc);
	    proto[length] = newLength;
	  }
	  return newLength;
	}

	/**
	 * Returns a property descriptor for the given "index", with "get" and "set"
	 * functions created within the closure.
	 *
	 * @api private
	 */

	function setup (index) {
	  function get () {
	    return this[ArrayIndex.get](index);
	  }
	  function set (v) {
	    return this[ArrayIndex.set](index, v);
	  }
	  return {
	    enumerable: true,
	    configurable: true,
	    get: get,
	    set: set
	  };
	}


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(42)() ? Symbol : __webpack_require__(43);


/***/ },
/* 42 */
/***/ function(module, exports) {

	'use strict';

	var validTypes = { object: true, symbol: true };

	module.exports = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	// ES2015 Symbol polyfill for environments that do not support it (or partially support it)

	'use strict';

	var d              = __webpack_require__(44)
	  , validateSymbol = __webpack_require__(57)

	  , create = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('TypeError: Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	module.exports = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('TypeError: Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d('', description),
			__name__: d('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// If there's native implementation of given symbol, let's fallback to it
		// to ensure proper interoperability with other native functions e.g. Array.from
		hasInstance: d('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d(SymbolPolyfill),
		toString: d('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var assign        = __webpack_require__(45)
	  , normalizeOpts = __webpack_require__(52)
	  , isCallable    = __webpack_require__(53)
	  , contains      = __webpack_require__(54)

	  , d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOpts(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOpts(options), desc);
	};


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(46)()
		? Object.assign
		: __webpack_require__(47);


/***/ },
/* 46 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== 'function') return false;
		obj = { foo: 'raz' };
		assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
		return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';
	};


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var keys  = __webpack_require__(48)
	  , value = __webpack_require__(51)

	  , max = Math.max;

	module.exports = function (dest, src/*, …srcn*/) {
		var error, i, l = max(arguments.length, 2), assign;
		dest = Object(value(dest));
		assign = function (key) {
			try { dest[key] = src[key]; } catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < l; ++i) {
			src = arguments[i];
			keys(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(49)()
		? Object.keys
		: __webpack_require__(50);


/***/ },
/* 49 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function () {
		try {
			Object.keys('primitive');
			return true;
		} catch (e) { return false; }
	};


/***/ },
/* 50 */
/***/ function(module, exports) {

	'use strict';

	var keys = Object.keys;

	module.exports = function (object) {
		return keys(object == null ? object : Object(object));
	};


/***/ },
/* 51 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function (value) {
		if (value == null) throw new TypeError("Cannot use null or undefined");
		return value;
	};


/***/ },
/* 52 */
/***/ function(module, exports) {

	'use strict';

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	module.exports = function (options/*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (options == null) return;
			process(Object(options), result);
		});
		return result;
	};


/***/ },
/* 53 */
/***/ function(module, exports) {

	// Deprecated

	'use strict';

	module.exports = function (obj) { return typeof obj === 'function'; };


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(55)()
		? String.prototype.contains
		: __webpack_require__(56);


/***/ },
/* 55 */
/***/ function(module, exports) {

	'use strict';

	var str = 'razdwatrzy';

	module.exports = function () {
		if (typeof str.contains !== 'function') return false;
		return ((str.contains('dwa') === true) && (str.contains('foo') === false));
	};


/***/ },
/* 56 */
/***/ function(module, exports) {

	'use strict';

	var indexOf = String.prototype.indexOf;

	module.exports = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var isSymbol = __webpack_require__(58);

	module.exports = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};


/***/ },
/* 58 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.constructContainerReq = exports.constructAuthReq = exports.constructContainerArray = exports.constructContainerPermission = exports.constructPermissionArray = exports.constructAppExchangeInfo = undefined;

	var _refArray = __webpack_require__(39);

	var _refArray2 = _interopRequireDefault(_refArray);

	var _types = __webpack_require__(27);

	var types = _interopRequireWildcard(_types);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var constructAppExchangeInfo = exports.constructAppExchangeInfo = function constructAppExchangeInfo(appInfo) {
	  return new types.AppExchangeInfo({
	    id: appInfo.id,
	    scope: appInfo.scope,
	    name: appInfo.name,
	    vendor: appInfo.vendor
	  });
	};

	var constructPermissionArray = exports.constructPermissionArray = function constructPermissionArray(permissions) {
	  var PermArray = (0, _refArray2.default)(types.Permission);
	  var permArray = new PermArray(permissions.length);

	  permissions.forEach(function (perm, i) {
	    permArray[i] = types.Permission.get(perm);
	  });
	  return permArray;
	};

	var constructContainerPermission = exports.constructContainerPermission = function constructContainerPermission(contPerm) {
	  return new types.ContainerPermissions({
	    cont_name: contPerm.cont_name,
	    access: constructPermissionArray(contPerm.access).buffer,
	    access_len: contPerm.access_len,
	    access_cap: contPerm.access_len
	  });
	};

	var constructContainerArray = exports.constructContainerArray = function constructContainerArray(containers) {
	  var ContArray = (0, _refArray2.default)(types.ContainerPermissions);
	  var contArray = new ContArray(containers.length);

	  containers.forEach(function (cont, i) {
	    contArray[i] = constructContainerPermission(cont);
	  });
	  return contArray;
	};

	var constructAuthReq = exports.constructAuthReq = function constructAuthReq(authReq) {
	  return new types.AuthReq({
	    app: constructAppExchangeInfo(authReq.app),
	    app_container: authReq.app_container,
	    containers: constructContainerArray(authReq.containers).buffer,
	    containers_len: authReq.containers_len,
	    containers_cap: authReq.containers_cap
	  });
	};

	var constructContainerReq = exports.constructContainerReq = function constructContainerReq(contReq) {
	  return new types.ContainersReq({
	    app: constructAppExchangeInfo(contReq.app),
	    containers: constructContainerArray(contReq.containers).buffer,
	    containers_len: contReq.containers_len,
	    containers_cap: contReq.containers_cap
	  });
		};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable no-underscore-dangle */
	/* eslint-disable import/no-unresolved, import/extensions */

	/* eslint-enable import/no-unresolved, import/extensions */


	var _ffi = __webpack_require__(6);

	var _ffi2 = _interopRequireDefault(_ffi);

	var _os = __webpack_require__(33);

	var _os2 = _interopRequireDefault(_os);

	var _path = __webpack_require__(1);

	var _path2 = _interopRequireDefault(_path);

	var _constants = __webpack_require__(61);

	var _constants2 = _interopRequireDefault(_constants);

	var _types = __webpack_require__(27);

	var type = _interopRequireWildcard(_types);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _ffiFunctions = Symbol('ffiFunctions');
	var _libPath = Symbol('libPath');

	var SystemUriLoader = function () {
	  function SystemUriLoader() {
	    _classCallCheck(this, SystemUriLoader);

	    this[_libPath] = _constants2.default.DEFAULT_SYSTEM_URI_LIB_PATH[_os2.default.platform()];
	    this[_ffiFunctions] = {
	      open: [type.int32, ['string']],
	      install: [type.int32, ['string', 'string', 'string', 'string', 'string', 'string']]
	    };
	    this.lib = _ffi2.default.Library(_path2.default.resolve(__dirname, this[_libPath]), this[_ffiFunctions]);
	  }

	  _createClass(SystemUriLoader, [{
	    key: 'registerUriScheme',
	    value: function registerUriScheme(appInfo, schemes) {
	      var bundle = appInfo.bundle || appInfo.id;
	      var exec = appInfo.exec ? appInfo.exec : process.execPath;
	      var vendor = appInfo.vendor;
	      var name = appInfo.name;
	      var icon = appInfo.icon;
	      var joinedSchemes = schemes.join ? schemes.join(',') : schemes;

	      var ret = this.lib.install(bundle, vendor, name, exec, icon, joinedSchemes);
	      if (ret === -1) {
	        throw new Error('Error occured installing: ' + ret);
	      }
	    }
	  }, {
	    key: 'openUri',
	    value: function openUri(str) {
	      var ret = this.lib.open(str);
	      if (ret === -1) {
	        throw new Error('Error occured opening ' + str + ' : ' + ret);
	      }
	    }
	  }]);

	  return SystemUriLoader;
	}();

	var loader = new SystemUriLoader();
	exports.default = loader;
	module.exports = exports['default'];

/***/ },
/* 61 */
/***/ function(module, exports) {

	module.exports = {
		"DEFAULT_LIB_PATH": {
			"win32": "./safe_authenticator.dll",
			"darwin": "./libsafe_authenticator.dylib",
			"linux": "./libsafe_authenticator.so"
		},
		"DEFAULT_SYSTEM_URI_LIB_PATH": {
			"win32": "./system_uri.dll",
			"darwin": "./libsystem_uri.dylib",
			"linux": "./libsystem_uri.so"
		},
		"DEFAULT_CLIENT_HANDLE_KEYS": {
			"AUTHENTICATOR": "authenticator"
		},
		"NETWORK_STATUS": {
			"CONNECTING": 0,
			"CONNECTED": 1,
			"DISCONNECTED": 2
		},
		"CREATE_ACC_NAV": {
			"WELCOME": 1,
			"INVITE_CODE": 2,
			"SECRET_FORM": 3,
			"PASSWORD_FORM": 4
		},
		"PASSPHRASE_STRENGTH": {
			"VERY_WEAK": 4,
			"WEAK": 8,
			"SOMEWHAT_SECURE": 10,
			"SECURE": 10
		},
		"PASSPHRASE_STRENGTH_MSG": {
			"VERY_WEAK": "Very weak",
			"WEAK": "Weak",
			"SOMEWHAT_SECURE": "Somewhat secure",
			"SECURE": "Secure"
		},
		"APP_DEFAULT_PERMISSIONS": {
			"SAFE_DRIVE_ACCESS": "SAFE_DRIVE_ACCESS",
			"LOW_LEVEL_API": "LOW_LEVEL_API"
		}
	};

/***/ },
/* 62 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var FfiApi = function () {
	  function FfiApi() {
	    _classCallCheck(this, FfiApi);

	    this.safeLib = null;
	  }

	  _createClass(FfiApi, [{
	    key: "setSafeLib",
	    value: function setSafeLib(safeLib) {
	      this.safeLib = safeLib;
	    }
	    // Abstract methods
	    /* eslint-disable class-methods-use-this */
	    /* eslint-disable no-unused-vars */

	  }, {
	    key: "drop",
	    value: function drop(safeLib) {}
	    /* eslint-enable no-unused-vars */

	  }, {
	    key: "getFunctionsToRegister",
	    value: function getFunctionsToRegister() {}
	    /* eslint-enable class-methods-use-this */

	  }]);

	  return FfiApi;
	}();

	exports.default = FfiApi;
	module.exports = exports["default"];

/***/ },
/* 63 */
/***/ function(module, exports) {

	module.exports = {
		"-1": "Encode decode error",
		"-2": "Asymmetric decipher failure",
		"-3": "Symmetric decipher failure",
		"-4": "Received unexpected data",
		"-5": "Received unexpected event",
		"-6": "Version cache miss",
		"-7": "Root directory exists",
		"-8": "Random data generation failure",
		"-9": "Operation forbidden",
		"-10": "Routing error",
		"-11": "Routing interface error",
		"-12": "Unsupported salt size for pw hash",
		"-13": "Unsuccessful pw hash",
		"-14": "Operation aborted",
		"-15": "Mpid messaging error",
		"-16": "Self encryption",
		"-17": "Request timeout",
		"-100": "Access denied",
		"-101": "No such account",
		"-102": "Account exists",
		"-103": "No such data",
		"-104": "Data exists",
		"-105": "Data too large",
		"-106": "No such entry",
		"-107": "Entry exists",
		"-108": "Too many entries",
		"-109": "No such key",
		"-110": "Invalid owners",
		"-111": "Invalid successor",
		"-112": "Invalid operation",
		"-113": "Low balance",
		"-114": "Network full",
		"-115": "Network other",
		"-200": "Auth denied",
		"-201": "Containers denied",
		"-202": "Invalid msg",
		"-203": "Already authorised",
		"-204": "Unknown app",
		"-205": "String error",
		"-300": "Directory exists",
		"-301": "Destination and source are same",
		"-302": "Directory not found",
		"-303": "File exists",
		"-304": "File does not match",
		"-305": "File not found",
		"-306": "Invalid range",
		"-307": "Invalid parameter",
		"-1013": "Io error",
		"-1014": "No such public id",
		"-1015": "Public id exists",
		"-2000": "Unexpected"
	};

/***/ }
/******/ ]);
//# sourceMappingURL=protocol.js.map