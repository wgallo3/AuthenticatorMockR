{"version":3,"file":"api.js","sources":["webpack:///webpack/bootstrap a456ad4e9342a97046e2","webpack:///./src/api/helpers.js","webpack:///./src/api/app.js","webpack:///./src/api/cipher_opt.js","webpack:///./src/api/crypto.js","webpack:///./src/api/crypto_key_pair.js","webpack:///./src/api/crypto_public_encryption_key.js","webpack:///./src/api/crypto_secret_encryption_key.js","webpack:///./src/api/crypto_sign_key.js","webpack:///./src/api/emulations/nfs.js","webpack:///./src/api/immutable_data.js","webpack:///./src/api/mutable_data.js","webpack:///./src/api/mutable_data_entries.js","webpack:///./src/api/mutable_data_keys.js","webpack:///./src/api/mutable_data_mutation.js","webpack:///./src/api/mutable_data_permissions.js","webpack:///./src/api/mutable_data_permissions_set.js","webpack:///./src/api/mutable_data_values.js","webpack:///./src/api/index.js","webpack:///./src/api/ipc.js","webpack:///external \"crypto\"","webpack:///external \"electron\"","webpack:///external \"safe-app\"","webpack:///external \"stream\""],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 17);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a456ad4e9342a97046e2","const crypto = require('crypto'); // electron deps will be available inside browser\r\nconst { Readable } = require('stream');\r\n\r\nconst handles = new Map();\r\n\r\nexport const genRandomString = () => (crypto.randomBytes(32).toString('hex'));\r\n\r\nexport const genHandle = (obj) => {\r\n  const randHandle = genRandomString();\r\n  handles.set(randHandle, obj);\r\n  return randHandle;\r\n};\r\n\r\nexport const getObj = (handle) => {\r\n  return new Promise((resolve, reject) => {\r\n    const obj = handles.get(handle);\r\n    if (obj) {\r\n      return resolve(obj);\r\n    }\r\n    return reject(new Error('Invalid handle'));\r\n  });\r\n};\r\n\r\nexport const freeObj = (handle) => {\r\n  handles.delete(handle);\r\n};\r\n\r\nexport const forEachHelper = (appToken, containerHandle, sendHandles) => {\r\n  var readable = new Readable({ objectMode: true, read() {} })\r\n  getObj(appToken)\r\n    .then(() => getObj(containerHandle))\r\n    .then((container) => container.forEach((arg1, arg2) => {\r\n        setImmediate(() => {\r\n          if (sendHandles) {\r\n            arg1 = genHandle(arg1);\r\n          }\r\n          let args = [arg1];\r\n          if (arg2) {\r\n            if (sendHandles) {\r\n              arg2 = genHandle(arg2);\r\n            }\r\n            args.push(arg2);\r\n          }\r\n          readable.push(args)\r\n        })\r\n      })\r\n      .then(() => {\r\n        setImmediate(() => {\r\n          readable.push(null)\r\n        })\r\n      })\r\n    );\r\n  return readable;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/helpers.js\n// module id = 0\n// module chunks = 0","const safeApp = require('safe-app');\r\nconst ipc = require('./ipc');\r\nconst { genHandle, getObj, freeObj } = require('./helpers');\r\n\r\nmodule.exports.manifest = {\r\n  initialise: 'promise',\r\n  connect: 'promise',\r\n  authorise: 'promise',\r\n  connectAuthorised: 'promise',\r\n  webFetch: 'promise',\r\n  isRegistered: 'promise',\r\n  canAccessContainer: 'promise',\r\n  refreshContainersPermissions: 'promise',\r\n  getContainersNames: 'promise',\r\n  getHomeContainer: 'promise',\r\n  getContainer: 'promise',\r\n  getPubSignKey: 'promise',\r\n  getEncKey: 'promise',\r\n  getSignKeyFromRaw: 'promise',\r\n  getEncKeyKeyFromRaw: 'promise',\r\n  free: 'sync'\r\n};\r\n\r\n/**\r\n * Create a new SAFEApp instance without a connection to the network\r\n * @returns {Promise<SAFEAppToken>} new instace\r\n */\r\nmodule.exports.initialise = (appInfo) => {\r\n  if (this && this.sender) {\r\n    const wholeUrl = this.sender.getURL();\r\n    appInfo.scope = wholeUrl;\r\n  } else {\r\n    appInfo.scope = null;\r\n  }\r\n\r\n  return safeApp.initializeApp(appInfo)\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Create a new, unregistered Session (read-only)\r\n * @returns {Promise<SAFEAppToken>} same instace\r\n */\r\nmodule.exports.connect = (appToken) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.auth.connectUnregistered())\r\n    .then(() => appToken);\r\n};\r\n\r\n/**\r\n * With the options object it can be opt for getting a container\r\n * for the app itself: opts.own_container=true\r\n * @returns {Promise<AuthURI>} auth granted URI\r\n */\r\nmodule.exports.authorise = (appToken, permissions, options) => {\r\n  return new Promise((resolve, reject) => {\r\n    getObj(appToken)\r\n      .then((app) => app.auth.genAuthUri(permissions, options)\r\n        .then((authReq) => ipc.sendAuthReq(authReq, (err, res) => {\r\n          if (err) {\r\n            return reject(new Error('Unable to authorise the application: ', err)); // TODO send Error in specific\r\n          }\r\n          return resolve(res);\r\n        })))\r\n      .catch(reject);\r\n  });\r\n};\r\n\r\n/**\r\n * Create a new, registered Session (read-write)\r\n * @returns {Promise<SAFEAppToken>} same instace\r\n */\r\nmodule.exports.connectAuthorised = (appToken, authUri) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.auth.loginFromURI(authUri))\r\n    .then((connectedApp) => appToken);\r\n};\r\n\r\n/**\r\n * Authorise container request\r\n * @returns {Promise<AuthURI>} auth granted URI\r\n */\r\nmodule.exports.authoriseContainer = (appToken, permissions) => {\r\n  return new Promise((resolve, reject) => {\r\n    getObj(appToken)\r\n      .then((app) => app.auth.genContainerAuthUri(permissions)\r\n        .then((authReq) => ipc.sendAuthReq(authReq, (err, res) => {\r\n          if (err) {\r\n            return reject(new Error('Unable to authorise the application: ', err)); // TODO send Error in specific\r\n          }\r\n          return resolve(res);\r\n        })))\r\n      .catch(reject);\r\n  });\r\n};\r\n\r\nmodule.exports.webFetch = (appToken, url) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.webFetch(url)\r\n      .then((f) => app.immutableData.fetch(f.dataMapName))\r\n      .then((i) => i.read())\r\n    );\r\n};\r\n\r\n/**\r\n * Whether or not this is a registered/authenticated\r\n * session.\r\n *\r\n * @param {String} appToken - the application token\r\n * @returns {Boolean} true if this is an authenticated session\r\n **/\r\nmodule.exports.isRegistered = (appToken) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.auth.registered);\r\n};\r\n\r\n/**\r\n * Whether or not this session has specifc permission access of a given\r\n * container.\r\n * @param {String} appToken - the application token\r\n * @arg {String} name  name of the container, e.g. `_public`\r\n * @arg {(String||Array<String>)} [permissions=['Read']] permissions to check for\r\n * @returns {Promise<Boolean>}\r\n **/\r\nmodule.exports.canAccessContainer = (appToken, name, permissions) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.auth.canAccessContainer(name, permissions));\r\n};\r\n\r\n/**\r\n * Refresh permissions for accessible containers from the network. Useful when\r\n * you just connected or received a response from the authenticator in the IPC protocol.\r\n * @param {String} appToken - the application token\r\n */\r\nmodule.exports.refreshContainersPermissions = (appToken) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.auth.refreshContainersPermissions());\r\n};\r\n\r\n/**\r\n * Get the names of all containers found.\r\n * @param {String} appToken - the application token\r\n * @returns {Promise<[String]>} list of containers names\r\n */\r\nmodule.exports.getContainersNames = (appToken) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.auth.getContainersNames())\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Get the MData for the apps own container generated by Authenticator\r\n * @param appToken\r\n * @return {*}\r\n */\r\nmodule.exports.getHomeContainer = (appToken) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.auth.getHomeContainer())\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Lookup and return the information necessary to access a container.\r\n * @param {String} appToken - the application token\r\n * @arg name {String} name of the container, e.g. `'_public'`\r\n * @returns {Promise<MutableDataHandle>} the handle for the Mutable Data behind it\r\n */\r\nmodule.exports.getContainer = (appToken, name) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.auth.getContainer(name))\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Get the public signing key of this session\r\n * @param {String} appToken - the application token\r\n * @returns {Promise<SignKeyHandle>}\r\n **/\r\nmodule.exports.getPubSignKey = (appToken) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.auth.getPubSignKey())\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Get the public encryption key of this session\r\n * @param {String} appToken - the application token\r\n * @returns {Promise<EncKeyHandle>}\r\n **/\r\nmodule.exports.getEncKey = (appToken) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.auth.getEncKey())\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Interprete the SignKey from a given raw string\r\n * @param {String} appToken - the application token\r\n * @param {String} raw\r\n * @returns {Promise<SignKeyHandle>}\r\n **/\r\nmodule.exports.getSignKeyFromRaw = (appToken, raw) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.auth.getSignKeyFromRaw(raw))\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Interprete the encryption Key from a given raw string\r\n * @param {String} appToken - the application token\r\n * @arg {String} raw\r\n * @returns {Promise<EncKeyHandle>}\r\n **/\r\nmodule.exports.getEncKeyKeyFromRaw = (appToken, raw) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.auth.getEncKeyKeyFromRaw(raw))\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Free the SAFEApp instance from memory\r\n * @param {String} appToken - the application token\r\n */\r\nmodule.exports.free = (appToken) => freeObj(appToken);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/app.js\n// module id = 1\n// module chunks = 0","const { genHandle, getObj, freeObj } = require('./helpers');\r\n\r\nmodule.exports.manifest = {\r\n  newPlainText: 'promise',\r\n  newSymmetric: 'promise',\r\n  newAsymmetric: 'promise',\r\n  free: 'sync'\r\n};\r\n\r\n/**\r\n * Create a PlainText Cipher Opt\r\n * @param {String} appToken - the application token\r\n * @returns {CipherOptHandle}\r\n **/\r\nmodule.exports.newPlainText = (appToken) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.cipherOpt.newPlainText())\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Create a new Symmetric Cipher\r\n * @param {String} appToken - the application token\r\n * @returns {CipherOptHandle}\r\n **/\r\nmodule.exports.newSymmetric = (appToken) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.cipherOpt.newSymmetric())\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Create a new Asymmetric Cipher for the given key\r\n * @param {String} appToken - the application token\r\n * @param {EncKeyHandle} keyHandle\r\n * @returns {CipherOptHandle}\r\n **/\r\nmodule.exports.newAsymmetric = (appToken, keyHandle) => {\r\n  return getObj(appToken)\r\n    .then((app) => getObj(keyHandle)\r\n      .then((key) => app.cipherOpt.newAsymmetric(key))\r\n      .then(genHandle)\r\n    );\r\n};\r\n\r\n/**\r\n * Free the CipherOpt instance from memory\r\n * @param {String} cipherOptHandle - the cipher opt handle\r\n */\r\nmodule.exports.free = (cipherOptHandle) => freeObj(cipherOptHandle);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/cipher_opt.js\n// module id = 2\n// module chunks = 0","const { genHandle, getObj } = require('./helpers');\r\n\r\nmodule.exports.manifest = {\r\n  sha3Hash: 'promise',\r\n  getAppPubSignKey: 'promise',\r\n  getAppPubEncKey: 'promise',\r\n  generateEncKeyPair: 'promise',\r\n  getSignKeyFromRaw: 'promise',\r\n  pubEncKeyKeyFromRaw: 'promise'\r\n};\r\n\r\n/**\r\n * Hash the given input with SHA3 Hash\r\n * @param appToken - the application token\r\n * @param inpt - input string\r\n * @return {Promise<Buffer>}\r\n */\r\nmodule.exports.sha3Hash = (appToken, inpt) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.crypto.sha3Hash(inpt));\r\n};\r\n\r\n/**\r\n * Get the public signing key\r\n * @param appToken - the application token\r\n * @return {Promise<SignKeyHandle>}\r\n */\r\nmodule.exports.getAppPubSignKey = (appToken) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.crypto.getAppPubSignKey())\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Get the public encryption key\r\n * @param appToken - the application token\r\n * @return {Promise<PubEncKeyHandle>}\r\n */\r\nmodule.exports.getAppPubEncKey = (appToken) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.crypto.getAppPubEncKey())\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Generate a new Asymmetric EncryptionKeyPair\r\n * @param appToken - the application token\r\n * @return {Promise<KeyPairHandle>}\r\n */\r\nmodule.exports.generateEncKeyPair = (appToken) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.crypto.generateEncKeyPair())\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Interpret the SignKey from a given raw string\r\n * @param appToken - the application token\r\n * @param raw - raw input string\r\n * @return {Promise<SignKeyHandle>}\r\n */\r\nmodule.exports.getSignKeyFromRaw = (appToken, raw) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.crypto.getSignKeyFromRaw(raw))\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Interprete the encryption Key from a given raw string\r\n * @param appToken - the application token\r\n * @param raw - raw input string\r\n * @return {Promise<PubEncKeyHandle>}\r\n */\r\nmodule.exports.pubEncKeyKeyFromRaw = (appToken, raw) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.crypto.pubEncKeyKeyFromRaw(raw))\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Interpret the secret encryption Key from a given raw string\r\n * @param appToken - the application token\r\n * @param raw - raw input string\r\n * @return {Promise<SecEncKey>}\r\n */\r\nmodule.exports.secEncKeyKeyFromRaw = (appToken, raw) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.crypto.secEncKeyKeyFromRaw(raw))\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Generate a new Asymmetric EncryptionKeyPair from raw secret and public keys\r\n * @param appToken - the application token\r\n * @param rawPublicKey\r\n * @param rawSecretKey\r\n * @return {Promise<KeyPair>}\r\n */\r\nmodule.exports.generateEncKeyPairFromRaw = (appToken, rawPublicKey, rawSecretKey) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.crypto.generateEncKeyPairFromRaw(rawPublicKey, rawSecretKey))\r\n    .then(genHandle);\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/crypto.js\n// module id = 3\n// module chunks = 0","const { genHandle, getObj, freeObj } = require('./helpers');\r\n\r\nmodule.exports.manifest = {\r\n  getPubEncKey: 'promise',\r\n  getSecEncKey: 'promise',\r\n  decryptSealed: 'promise',\r\n  free: 'sync'\r\n};\r\n\r\n/**\r\n * Get the Public Encryption key instance of this keypair\r\n * @param appToken - application token\r\n * @param keyPairHandle - keyPair handle\r\n * @return {Promise<PubEncKey>}\r\n */\r\nmodule.exports.getPubEncKey = (appToken, keyPairHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(keyPairHandle))\r\n    .then((keyPair) => genHandle(keyPair.pubEncKey));\r\n};\r\n\r\n/**\r\n * Get the Secrect Encryption key instance of this keypair\r\n * @param appToken - application token\r\n * @param keyPairHandle - keyPair handle\r\n * @return {Promise<SecEncKey>}\r\n */\r\nmodule.exports.getSecEncKey = (appToken, keyPairHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(keyPairHandle))\r\n    .then((keyPair) => genHandle(keyPair.secEncKey));\r\n};\r\n\r\n/**\r\n * Decrypt the given ciphertext with a seal (buffer or string) using the private and public key\r\n * @param appToken - application token\r\n * @param keyPairHandle - keyPair handle\r\n * @param cipher\r\n * @return {Promise<Buffer>}\r\n */\r\nmodule.exports.decryptSealed = (appToken, keyPairHandle, cipher) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(keyPairHandle))\r\n    .then((keyPair) => keyPair.decryptSealed(cipher));\r\n};\r\n\r\n/**\r\n * Free the KeyPair instance from memory\r\n * @param {String} keyPairHandle - the KeyPair handle\r\n */\r\nmodule.exports.free = (keyPairHandle) => freeObj(keyPairHandle);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/crypto_key_pair.js\n// module id = 4\n// module chunks = 0","const { getObj, freeObj } = require('./helpers');\r\n\r\nmodule.exports.manifest = {\r\n  getRaw: 'promise',\r\n  encryptSealed: 'promise',\r\n  encrypt: 'promise',\r\n  free: 'sync'\r\n};\r\n\r\n/**\r\n * Generate raw string copy of encryption key\r\n * @param appToken - application token\r\n * @param pubEncKeyHandle - public encrypted key handle\r\n * @return {Promise<String>}\r\n */\r\nmodule.exports.getRaw = (appToken, pubEncKeyHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(pubEncKeyHandle))\r\n    .then((pubEncKey) => pubEncKey.getRaw());\r\n};\r\n\r\n/**\r\n * Encrypt the input (buffer or string) using the private and public key with a seal\r\n * @param appToken - application token\r\n * @param pubEncKeyHandle - public encrypted key handle\r\n * @param str\r\n * @return {Promise<Buffer>}\r\n */\r\nmodule.exports.encryptSealed = (appToken, pubEncKeyHandle, str) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(pubEncKeyHandle))\r\n    .then((pubEncKey) => pubEncKey.encryptSealed(str));\r\n};\r\n\r\n/**\r\n * Encrypt the input (buffer or string) using the private and public key and the given privateKey\r\n * @param appToken - application token\r\n * @param pubEncKeyHandle - public encrypted key handle\r\n * @param str\r\n * @param secretKey\r\n * @return {Promise<Buffer>}\r\n */\r\nmodule.exports.encrypt = (appToken, pubEncKeyHandle, str, secretKey) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(pubEncKeyHandle))\r\n    .then((pubEncKey) => pubEncKey.encrypt(str, secretKey));\r\n};\r\n\r\n/**\r\n * Free the PubEncKey instance from memory\r\n * @param {String} pubEncKeyHandle - the public encryption key handle\r\n */\r\nmodule.exports.free = (pubEncKeyHandle) => freeObj(pubEncKeyHandle);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/crypto_public_encryption_key.js\n// module id = 5\n// module chunks = 0","const { getObj, freeObj } = require('./helpers');\r\n\r\nmodule.exports.manifest = {\r\n  getRaw: 'promise',\r\n  decrypt: 'promise',\r\n  free: 'sync'\r\n};\r\n\r\n/**\r\n * Generate raw string copy of encryption key\r\n * @param appToken - application token\r\n * @param secEncKeyHandle - secret encrypted key handle\r\n * @return {Promise<String>}\r\n */\r\nmodule.exports.getRaw = (appToken, secEncKeyHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(secEncKeyHandle))\r\n    .then((secEncKey) => secEncKey.getRaw());\r\n};\r\n\r\n/**\r\n * Decrypt the given ciphertext (buffer or string) using the private and public key\r\n * @param appToken - application token\r\n * @param secEncKeyHandle - secret encrypted key handle\r\n * @param cipher\r\n * @param theirPubKey\r\n * @return {Promise<Buffer>}\r\n */\r\nmodule.exports.decrypt = (appToken, secEncKeyHandle, cipher, theirPubKey) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(secEncKeyHandle))\r\n    .then((secEncKey) => secEncKey.decrypt(cipher, theirPubKey));\r\n};\r\n\r\n/**\r\n * Free the SecEncKey instance from memory\r\n * @param {String} secEncKeyHandle - the secret encryption key handle\r\n */\r\nmodule.exports.free = (secEncKeyHandle) => freeObj(secEncKeyHandle);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/crypto_secret_encryption_key.js\n// module id = 6\n// module chunks = 0","const { getObj, freeObj } = require('./helpers');\r\n\r\nmodule.exports.manifest = {\r\n  getRaw: 'promise',\r\n  free: 'sync'\r\n};\r\n\r\n/**\r\n * Generate raw string copy of encryption key\r\n * @param appToken - application token\r\n * @param signKeyHandle - public encrypted key handle\r\n * @return {Promise<String>}\r\n */\r\nmodule.exports.getRaw = (appToken, signKeyHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(signKeyHandle))\r\n    .then((signKey) => signKey.getRaw());\r\n};\r\n\r\n/**\r\n * Free the SignKey instance from memory\r\n * @param {String} signKeyHandle - the SignKey handle\r\n */\r\nmodule.exports.free = (signKeyHandle) => freeObj(signKeyHandle);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/crypto_sign_key.js\n// module id = 7\n// module chunks = 0","const { genHandle, getObj, freeObj } = require('../helpers');\r\n\r\nmodule.exports.manifest = {\r\n  create: 'promise',\r\n  fetch: 'promise',\r\n  insert: 'promise',\r\n  update: 'promise',\r\n  getFileMeta: 'promise',\r\n  free: 'sync'\r\n};\r\n\r\nmodule.exports.create = (appToken, nfsHandle, content) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(nfsHandle))\r\n    .then((nfs) => nfs.create(content))\r\n    .then(genHandle);\r\n};\r\n\r\nmodule.exports.fetch = (appToken, nfsHandle, fileName) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(nfsHandle))\r\n    .then((nfs) => nfs.fetch(fileName))\r\n    .then(genHandle);\r\n};\r\n\r\nmodule.exports.insert = (appToken, nfsHandle, fileHandle, fileName) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(nfsHandle))\r\n    .then((nfs) => {\r\n      return getObj(fileHandle).then((file) => nfs.insert(fileName, file));\r\n    })\r\n    .then(() => fileHandle);\r\n};\r\n\r\nmodule.exports.update = (appToken, nfsHandle, fileHandle, fileName, version) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(nfsHandle))\r\n    .then((nfs) => {\r\n      return getObj(fileHandle).then((file) => nfs.update(fileName, file, version));\r\n    })\r\n    .then(() => fileHandle);\r\n};\r\n\r\nmodule.exports.getFileMeta = (fileHandle) => {\r\n  return getObj(fileHandle).then((file) => (\r\n    {\r\n      dataMapName: file.dataMapName,\r\n      created: file.created,\r\n      modified: file.modified,\r\n      size: file.size,\r\n      version: file.version\r\n    }\r\n  ))\r\n};\r\n\r\n/**\r\n * Free the File instance from memory\r\n * @param {String} fileHandle - the File handle\r\n */\r\nmodule.exports.free = (fileHandle) => freeObj(fileHandle);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/emulations/nfs.js\n// module id = 8\n// module chunks = 0","const { genHandle, getObj, freeObj } = require('./helpers');\r\n\r\nmodule.exports.manifest = {\r\n  create: 'promise',\r\n  fetch: 'promise',\r\n  write: 'promise',\r\n  closeWriter: 'promise',\r\n  read: 'promise',\r\n  size: 'promise',\r\n  closeReader: 'promise',\r\n};\r\n\r\n/**\r\n * Create a new ImmutableData Writer\r\n * @param {String} appToken - the application token\r\n * @returns {Promise<Handle>} - the ImmutableData Writer Handle\r\n **/\r\nmodule.exports.create = (appToken) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.immutableData.create())\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Look up an existing Immutable Data for the given address\r\n * @param {String} appToken - the application token\r\n * @param {Buffer} address - the XorName on the network\r\n * @returns {Promise<Handle>} - the ImmutableData Reader Handle\r\n **/\r\nmodule.exports.fetch = (appToken, address) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.immutableData.fetch(address))\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Append the given data to immutable Data.\r\n *\r\n * @param {String} appToken - the application token\r\n * @param {Handle} writerHandle - the writer handle\r\n * @param {String} string\r\n * @returns {Promise<()>}\r\n **/\r\nmodule.exports.write = (appToken, writerHandle, string) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(writerHandle))\r\n    .then((writer) => writer.write(string));\r\n};\r\n\r\n/**\r\n * Close and write the immutable Data to the network.\r\n * @param {String} appToken - the application token\r\n * @param {Handle} writerHandle - the writer handle\r\n * @returns {Promise<String>} the address to the data once written to the network\r\n **/\r\nmodule.exports.closeWriter = (appToken, writerHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(writerHandle))\r\n    .then((writer) => writer.close())\r\n    .then((addr) => {\r\n      freeObj(writerHandle);\r\n      return addr;\r\n    });\r\n};\r\n\r\n/**\r\n * Read the given amount of bytes from the network\r\n * @param {String} appToken - the application token\r\n * @param {Handle} readerHandle - the reader handle\r\n * @param {Object=} options\r\n * @param {Number} [options.offset=0] start position\r\n * @param {Number} [options.end=size] end position or end of data\r\n **/\r\nmodule.exports.read = (appToken, readerHandle, options) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(readerHandle))\r\n    .then((reader) => reader.read(options));\r\n};\r\n\r\n/**\r\n * The size of the mutable data on the network\r\n * @param {String} appToken - the application token\r\n * @param {Handle} readerHandle - the reader handle\r\n * @returns {Promise<Number>} length in bytes\r\n **/\r\nmodule.exports.size = (appToken, readerHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(readerHandle))\r\n    .then((reader) => reader.size());\r\n};\r\n\r\n/**\r\n * Close the Reader handle\r\n * @param {String} appToken - the application token\r\n * @param {Handle} readerHandle - the reader handle\r\n * @returns {Promise<()>}\r\n */\r\nmodule.exports.closeReader = (appToken, readerHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(readerHandle))\r\n    .then((reader) => reader.close())\r\n    .then(() => freeObj(readerHandle));\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/immutable_data.js\n// module id = 9\n// module chunks = 0","const { genHandle, getObj, freeObj } = require('./helpers');\r\n\r\nmodule.exports.manifest = {\r\n  newRandomPrivate: 'promise',\r\n  newRandomPublic: 'promise',\r\n  newPrivate: 'promise',\r\n  newPublic: 'promise',\r\n  newPermissions: 'promise',\r\n  newPermissionSet: 'promise',\r\n  newMutation: 'promise',\r\n  newEntries: 'promise',\r\n  quickSetup: 'promise',\r\n  encryptKey: 'promise',\r\n  encryptValue: 'promise',\r\n  decrypt: 'promise',\r\n  getNameAndTag: 'promise',\r\n  getVersion: 'promise',\r\n  get: 'promise',\r\n  put: 'promise',\r\n  getEntries: 'promise',\r\n  getKeys: 'promise',\r\n  getValues: 'promise',\r\n  getPermissions: 'promise',\r\n  getUserPermissions: 'promise',\r\n  delUserPermissions: 'promise',\r\n  setUserPermissions: 'promise',\r\n  applyEntriesMutation: 'promise',\r\n  serialise: 'promise',\r\n  fromSerial: 'promise',\r\n  emulateAs: 'promise',\r\n  free: 'sync'\r\n};\r\n\r\n/**\r\n * Create a new mutuable data at a random address with private\r\n * access.\r\n * @param {String} appToken - the application token\r\n * @param {Number} typeTag - the typeTag to use\r\n * @returns {Promise<MutableDataHandle>}\r\n **/\r\nmodule.exports.newRandomPrivate = (appToken, typeTag) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.mutableData.newRandomPrivate(typeTag))\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Create a new mutuable data at a random address with public\r\n * access.\r\n * @param {String} appToken - the application token\r\n * @param {Number} typeTag - the typeTag to use\r\n * @returns {Promise<MutableDataHandle>}\r\n **/\r\nmodule.exports.newRandomPublic = (appToken, typeTag) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.mutableData.newRandomPublic(typeTag))\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Initiate a mutuable data at the given address with private\r\n * access.\r\n * @param {String} appToken - the application token\r\n * @param {Buffer|String}\r\n * @param {Number} typeTag - the typeTag to use\r\n * @returns {Promise<MutableDataHandle>}\r\n **/\r\nmodule.exports.newPrivate = (appToken, name, typeTag) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.mutableData.newPrivate(name, typeTag))\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Initiate a mutuable data at the given address with public\r\n * access.\r\n * @param {String} appToken - the application token\r\n * @param {Buffer|String}\r\n * @param {Number} typeTag - the typeTag to use\r\n * @returns {Promise<MutableDataHandle>}\r\n **/\r\nmodule.exports.newPublic = (appToken, name, typeTag) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.mutableData.newPublic(name, typeTag))\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Create a new Permissions object.\r\n * @param {String} appToken - the application token\r\n * @returns {Promise<PermissionsHandle>}\r\n **/\r\nmodule.exports.newPermissions = (appToken) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.mutableData.newPermissions())\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Create a new PermissionsSet object.\r\n * @param {String} appToken - the application token\r\n * @returns {Promise<PermissionsSetHandle>}\r\n **/\r\nmodule.exports.newPermissionSet = (appToken) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.mutableData.newPermissionSet())\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Create a new Mutation object.\r\n * @param {String} appToken - the application token\r\n * @returns {Promise<MutationHandle>}\r\n **/\r\nmodule.exports.newMutation = (appToken) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.mutableData.newMutation())\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Create a new Entries object.\r\n * @param {String} appToken - the application token\r\n * @returns {Promise<EntriesHandle>}\r\n **/\r\nmodule.exports.newEntries = (appToken) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.mutableData.newEntries())\r\n    .then(genHandle);\r\n};\r\n\r\n// MutableData functions\r\n/**\r\n * Quickly set up a newly (not yet created) MutableData with\r\n * the app having full-access permissions (and no other).\r\n *\r\n * @param {String} appToken - the application token\r\n * @param {MutableDataHandle} mdHandle - the MutableData handle\r\n * @param {Object=} data - a key-value payload it should\r\n *        create the data with\r\n * @returns {Promise<MutableDataHandle>} - self\r\n **/\r\nmodule.exports.quickSetup = (appToken, mdHandle, data) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(mdHandle))\r\n    .then((md) => md.quickSetup(data))\r\n    .then(() => mdHandle);\r\n};\r\n\r\n/**\r\n * Encrypt the entry key provided as parameter with the encryption key\r\n * contained in a Private MutableData. If the MutableData is Public, the same\r\n * (and unencrypted) value is returned.\r\n *\r\n * @param {String} appToken - the application token\r\n * @param {MutableDataHandle} mdHandle - the MutableData handle\r\n * @param {(String|Buffer)} key - the key you want to encrypt\r\n * @returns {Promise<Key>} - the encrypted entry key\r\n **/\r\nmodule.exports.encryptKey = (appToken, mdHandle, key) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(mdHandle))\r\n    .then((md) => md.encryptKey(key));\r\n};\r\n\r\n/**\r\n * Encrypt the entry value provided as parameter with the encryption key\r\n * contained in a Private MutableData. If the MutableData is Public, the same\r\n * (and unencrypted) value is returned.\r\n *\r\n * @param {String} appToken - the application token\r\n * @param {MutableDataHandle} mdHandle - the MutableData handle\r\n * @param {(String|Buffer)} value - the data you want to encrypt\r\n * @returns {Promise<Value>} - the encrypted entry value\r\n **/\r\nmodule.exports.encryptValue = (appToken, mdHandle, value) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(mdHandle))\r\n    .then((md) => md.encryptValue(value));\r\n};\r\n\r\n/**\r\n * Decrypt the entry key/value provided as parameter with the encryption key\r\n * contained in a Private MutableData.\r\n *\r\n * @param {String} appToken - the application token\r\n * @param {MutableDataHandle} mdHandle - the MutableData handle\r\n * @param {(String|Buffer)} value - the data you want to decrypt\r\n * @returns {Promise<Value>} - the decrypted value\r\n **/\r\nmodule.exports.decrypt = (appToken, mdHandle, value) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(mdHandle))\r\n    .then((md) => md.decrypt(value));\r\n};\r\n\r\n/**\r\n * Look up the name and tag of the MutableData as required to look it\r\n * up on the network.\r\n *\r\n * @param {String} appToken - the application token\r\n * @param {MutableDataHandle} mdHandle - the MutableData handle\r\n * @returns {Promise<NameAndTag>}\r\n **/\r\nmodule.exports.getNameAndTag = (appToken, mdHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(mdHandle))\r\n    .then((md) => md.getNameAndTag());\r\n};\r\n\r\n/**\r\n * Look up the mutable data object version on the network\r\n *\r\n * @param {String} appToken - the application token\r\n * @param {MutableDataHandle} mdHandle - the MutableData handle\r\n * @returns {Promise<Number>} the version\r\n **/\r\nmodule.exports.getVersion = (appToken, mdHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(mdHandle))\r\n    .then((md) => md.getVersion());\r\n};\r\n\r\n/**\r\n * Look up the value of a specific key\r\n *\r\n * @param {String} appToken - the application token\r\n * @param {MutableDataHandle} mdHandle - the MutableData handle\r\n * @param {String} key - the entry's key\r\n * @returns {Promise<ValueVersion>} - the value at the current version\r\n **/\r\nmodule.exports.get = (appToken, mdHandle, key) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(mdHandle))\r\n    .then((md) => md.get(key));\r\n};\r\n\r\n/**\r\n * Create this MutableData on the network.\r\n * @param {String} appToken - the application token\r\n * @param {MutableDataHandle} mdHandle - the MutableData handle\r\n * @param {PermissionsHandle} permissionsHandle - the permissions to create the mdata with\r\n * @param {EntriesHandle} entriesHandle - data payload to create the mdata with\r\n * @returns {Promise<()>}\r\n **/\r\nmodule.exports.put = (appToken, mdHandle, permissionsHandle, entriesHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(mdHandle))\r\n    .then((md) => getObj(permissionsHandle)\r\n      .then((permissions) => getObj(entriesHandle)\r\n        .then((entries) => md.put(permissions, entries))\r\n      ));\r\n};\r\n\r\n/**\r\n * Get a Handle to the entries associated with this mdata\r\n * @param {String} appToken - the application token\r\n * @param {MutableDataHandle} mdHandle - the MutableData handle\r\n * @returns {Promise<(EntriesHandle)>}\r\n **/\r\nmodule.exports.getEntries = (appToken, mdHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(mdHandle))\r\n    .then((md) => md.getEntries())\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Get a Handle to the keys associated with this mdata\r\n * @param {String} appToken - the application token\r\n * @param {MutableDataHandle} mdHandle - the MutableData handle\r\n * @returns {Promise<(KeysHandle)>}\r\n **/\r\nmodule.exports.getKeys = (appToken, mdHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(mdHandle))\r\n    .then((md) => md.getKeys())\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Get a Handle to the values associated with this mdata\r\n * @param {String} appToken - the application token\r\n * @param {MutableDataHandle} mdHandle - the MutableData handle\r\n * @returns {Promise<(ValuesHandle)>}\r\n **/\r\nmodule.exports.getValues = (appToken, mdHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(mdHandle))\r\n    .then((md) => md.getValues())\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Get a Handle to the permissions associated with this mdata\r\n * @param {String} appToken - the application token\r\n * @param {MutableDataHandle} mdHandle - the MutableData handle\r\n * @returns {Promise<(PermissionsHandle)>}\r\n **/\r\nmodule.exports.getPermissions = (appToken, mdHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(mdHandle))\r\n    .then((md) => md.getPermissions())\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Get a Handle to the permissions associated with this mdata for\r\n * a specifc key\r\n * @param {String} appToken - the application token\r\n * @param {MutableDataHandle} mdHandle - the MutableData handle\r\n * @param {SignKeyHandle} signKeyHandle - the sign key to look up\r\n * @returns {Promise<(PermissionsSetHandle)>}\r\n **/\r\nmodule.exports.getUserPermissions = (appToken, mdHandle, signKeyHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(signKeyHandle))\r\n    .then((signKey) => getObj(mdHandle)\r\n      .then((md) => md.getUserPermissions(signKey))\r\n      .then(genHandle)\r\n    );\r\n};\r\n\r\n/**\r\n * Delete the permissions of a specifc key. Directly commits to the network.\r\n * Requires 'ManagePermissions'-Permission for the app.\r\n * @param {String} appToken - the application token\r\n * @param {MutableDataHandle} mdHandle - the MutableData handle\r\n * @param {SignKeyHandle} signKeyHandle - the sign key to lookup for\r\n * @param {Number} version - the current version, to confirm you are\r\n *        actually asking for the right state\r\n * @returns {Promise} - once finished\r\n **/\r\nmodule.exports.delUserPermissions = (appToken, mdHandle, signKeyHandle, version) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(signKeyHandle))\r\n    .then((signKey) => getObj(mdHandle)\r\n      .then((md) => md.delUserPermissions(signKey, version))\r\n    );\r\n};\r\n\r\n/**\r\n * Set the permissions of a specifc key. Directly commits to the network.\r\n * Requires 'ManagePermissions'-Permission for the app.\r\n * @param {String} appToken - the application token\r\n * @param {MutableDataHandle} mdHandle - the MutableData handle\r\n * @param {SignKeyHandle} signKeyHandle - the sign key to lookup for\r\n * @param {PermissionsSetHandle} pmSetHandle - the PermissionsSet to set to\r\n * @param {Number} version - the current version, to confirm you are\r\n *        actually asking for the right state\r\n * @returns {Promise} - once finished\r\n **/\r\nmodule.exports.setUserPermissions = (appToken, mdHandle, signKeyHandle, pmSetHandle, version) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(signKeyHandle)\r\n      .then((signKey) => getObj(pmSetHandle)\r\n        .then((pmSet) => getObj(mdHandle)\r\n          .then((md) => md.setUserPermissions(signKey, pmSet, version))\r\n        )));\r\n};\r\n\r\n/**\r\n * Commit the transaction to the network\r\n * @param {String} appToken - the application token\r\n * @param {MutableDataHandle} mdHandle - the MutableData handle\r\n * @param {MutationHandle} mutationHandle - the Mutation you want to apply\r\n * @return {Promise}\r\n **/\r\nmodule.exports.applyEntriesMutation = (appToken, mdHandle, mutationHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(mutationHandle))\r\n    .then((mutation) => getObj(mdHandle)\r\n      .then((md) => md.applyEntriesMutation(mutation))\r\n    );\r\n};\r\n\r\n/**\r\n * Serialise the current mdata\r\n * @param {String} appToken - the application token\r\n * @param {MutableDataHandle} mdHandle - the MutableData handle\r\n * @returns {Promise<(String)>}\r\n **/\r\nmodule.exports.serialise = (appToken, mdHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(mdHandle))\r\n    .then((md) => md.serialise());\r\n};\r\n\r\n/**\r\n * Deserialize the mdata\r\n * @param {String} appToken - the application token\r\n * @returns {Promise<MutableDataHandle>}\r\n */\r\nmodule.exports.fromSerial = (appToken, data) => {\r\n  return getObj(appToken)\r\n    .then((app) => app.mutableData.fromSerial(data))\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Wrap this MData into a known abstraction. Currently known: `NFS`\r\n * @param {String} appToken - the application token\r\n * @param {MutableDataHandle} mdHandle - the MutableData handle\r\n * @param {String} eml - name of the emulation\r\n * @returns {EmulationHandle} the Emulation you are asking for\r\n **/\r\nmodule.exports.emulateAs = (appToken, mdHandle, eml) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(mdHandle))\r\n    .then((md) => md.emulateAs(eml))\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Free the MutableData instance from memory\r\n * @param {String} mdHandle - the MutableData handle\r\n */\r\nmodule.exports.free = (mdHandle) => freeObj(mdHandle);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/mutable_data.js\n// module id = 10\n// module chunks = 0","const { genHandle, getObj, freeObj, forEachHelper } = require('./helpers');\r\n\r\nmodule.exports.manifest = {\r\n  len: 'promise',\r\n  get: 'promise',\r\n  _with_cb_forEach: 'readable',\r\n  insert: 'promise',\r\n  mutate: 'promise',\r\n  free: 'sync'\r\n};\r\n\r\n\r\n/**\r\n * Get the total number of entries in the Mdata\r\n * @param {String} appToken - the application token\r\n * @param {EntriesHandle} entriesHandle - the Entries obj handle\r\n * @returns {Promise<Number>}\r\n **/\r\nmodule.exports.len = (appToken, entriesHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(entriesHandle))\r\n    .then((entries) => entries.len());\r\n};\r\n\r\n/**\r\n * Look up the value of a specific key\r\n *\r\n * @param {String} appToken - the application token\r\n * @param {EntriesHandle} entriesHandle - the Entries obj handle\r\n * @param {String} keyName - the entry's key\r\n * @returns {Promise<ValueVersion>} - the value at the current version\r\n **/\r\nmodule.exports.get = (appToken, entriesHandle, keyName) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(entriesHandle))\r\n    .then((entries) => entries.get(keyName));\r\n};\r\n\r\n/**\r\n * Iterate over the entries, execute the function every time\r\n * @param {String} appToken - the application token\r\n * @param {EntriesHandle} entriesHandle - the Entries obj handle\r\n * @param {function(Buffer, ValueVersion)} fn - the function to call\r\n * @returns {Promise<()>} - resolves once the iteration is done\r\n **/\r\nmodule.exports._with_cb_forEach = (appToken, entriesHandle) => {\r\n  return forEachHelper(appToken, entriesHandle);\r\n};\r\n\r\n/**\r\n * Insert a new entry. Will directly commit that transaction to the network.\r\n * Will fail if the entry already exists or the current app doesn't have the\r\n * permissions to edit that mdata.\r\n *\r\n * @param {String} appToken - the application token\r\n * @param {EntriesHandle} entriesHandle - the Entries obj handle\r\n * @param {(String|Buffer)} keyName - the key you want store the data under\r\n * @param {(String|Buffer)} value - the data you want to store\r\n * @returns {Promise<>}\r\n **/\r\nmodule.exports.insert = (appToken, entriesHandle, keyName, value) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(entriesHandle))\r\n    .then((entries) => entries.insert(keyName, value));\r\n};\r\n\r\n/**\r\n * Start a new transaction of mutation of the entries\r\n * @param {String} appToken - the application token\r\n * @param {EntriesHandle} entriesHandle - the Entries obj handle\r\n * @return {Promise<MutationHandle>}\r\n **/\r\nmodule.exports.mutate = (appToken, entriesHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(entriesHandle))\r\n    .then((entries) => entries.mutate())\r\n    .then(genHandle);\r\n};\r\n\r\n/**\r\n * Free the Entries instance from memory\r\n * @param {String} entriesHandle - the Entries handle\r\n */\r\nmodule.exports.free = (entriesHandle) => freeObj(entriesHandle);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/mutable_data_entries.js\n// module id = 11\n// module chunks = 0","const { getObj, freeObj, forEachHelper } = require('./helpers');\r\n\r\nmodule.exports.manifest = {\r\n  len: 'promise',\r\n  _with_cb_forEach: 'readable',\r\n  free: 'sync'\r\n};\r\n\r\n/**\r\n * Get the total number of keys in the Mdata\r\n * @param {String} appToken - the application token\r\n * @param {KeysHandle} keysHandle - the Keys obj handle\r\n * @returns {Promise<Number>}\r\n **/\r\nmodule.exports.len = (appToken, keysHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(keysHandle))\r\n    .then((keys) => keys.len());\r\n};\r\n\r\n/**\r\n * Iterate over the value, execute the function every time\r\n * @param {String} appToken - the application token\r\n * @param {KeysHandle} keysHandle - the Keys obj handle\r\n * @param {function(Buffer)} fn - the function to call with the key in the buffer\r\n * @returns {Promise<()>} - resolves once the iteration is done\r\n **/\r\nmodule.exports._with_cb_forEach = (appToken, keysHandle) => {\r\n  return forEachHelper(appToken, keysHandle);\r\n}\r\n\r\n/**\r\n * Free the Keys instance from memory\r\n * @param {String} keysHandle - the Keys handle\r\n */\r\nmodule.exports.free = (keysHandle) => freeObj(keysHandle);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/mutable_data_keys.js\n// module id = 12\n// module chunks = 0","const { getObj, freeObj } = require('./helpers');\r\n\r\nmodule.exports.manifest = {\r\n  insert: 'promise',\r\n  remove: 'promise',\r\n  update: 'promise',\r\n  free: 'sync'\r\n};\r\n\r\n/**\r\n * Store a new `Insert`-Action in the transaction.\r\n *\r\n * @param {String} appToken - the application token\r\n * @param {MutationHandle} mutationHandle - the Mutation obj handle\r\n * @param {(String|Buffer)} keyName\r\n * @param {(String|Buffer)} value\r\n * @returns {Promise} resolves once the storing is done\r\n **/\r\nmodule.exports.insert = (appToken, mutationHandle, keyName, value) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(mutationHandle))\r\n    .then((mutation) => mutation.insert(keyName, value));\r\n};\r\n\r\n/**\r\n * Store a new `Remove`-Action in the transaction\r\n *\r\n * @param {String} appToken - the application token\r\n * @param {MutationHandle} mutationHandle - the Mutation obj handle\r\n * @param {(String|Buffer)} keyName - the key you want to remove\r\n * @param {Number} version - the current version, to confirm you are\r\n *        actually asking for the right state\r\n * @returns {Promise} resolves once the storing is done\r\n **/\r\nmodule.exports.remove = (appToken, mutationHandle, keyName, version) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(mutationHandle))\r\n    .then((mutation) => mutation.remove(keyName, version));\r\n};\r\n\r\n/**\r\n * Store a `Update`-Action in the transaction\r\n *\r\n * @param {String} appToken - the application token\r\n * @param {MutationHandle} mutationHandle - the Mutation obj handle\r\n * @param {(String|Buffer)} keyName - the key you want to remove\r\n * @param {(String|Buffer)} value - the value to upate to\r\n * @param {Number} version - the current version, to confirm you are\r\n *        actually asking for the right state\r\n * @returns {Promise} resolves once the storing is done\r\n **/\r\nmodule.exports.update = (appToken, mutationHandle, keyName, value, version) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(mutationHandle))\r\n    .then((mutation) => mutation.update(keyName, value, version));\r\n};\r\n\r\n/**\r\n * Free the Mutation instance from memory\r\n * @param {String} mutationHandle - the application token\r\n */\r\nmodule.exports.free = (mutationHandle) => freeObj(mutationHandle);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/mutable_data_mutation.js\n// module id = 13\n// module chunks = 0","const { genHandle, getObj, freeObj, forEachHelper } = require('./helpers');\r\n\r\nmodule.exports.manifest = {\r\n  len: 'promise',\r\n  getPermissionsSet: 'promise',\r\n  insertPermissionsSet: 'promise',\r\n  _with_cb_forEach: 'readable',\r\n  free: 'sync'\r\n};\r\n\r\n/**\r\n * Total number of permission entries\r\n * @param {String} appToken - the application token\r\n * @param {PermissionsHandle} permissionsHandle - the Permissions obj handle\r\n * @returns {Promise<Number>}\r\n **/\r\nmodule.exports.len = (appToken, permissionsHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(permissionsHandle))\r\n    .then((permissions) => permissions.len());\r\n};\r\n\r\n/**\r\n * Lookup the permissions of a specifc key\r\n * @param {String} appToken - the application token\r\n * @param {PermissionsHandle} permissionsHandle - the Permissions obj handle\r\n * @param {SignKeyHandle} signKeyHandle - the key to lookup for\r\n * @returns {Promise<PermissionsSetHandle>} - the permissions set for that key\r\n **/\r\nmodule.exports.getPermissionsSet = (appToken, permissionsHandle, signKeyHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(signKeyHandle))\r\n    .then((signKey) => getObj(permissionsHandle)\r\n      .then((permissions) => permissions.getPermissionSet(signKey))\r\n      .then(genHandle)\r\n    );\r\n};\r\n\r\n/**\r\n * Insert a new permissions to a specifc key. Directly commits to the network.\r\n * Requires 'ManagePermissions'-Permission for the app.\r\n * @param {String} appToken - the application token\r\n * @param {PermissionsHandle} permissionsHandle - the Permissions obj handle\r\n * @param {SignKeyHandle} signKeyHandle - the key to lookup for\r\n * @param {PermissionsSetHandle} pmSetHandle - the permissions set you'd like insert\r\n * @returns {Promise} - once finished\r\n **/\r\nmodule.exports.insertPermissionsSet = (appToken, permissionsHandle, signKeyHandle, pmSetHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(signKeyHandle))\r\n    .then((signKey) => getObj(pmSetHandle)\r\n      .then((pmSet) => getObj(permissionsHandle)\r\n        .then((permissions) => permissions.insertPermissionSet(signKey, pmSet))\r\n      ));\r\n};\r\n\r\n/**\r\n * Iterate over the entries, execute the function every time\r\n * @param {String} appToken - the application token\r\n * @param {PermissionsHandle} permissionsHandle - the Permissions obj handle\r\n * @param {function(Buffer, ValueVersion)} fn - the function to call\r\n * @returns {Promise<()>} - resolves once the iteration is done\r\n **/\r\nmodule.exports._with_cb_forEach = (appToken, permissionsHandle) => {\r\n  return forEachHelper(appToken, permissionsHandle, true);\r\n};\r\n\r\n/**\r\n * Free the Permissions instance from memory\r\n * @param {String} permissionsHandle - the application token\r\n */\r\nmodule.exports.free = (permissionsHandle) => freeObj(permissionsHandle);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/mutable_data_permissions.js\n// module id = 14\n// module chunks = 0","const { getObj, freeObj } = require('./helpers');\r\n\r\nmodule.exports.manifest = {\r\n  setAllow: 'promise',\r\n  setDeny: 'promise',\r\n  clear: 'promise',\r\n  free: 'sync'\r\n};\r\n\r\n/**\r\n * Set the action as allowed\r\n * @param {String} appToken - the application token\r\n * @param {PermissionsSetHandle} permissionsSetHandle - the PermissionsSet obj handle\r\n * @param {MDataAction} action\r\n * @returns {Promise}\r\n **/\r\nmodule.exports.setAllow = (appToken, permissionsSetHandle, action) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(permissionsSetHandle))\r\n    .then((pmSet) => pmSet.setAllow(action));\r\n};\r\n\r\n/**\r\n * Set the action as denied\r\n * @param {String} appToken - the application token\r\n * @param {PermissionsSetHandle} permissionsSetHandle - the PermissionsSet obj handle\r\n * @param {MDataAction} action\r\n * @returns {Promise}\r\n **/\r\nmodule.exports.setDeny = (appToken, permissionsSetHandle, action) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(permissionsSetHandle))\r\n    .then((pmSet) => pmSet.setDeny(action));\r\n};\r\n\r\n/**\r\n * Remove action from the set\r\n * @param {String} appToken - the application token\r\n * @param {PermissionsSetHandle} permissionsSetHandle - the PermissionsSet obj handle\r\n * @param {MDataAction} action\r\n * @returns {Promise}\r\n **/\r\nmodule.exports.clear = (appToken, permissionsSetHandle, action) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(permissionsSetHandle))\r\n    .then((pmSet) => pmSet.clear(action));\r\n};\r\n\r\n/**\r\n * Free the PermissionsSet instance from memory\r\n * @param {String} permissionsSetHandle - the application token\r\n */\r\nmodule.exports.free = (permissionsSetHandle) => freeObj(permissionsSetHandle);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/mutable_data_permissions_set.js\n// module id = 15\n// module chunks = 0","const { getObj, freeObj, forEachHelper } = require('./helpers');\r\n\r\nmodule.exports.manifest = {\r\n  len: 'promise',\r\n  _with_cb_forEach: 'readable',\r\n  free: 'sync'\r\n};\r\n\r\n/**\r\n * Get the total number of values in the Mdata\r\n * @param {String} appToken - the application token\r\n * @param {ValuesHandle} valuesHandle - the Values obj handle\r\n * @returns {Promise<Number>}\r\n **/\r\nmodule.exports.len = (appToken, valuesHandle) => {\r\n  return getObj(appToken)\r\n    .then(() => getObj(valuesHandle))\r\n    .then((values) => values.len());\r\n};\r\n\r\n/**\r\n * Iterate over the value, execute the function every time\r\n * @param {String} appToken - the application token\r\n * @param {ValuesHandle} valuesHandle - the Values obj handle\r\n * @param {function(Buffer, ValueVersion)} fn - the function to call\r\n * @returns {Promise<()>} - resolves once the iteration is done\r\n **/\r\nmodule.exports._with_cb_forEach = (appToken, valuesHandle) => {\r\n  return forEachHelper(appToken, valuesHandle);\r\n};\r\n\r\n/**\r\n * Free the Values instance from memory\r\n * @param {String} valuesHandle - the Values handle\r\n */\r\nmodule.exports.free = (valuesHandle) => freeObj(valuesHandle);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/mutable_data_values.js\n// module id = 16\n// module chunks = 0","const app = require('./app');\r\nconst cipherOpt = require('./cipher_opt');\r\nconst imdata = require('./immutable_data');\r\nconst crypto = require('./crypto');\r\nconst cryptoKeyPair = require('./crypto_key_pair');\r\nconst cryptoSecEncKey = require('./crypto_secret_encryption_key');\r\nconst cryptoPubEncKey = require('./crypto_public_encryption_key');\r\nconst cryptoSignKey = require('./crypto_sign_key');\r\nconst mdata = require('./mutable_data');\r\nconst mdataEntries = require('./mutable_data_entries');\r\nconst mdataKeys = require('./mutable_data_keys');\r\nconst mdataValues = require('./mutable_data_values');\r\nconst mdataMutation = require('./mutable_data_mutation');\r\nconst mdataPermissions = require('./mutable_data_permissions');\r\nconst mdataPermissionsSet = require('./mutable_data_permissions_set');\r\nconst nfs = require('./emulations/nfs');\r\n\r\nmodule.exports = [\r\n  {\r\n    name: 'safeApp',\r\n    isInternal: true,\r\n    manifest: app.manifest,\r\n    methods: app\r\n  },\r\n  {\r\n    name: 'safeCipherOpt',\r\n    isInternal: true,\r\n    manifest: cipherOpt.manifest,\r\n    methods: cipherOpt\r\n  },\r\n  {\r\n    name: 'safeImmutableData',\r\n    isInternal: true,\r\n    manifest: imdata.manifest,\r\n    methods: imdata\r\n  },\r\n  {\r\n    name: 'safeCrypto',\r\n    isInternal: true,\r\n    manifest: crypto.manifest,\r\n    methods: crypto\r\n  },\r\n  {\r\n    name: 'safeCryptoKeyPair',\r\n    isInternal: true,\r\n    manifest: cryptoKeyPair.manifest,\r\n    methods: cryptoKeyPair\r\n  },\r\n  {\r\n    name: 'safeCryptoSecEncKey',\r\n    isInternal: true,\r\n    manifest: cryptoSecEncKey.manifest,\r\n    methods: cryptoSecEncKey\r\n  },\r\n  {\r\n    name: 'safeCryptoPubEncKey',\r\n    isInternal: true,\r\n    manifest: cryptoPubEncKey.manifest,\r\n    methods: cryptoPubEncKey\r\n  },\r\n  {\r\n    name: 'safeCryptoSignKey',\r\n    isInternal: true,\r\n    manifest: cryptoSignKey.manifest,\r\n    methods: cryptoSignKey\r\n  },\r\n  {\r\n    name: 'safeMutableData',\r\n    isInternal: true,\r\n    manifest: mdata.manifest,\r\n    methods: mdata\r\n  },\r\n  {\r\n    name: 'safeMutableDataEntries',\r\n    isInternal: true,\r\n    manifest: mdataEntries.manifest,\r\n    methods: mdataEntries\r\n  },\r\n  {\r\n    name: 'safeMutableDataKeys',\r\n    isInternal: true,\r\n    manifest: mdataKeys.manifest,\r\n    methods: mdataKeys\r\n  },\r\n  {\r\n    name: 'safeMutableDataValues',\r\n    isInternal: true,\r\n    manifest: mdataValues.manifest,\r\n    methods: mdataValues\r\n  },\r\n  {\r\n    name: 'safeMutableDataMutation',\r\n    isInternal: true,\r\n    manifest: mdataMutation.manifest,\r\n    methods: mdataMutation\r\n  },\r\n  {\r\n    name: 'safeMutableDataPermissions',\r\n    isInternal: true,\r\n    manifest: mdataPermissions.manifest,\r\n    methods: mdataPermissions\r\n  },\r\n  {\r\n    name: 'safeMutableDataPermissionsSet',\r\n    isInternal: true,\r\n    manifest: mdataPermissionsSet.manifest,\r\n    methods: mdataPermissionsSet\r\n  },\r\n  {\r\n    name: 'safeNfs',\r\n    isInternal: true,\r\n    manifest: nfs.manifest,\r\n    methods: nfs\r\n  }\r\n];\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/index.js\n// module id = 17\n// module chunks = 0","/* eslint-disable import/no-extraneous-dependencies, import/no-unresolved */\r\nconst ipcMain = require('electron').ipcMain; // electron deps will be avaible inside browser\r\n/* eslint-enable import/no-extraneous-dependencies, import/no-unresolved */\r\nconst genRandomString = require('./helpers').genRandomString;\r\n\r\nclass IpcTask {\r\n  constructor() {\r\n    this.tasks = [];\r\n    this.tasksInfo = {};\r\n    this.isProcessing = false;\r\n    this.currentTaskId = null;\r\n    this.currentTaskInfo = null;\r\n    this.currentTaskCb = null;\r\n  }\r\n\r\n  add(info, cb) {\r\n    const token = genRandomString();\r\n    this.tasks.push(token);\r\n    this.tasksInfo[token] = { info, cb };\r\n    this.next();\r\n  }\r\n\r\n  remove() {\r\n    const index = this.tasks.indexOf(this.currentTaskId);\r\n    this.tasks.splice(index, 1);\r\n    delete this.tasksInfo[this.currentTaskId];\r\n    this.isProcessing = false;\r\n    return this;\r\n  }\r\n\r\n  next() {\r\n    if (this.isProcessing || this.tasks.length === 0) {\r\n      return;\r\n    }\r\n    this.isProcessing = true;\r\n    this.currentTaskId = this.tasks[0];\r\n    this.currentTaskInfo = this.tasksInfo[this.currentTaskId].info;\r\n    this.currentTaskCb = this.tasksInfo[this.currentTaskId].cb;\r\n    ipcEvent.sender.send('webClientAuthReq', this.currentTaskInfo);\r\n  }\r\n}\r\n\r\nconst ipcTask = new IpcTask();\r\n\r\nlet ipcEvent = null;\r\n\r\nipcMain.on('registerSafeApp', (event) => {\r\n  ipcEvent = event;\r\n});\r\n\r\nipcMain.on('webClientContainerRes', (event, res) => {\r\n  // handle response\r\n  if (typeof ipcTask.currentTaskCb === 'function') {\r\n    ipcTask.currentTaskCb(null, res);\r\n  }\r\n  ipcTask.remove().next();\r\n});\r\n\r\nipcMain.on('webClientAuthRes', (event, res) => {\r\n  // handle response\r\n  if (typeof ipcTask.currentTaskCb === 'function') {\r\n    ipcTask.currentTaskCb(null, res);\r\n  }\r\n  ipcTask.remove().next();\r\n});\r\n\r\nipcMain.on('webClientErrorRes', (event, err) => {\r\n  // handle Error\r\n  if (typeof ipcTask.currentTaskCb === 'function') {\r\n    ipcTask.currentTaskCb(err);\r\n  }\r\n  ipcTask.remove().next();\r\n});\r\n\r\nmodule.exports.sendAuthReq = (req, cb) => {\r\n  ipcTask.add(req.uri, cb);\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/ipc.js\n// module id = 18\n// module chunks = 0","module.exports = require(\"crypto\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"crypto\"\n// module id = 19\n// module chunks = 0","module.exports = require(\"electron\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"electron\"\n// module id = 20\n// module chunks = 0","module.exports = require(\"safe-app\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"safe-app\"\n// module id = 21\n// module chunks = 0","module.exports = require(\"stream\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"stream\"\n// module id = 22\n// module chunks = 0"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AChEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5EA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;A","sourceRoot":""}