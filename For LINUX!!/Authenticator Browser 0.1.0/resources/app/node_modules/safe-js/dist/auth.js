'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isTokenValid = exports.authorise = exports.manifest = undefined;

var _isomorphicFetch = require('isomorphic-fetch');

var _isomorphicFetch2 = _interopRequireDefault(_isomorphicFetch);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var dnsList = null;

/*
* Manifest for Beaker: 
* https://github.com/pfrazee/beaker/blob/master/doc/authoring-plugins.md#api-manifests
*/
var manifest = exports.manifest = {
    isTokenValid: 'promise',
    authorise: 'promise'
};

var authorise = exports.authorise = function authorise(packageData) {
    if (!packageData) {
        return Promise.reject('packageData is missing.');
    }

    var url = _utils.SERVER + 'auth';

    var authData = {
        app: {
            name: packageData.name,
            id: packageData.id,
            version: packageData.version,
            vendor: packageData.vendor
        },
        permissions: packageData.permissions
    };

    var payload = {
        method: 'POST',
        headers: {
            'content-type': 'application/json'
        },
        body: JSON.stringify(authData)
    };

    return (0, _isomorphicFetch2.default)(url, payload).then(function (response) {
        return (0, _utils.parseResponse)(response);
    });
};

/**
 * Check if a token is valid with the current launcher
 * @param  {string}  token auth token for SAFE
 * @return {Boolean}      is the token valid?
 */
var isTokenValid = exports.isTokenValid = function isTokenValid(token) {

    var url = _utils.SERVER + 'auth';
    var payload = {
        method: 'GET',
        headers: {
            Authorization: 'Bearer ' + token
        }
    };

    return (0, _isomorphicFetch2.default)(url, payload).then(function (response) {
        if (response.status === 200 && response.ok) {
            return Promise.resolve(true);
        } else {
            return Promise.resolve(false);
        }
    });
};