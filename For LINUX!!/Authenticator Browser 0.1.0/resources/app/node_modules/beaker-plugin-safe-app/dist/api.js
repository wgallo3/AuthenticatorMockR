module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 17);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
const crypto = __webpack_require__(19); // electron deps will be available inside browser
const { Readable } = __webpack_require__(22);

const handles = new Map();

const genRandomString = () => (crypto.randomBytes(32).toString('hex'));
/* harmony export (immutable) */ __webpack_exports__["genRandomString"] = genRandomString;


const genHandle = (obj) => {
  const randHandle = genRandomString();
  handles.set(randHandle, obj);
  return randHandle;
};
/* harmony export (immutable) */ __webpack_exports__["genHandle"] = genHandle;


const getObj = (handle) => {
  return new Promise((resolve, reject) => {
    const obj = handles.get(handle);
    if (obj) {
      return resolve(obj);
    }
    return reject(new Error('Invalid handle'));
  });
};
/* harmony export (immutable) */ __webpack_exports__["getObj"] = getObj;


const freeObj = (handle) => {
  handles.delete(handle);
};
/* harmony export (immutable) */ __webpack_exports__["freeObj"] = freeObj;


const forEachHelper = (appToken, containerHandle, sendHandles) => {
  var readable = new Readable({ objectMode: true, read() {} })
  getObj(appToken)
    .then(() => getObj(containerHandle))
    .then((container) => container.forEach((arg1, arg2) => {
        setImmediate(() => {
          if (sendHandles) {
            arg1 = genHandle(arg1);
          }
          let args = [arg1];
          if (arg2) {
            if (sendHandles) {
              arg2 = genHandle(arg2);
            }
            args.push(arg2);
          }
          readable.push(args)
        })
      })
      .then(() => {
        setImmediate(() => {
          readable.push(null)
        })
      })
    );
  return readable;
}
/* harmony export (immutable) */ __webpack_exports__["forEachHelper"] = forEachHelper;



/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

const safeApp = __webpack_require__(21);
const ipc = __webpack_require__(18);
const { genHandle, getObj, freeObj } = __webpack_require__(0);

module.exports.manifest = {
  initialise: 'promise',
  connect: 'promise',
  authorise: 'promise',
  connectAuthorised: 'promise',
  webFetch: 'promise',
  isRegistered: 'promise',
  canAccessContainer: 'promise',
  refreshContainersPermissions: 'promise',
  getContainersNames: 'promise',
  getHomeContainer: 'promise',
  getContainer: 'promise',
  getPubSignKey: 'promise',
  getEncKey: 'promise',
  getSignKeyFromRaw: 'promise',
  getEncKeyKeyFromRaw: 'promise',
  free: 'sync'
};

/**
 * Create a new SAFEApp instance without a connection to the network
 * @returns {Promise<SAFEAppToken>} new instace
 */
module.exports.initialise = (appInfo) => {
  if (this && this.sender) {
    const wholeUrl = this.sender.getURL();
    appInfo.scope = wholeUrl;
  } else {
    appInfo.scope = null;
  }

  return safeApp.initializeApp(appInfo)
    .then(genHandle);
};

/**
 * Create a new, unregistered Session (read-only)
 * @returns {Promise<SAFEAppToken>} same instace
 */
module.exports.connect = (appToken) => {
  return getObj(appToken)
    .then((app) => app.auth.connectUnregistered())
    .then(() => appToken);
};

/**
 * With the options object it can be opt for getting a container
 * for the app itself: opts.own_container=true
 * @returns {Promise<AuthURI>} auth granted URI
 */
module.exports.authorise = (appToken, permissions, options) => {
  return new Promise((resolve, reject) => {
    getObj(appToken)
      .then((app) => app.auth.genAuthUri(permissions, options)
        .then((authReq) => ipc.sendAuthReq(authReq, (err, res) => {
          if (err) {
            return reject(new Error('Unable to authorise the application: ', err)); // TODO send Error in specific
          }
          return resolve(res);
        })))
      .catch(reject);
  });
};

/**
 * Create a new, registered Session (read-write)
 * @returns {Promise<SAFEAppToken>} same instace
 */
module.exports.connectAuthorised = (appToken, authUri) => {
  return getObj(appToken)
    .then((app) => app.auth.loginFromURI(authUri))
    .then((connectedApp) => appToken);
};

/**
 * Authorise container request
 * @returns {Promise<AuthURI>} auth granted URI
 */
module.exports.authoriseContainer = (appToken, permissions) => {
  return new Promise((resolve, reject) => {
    getObj(appToken)
      .then((app) => app.auth.genContainerAuthUri(permissions)
        .then((authReq) => ipc.sendAuthReq(authReq, (err, res) => {
          if (err) {
            return reject(new Error('Unable to authorise the application: ', err)); // TODO send Error in specific
          }
          return resolve(res);
        })))
      .catch(reject);
  });
};

module.exports.webFetch = (appToken, url) => {
  return getObj(appToken)
    .then((app) => app.webFetch(url)
      .then((f) => app.immutableData.fetch(f.dataMapName))
      .then((i) => i.read())
    );
};

/**
 * Whether or not this is a registered/authenticated
 * session.
 *
 * @param {String} appToken - the application token
 * @returns {Boolean} true if this is an authenticated session
 **/
module.exports.isRegistered = (appToken) => {
  return getObj(appToken)
    .then((app) => app.auth.registered);
};

/**
 * Whether or not this session has specifc permission access of a given
 * container.
 * @param {String} appToken - the application token
 * @arg {String} name  name of the container, e.g. `_public`
 * @arg {(String||Array<String>)} [permissions=['Read']] permissions to check for
 * @returns {Promise<Boolean>}
 **/
module.exports.canAccessContainer = (appToken, name, permissions) => {
  return getObj(appToken)
    .then((app) => app.auth.canAccessContainer(name, permissions));
};

/**
 * Refresh permissions for accessible containers from the network. Useful when
 * you just connected or received a response from the authenticator in the IPC protocol.
 * @param {String} appToken - the application token
 */
module.exports.refreshContainersPermissions = (appToken) => {
  return getObj(appToken)
    .then((app) => app.auth.refreshContainersPermissions());
};

/**
 * Get the names of all containers found.
 * @param {String} appToken - the application token
 * @returns {Promise<[String]>} list of containers names
 */
module.exports.getContainersNames = (appToken) => {
  return getObj(appToken)
    .then((app) => app.auth.getContainersNames())
    .then(genHandle);
};

/**
 * Get the MData for the apps own container generated by Authenticator
 * @param appToken
 * @return {*}
 */
module.exports.getHomeContainer = (appToken) => {
  return getObj(appToken)
    .then((app) => app.auth.getHomeContainer())
    .then(genHandle);
};

/**
 * Lookup and return the information necessary to access a container.
 * @param {String} appToken - the application token
 * @arg name {String} name of the container, e.g. `'_public'`
 * @returns {Promise<MutableDataHandle>} the handle for the Mutable Data behind it
 */
module.exports.getContainer = (appToken, name) => {
  return getObj(appToken)
    .then((app) => app.auth.getContainer(name))
    .then(genHandle);
};

/**
 * Get the public signing key of this session
 * @param {String} appToken - the application token
 * @returns {Promise<SignKeyHandle>}
 **/
module.exports.getPubSignKey = (appToken) => {
  return getObj(appToken)
    .then((app) => app.auth.getPubSignKey())
    .then(genHandle);
};

/**
 * Get the public encryption key of this session
 * @param {String} appToken - the application token
 * @returns {Promise<EncKeyHandle>}
 **/
module.exports.getEncKey = (appToken) => {
  return getObj(appToken)
    .then((app) => app.auth.getEncKey())
    .then(genHandle);
};

/**
 * Interprete the SignKey from a given raw string
 * @param {String} appToken - the application token
 * @param {String} raw
 * @returns {Promise<SignKeyHandle>}
 **/
module.exports.getSignKeyFromRaw = (appToken, raw) => {
  return getObj(appToken)
    .then((app) => app.auth.getSignKeyFromRaw(raw))
    .then(genHandle);
};

/**
 * Interprete the encryption Key from a given raw string
 * @param {String} appToken - the application token
 * @arg {String} raw
 * @returns {Promise<EncKeyHandle>}
 **/
module.exports.getEncKeyKeyFromRaw = (appToken, raw) => {
  return getObj(appToken)
    .then((app) => app.auth.getEncKeyKeyFromRaw(raw))
    .then(genHandle);
};

/**
 * Free the SAFEApp instance from memory
 * @param {String} appToken - the application token
 */
module.exports.free = (appToken) => freeObj(appToken);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

const { genHandle, getObj, freeObj } = __webpack_require__(0);

module.exports.manifest = {
  newPlainText: 'promise',
  newSymmetric: 'promise',
  newAsymmetric: 'promise',
  free: 'sync'
};

/**
 * Create a PlainText Cipher Opt
 * @param {String} appToken - the application token
 * @returns {CipherOptHandle}
 **/
module.exports.newPlainText = (appToken) => {
  return getObj(appToken)
    .then((app) => app.cipherOpt.newPlainText())
    .then(genHandle);
};

/**
 * Create a new Symmetric Cipher
 * @param {String} appToken - the application token
 * @returns {CipherOptHandle}
 **/
module.exports.newSymmetric = (appToken) => {
  return getObj(appToken)
    .then((app) => app.cipherOpt.newSymmetric())
    .then(genHandle);
};

/**
 * Create a new Asymmetric Cipher for the given key
 * @param {String} appToken - the application token
 * @param {EncKeyHandle} keyHandle
 * @returns {CipherOptHandle}
 **/
module.exports.newAsymmetric = (appToken, keyHandle) => {
  return getObj(appToken)
    .then((app) => getObj(keyHandle)
      .then((key) => app.cipherOpt.newAsymmetric(key))
      .then(genHandle)
    );
};

/**
 * Free the CipherOpt instance from memory
 * @param {String} cipherOptHandle - the cipher opt handle
 */
module.exports.free = (cipherOptHandle) => freeObj(cipherOptHandle);


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

const { genHandle, getObj } = __webpack_require__(0);

module.exports.manifest = {
  sha3Hash: 'promise',
  getAppPubSignKey: 'promise',
  getAppPubEncKey: 'promise',
  generateEncKeyPair: 'promise',
  getSignKeyFromRaw: 'promise',
  pubEncKeyKeyFromRaw: 'promise'
};

/**
 * Hash the given input with SHA3 Hash
 * @param appToken - the application token
 * @param inpt - input string
 * @return {Promise<Buffer>}
 */
module.exports.sha3Hash = (appToken, inpt) => {
  return getObj(appToken)
    .then((app) => app.crypto.sha3Hash(inpt));
};

/**
 * Get the public signing key
 * @param appToken - the application token
 * @return {Promise<SignKeyHandle>}
 */
module.exports.getAppPubSignKey = (appToken) => {
  return getObj(appToken)
    .then((app) => app.crypto.getAppPubSignKey())
    .then(genHandle);
};

/**
 * Get the public encryption key
 * @param appToken - the application token
 * @return {Promise<PubEncKeyHandle>}
 */
module.exports.getAppPubEncKey = (appToken) => {
  return getObj(appToken)
    .then((app) => app.crypto.getAppPubEncKey())
    .then(genHandle);
};

/**
 * Generate a new Asymmetric EncryptionKeyPair
 * @param appToken - the application token
 * @return {Promise<KeyPairHandle>}
 */
module.exports.generateEncKeyPair = (appToken) => {
  return getObj(appToken)
    .then((app) => app.crypto.generateEncKeyPair())
    .then(genHandle);
};

/**
 * Interpret the SignKey from a given raw string
 * @param appToken - the application token
 * @param raw - raw input string
 * @return {Promise<SignKeyHandle>}
 */
module.exports.getSignKeyFromRaw = (appToken, raw) => {
  return getObj(appToken)
    .then((app) => app.crypto.getSignKeyFromRaw(raw))
    .then(genHandle);
};

/**
 * Interprete the encryption Key from a given raw string
 * @param appToken - the application token
 * @param raw - raw input string
 * @return {Promise<PubEncKeyHandle>}
 */
module.exports.pubEncKeyKeyFromRaw = (appToken, raw) => {
  return getObj(appToken)
    .then((app) => app.crypto.pubEncKeyKeyFromRaw(raw))
    .then(genHandle);
};

/**
 * Interpret the secret encryption Key from a given raw string
 * @param appToken - the application token
 * @param raw - raw input string
 * @return {Promise<SecEncKey>}
 */
module.exports.secEncKeyKeyFromRaw = (appToken, raw) => {
  return getObj(appToken)
    .then((app) => app.crypto.secEncKeyKeyFromRaw(raw))
    .then(genHandle);
};

/**
 * Generate a new Asymmetric EncryptionKeyPair from raw secret and public keys
 * @param appToken - the application token
 * @param rawPublicKey
 * @param rawSecretKey
 * @return {Promise<KeyPair>}
 */
module.exports.generateEncKeyPairFromRaw = (appToken, rawPublicKey, rawSecretKey) => {
  return getObj(appToken)
    .then((app) => app.crypto.generateEncKeyPairFromRaw(rawPublicKey, rawSecretKey))
    .then(genHandle);
};


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

const { genHandle, getObj, freeObj } = __webpack_require__(0);

module.exports.manifest = {
  getPubEncKey: 'promise',
  getSecEncKey: 'promise',
  decryptSealed: 'promise',
  free: 'sync'
};

/**
 * Get the Public Encryption key instance of this keypair
 * @param appToken - application token
 * @param keyPairHandle - keyPair handle
 * @return {Promise<PubEncKey>}
 */
module.exports.getPubEncKey = (appToken, keyPairHandle) => {
  return getObj(appToken)
    .then(() => getObj(keyPairHandle))
    .then((keyPair) => genHandle(keyPair.pubEncKey));
};

/**
 * Get the Secrect Encryption key instance of this keypair
 * @param appToken - application token
 * @param keyPairHandle - keyPair handle
 * @return {Promise<SecEncKey>}
 */
module.exports.getSecEncKey = (appToken, keyPairHandle) => {
  return getObj(appToken)
    .then(() => getObj(keyPairHandle))
    .then((keyPair) => genHandle(keyPair.secEncKey));
};

/**
 * Decrypt the given ciphertext with a seal (buffer or string) using the private and public key
 * @param appToken - application token
 * @param keyPairHandle - keyPair handle
 * @param cipher
 * @return {Promise<Buffer>}
 */
module.exports.decryptSealed = (appToken, keyPairHandle, cipher) => {
  return getObj(appToken)
    .then(() => getObj(keyPairHandle))
    .then((keyPair) => keyPair.decryptSealed(cipher));
};

/**
 * Free the KeyPair instance from memory
 * @param {String} keyPairHandle - the KeyPair handle
 */
module.exports.free = (keyPairHandle) => freeObj(keyPairHandle);


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

const { getObj, freeObj } = __webpack_require__(0);

module.exports.manifest = {
  getRaw: 'promise',
  encryptSealed: 'promise',
  encrypt: 'promise',
  free: 'sync'
};

/**
 * Generate raw string copy of encryption key
 * @param appToken - application token
 * @param pubEncKeyHandle - public encrypted key handle
 * @return {Promise<String>}
 */
module.exports.getRaw = (appToken, pubEncKeyHandle) => {
  return getObj(appToken)
    .then(() => getObj(pubEncKeyHandle))
    .then((pubEncKey) => pubEncKey.getRaw());
};

/**
 * Encrypt the input (buffer or string) using the private and public key with a seal
 * @param appToken - application token
 * @param pubEncKeyHandle - public encrypted key handle
 * @param str
 * @return {Promise<Buffer>}
 */
module.exports.encryptSealed = (appToken, pubEncKeyHandle, str) => {
  return getObj(appToken)
    .then(() => getObj(pubEncKeyHandle))
    .then((pubEncKey) => pubEncKey.encryptSealed(str));
};

/**
 * Encrypt the input (buffer or string) using the private and public key and the given privateKey
 * @param appToken - application token
 * @param pubEncKeyHandle - public encrypted key handle
 * @param str
 * @param secretKey
 * @return {Promise<Buffer>}
 */
module.exports.encrypt = (appToken, pubEncKeyHandle, str, secretKey) => {
  return getObj(appToken)
    .then(() => getObj(pubEncKeyHandle))
    .then((pubEncKey) => pubEncKey.encrypt(str, secretKey));
};

/**
 * Free the PubEncKey instance from memory
 * @param {String} pubEncKeyHandle - the public encryption key handle
 */
module.exports.free = (pubEncKeyHandle) => freeObj(pubEncKeyHandle);


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

const { getObj, freeObj } = __webpack_require__(0);

module.exports.manifest = {
  getRaw: 'promise',
  decrypt: 'promise',
  free: 'sync'
};

/**
 * Generate raw string copy of encryption key
 * @param appToken - application token
 * @param secEncKeyHandle - secret encrypted key handle
 * @return {Promise<String>}
 */
module.exports.getRaw = (appToken, secEncKeyHandle) => {
  return getObj(appToken)
    .then(() => getObj(secEncKeyHandle))
    .then((secEncKey) => secEncKey.getRaw());
};

/**
 * Decrypt the given ciphertext (buffer or string) using the private and public key
 * @param appToken - application token
 * @param secEncKeyHandle - secret encrypted key handle
 * @param cipher
 * @param theirPubKey
 * @return {Promise<Buffer>}
 */
module.exports.decrypt = (appToken, secEncKeyHandle, cipher, theirPubKey) => {
  return getObj(appToken)
    .then(() => getObj(secEncKeyHandle))
    .then((secEncKey) => secEncKey.decrypt(cipher, theirPubKey));
};

/**
 * Free the SecEncKey instance from memory
 * @param {String} secEncKeyHandle - the secret encryption key handle
 */
module.exports.free = (secEncKeyHandle) => freeObj(secEncKeyHandle);


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

const { getObj, freeObj } = __webpack_require__(0);

module.exports.manifest = {
  getRaw: 'promise',
  free: 'sync'
};

/**
 * Generate raw string copy of encryption key
 * @param appToken - application token
 * @param signKeyHandle - public encrypted key handle
 * @return {Promise<String>}
 */
module.exports.getRaw = (appToken, signKeyHandle) => {
  return getObj(appToken)
    .then(() => getObj(signKeyHandle))
    .then((signKey) => signKey.getRaw());
};

/**
 * Free the SignKey instance from memory
 * @param {String} signKeyHandle - the SignKey handle
 */
module.exports.free = (signKeyHandle) => freeObj(signKeyHandle);


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

const { genHandle, getObj, freeObj } = __webpack_require__(0);

module.exports.manifest = {
  create: 'promise',
  fetch: 'promise',
  insert: 'promise',
  update: 'promise',
  getFileMeta: 'promise',
  free: 'sync'
};

module.exports.create = (appToken, nfsHandle, content) => {
  return getObj(appToken)
    .then(() => getObj(nfsHandle))
    .then((nfs) => nfs.create(content))
    .then(genHandle);
};

module.exports.fetch = (appToken, nfsHandle, fileName) => {
  return getObj(appToken)
    .then(() => getObj(nfsHandle))
    .then((nfs) => nfs.fetch(fileName))
    .then(genHandle);
};

module.exports.insert = (appToken, nfsHandle, fileHandle, fileName) => {
  return getObj(appToken)
    .then(() => getObj(nfsHandle))
    .then((nfs) => {
      return getObj(fileHandle).then((file) => nfs.insert(fileName, file));
    })
    .then(() => fileHandle);
};

module.exports.update = (appToken, nfsHandle, fileHandle, fileName, version) => {
  return getObj(appToken)
    .then(() => getObj(nfsHandle))
    .then((nfs) => {
      return getObj(fileHandle).then((file) => nfs.update(fileName, file, version));
    })
    .then(() => fileHandle);
};

module.exports.getFileMeta = (fileHandle) => {
  return getObj(fileHandle).then((file) => (
    {
      dataMapName: file.dataMapName,
      created: file.created,
      modified: file.modified,
      size: file.size,
      version: file.version
    }
  ))
};

/**
 * Free the File instance from memory
 * @param {String} fileHandle - the File handle
 */
module.exports.free = (fileHandle) => freeObj(fileHandle);


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

const { genHandle, getObj, freeObj } = __webpack_require__(0);

module.exports.manifest = {
  create: 'promise',
  fetch: 'promise',
  write: 'promise',
  closeWriter: 'promise',
  read: 'promise',
  size: 'promise',
  closeReader: 'promise',
};

/**
 * Create a new ImmutableData Writer
 * @param {String} appToken - the application token
 * @returns {Promise<Handle>} - the ImmutableData Writer Handle
 **/
module.exports.create = (appToken) => {
  return getObj(appToken)
    .then((app) => app.immutableData.create())
    .then(genHandle);
};

/**
 * Look up an existing Immutable Data for the given address
 * @param {String} appToken - the application token
 * @param {Buffer} address - the XorName on the network
 * @returns {Promise<Handle>} - the ImmutableData Reader Handle
 **/
module.exports.fetch = (appToken, address) => {
  return getObj(appToken)
    .then((app) => app.immutableData.fetch(address))
    .then(genHandle);
};

/**
 * Append the given data to immutable Data.
 *
 * @param {String} appToken - the application token
 * @param {Handle} writerHandle - the writer handle
 * @param {String} string
 * @returns {Promise<()>}
 **/
module.exports.write = (appToken, writerHandle, string) => {
  return getObj(appToken)
    .then(() => getObj(writerHandle))
    .then((writer) => writer.write(string));
};

/**
 * Close and write the immutable Data to the network.
 * @param {String} appToken - the application token
 * @param {Handle} writerHandle - the writer handle
 * @returns {Promise<String>} the address to the data once written to the network
 **/
module.exports.closeWriter = (appToken, writerHandle) => {
  return getObj(appToken)
    .then(() => getObj(writerHandle))
    .then((writer) => writer.close())
    .then((addr) => {
      freeObj(writerHandle);
      return addr;
    });
};

/**
 * Read the given amount of bytes from the network
 * @param {String} appToken - the application token
 * @param {Handle} readerHandle - the reader handle
 * @param {Object=} options
 * @param {Number} [options.offset=0] start position
 * @param {Number} [options.end=size] end position or end of data
 **/
module.exports.read = (appToken, readerHandle, options) => {
  return getObj(appToken)
    .then(() => getObj(readerHandle))
    .then((reader) => reader.read(options));
};

/**
 * The size of the mutable data on the network
 * @param {String} appToken - the application token
 * @param {Handle} readerHandle - the reader handle
 * @returns {Promise<Number>} length in bytes
 **/
module.exports.size = (appToken, readerHandle) => {
  return getObj(appToken)
    .then(() => getObj(readerHandle))
    .then((reader) => reader.size());
};

/**
 * Close the Reader handle
 * @param {String} appToken - the application token
 * @param {Handle} readerHandle - the reader handle
 * @returns {Promise<()>}
 */
module.exports.closeReader = (appToken, readerHandle) => {
  return getObj(appToken)
    .then(() => getObj(readerHandle))
    .then((reader) => reader.close())
    .then(() => freeObj(readerHandle));
};


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

const { genHandle, getObj, freeObj } = __webpack_require__(0);

module.exports.manifest = {
  newRandomPrivate: 'promise',
  newRandomPublic: 'promise',
  newPrivate: 'promise',
  newPublic: 'promise',
  newPermissions: 'promise',
  newPermissionSet: 'promise',
  newMutation: 'promise',
  newEntries: 'promise',
  quickSetup: 'promise',
  encryptKey: 'promise',
  encryptValue: 'promise',
  decrypt: 'promise',
  getNameAndTag: 'promise',
  getVersion: 'promise',
  get: 'promise',
  put: 'promise',
  getEntries: 'promise',
  getKeys: 'promise',
  getValues: 'promise',
  getPermissions: 'promise',
  getUserPermissions: 'promise',
  delUserPermissions: 'promise',
  setUserPermissions: 'promise',
  applyEntriesMutation: 'promise',
  serialise: 'promise',
  fromSerial: 'promise',
  emulateAs: 'promise',
  free: 'sync'
};

/**
 * Create a new mutuable data at a random address with private
 * access.
 * @param {String} appToken - the application token
 * @param {Number} typeTag - the typeTag to use
 * @returns {Promise<MutableDataHandle>}
 **/
module.exports.newRandomPrivate = (appToken, typeTag) => {
  return getObj(appToken)
    .then((app) => app.mutableData.newRandomPrivate(typeTag))
    .then(genHandle);
};

/**
 * Create a new mutuable data at a random address with public
 * access.
 * @param {String} appToken - the application token
 * @param {Number} typeTag - the typeTag to use
 * @returns {Promise<MutableDataHandle>}
 **/
module.exports.newRandomPublic = (appToken, typeTag) => {
  return getObj(appToken)
    .then((app) => app.mutableData.newRandomPublic(typeTag))
    .then(genHandle);
};

/**
 * Initiate a mutuable data at the given address with private
 * access.
 * @param {String} appToken - the application token
 * @param {Buffer|String}
 * @param {Number} typeTag - the typeTag to use
 * @returns {Promise<MutableDataHandle>}
 **/
module.exports.newPrivate = (appToken, name, typeTag) => {
  return getObj(appToken)
    .then((app) => app.mutableData.newPrivate(name, typeTag))
    .then(genHandle);
};

/**
 * Initiate a mutuable data at the given address with public
 * access.
 * @param {String} appToken - the application token
 * @param {Buffer|String}
 * @param {Number} typeTag - the typeTag to use
 * @returns {Promise<MutableDataHandle>}
 **/
module.exports.newPublic = (appToken, name, typeTag) => {
  return getObj(appToken)
    .then((app) => app.mutableData.newPublic(name, typeTag))
    .then(genHandle);
};

/**
 * Create a new Permissions object.
 * @param {String} appToken - the application token
 * @returns {Promise<PermissionsHandle>}
 **/
module.exports.newPermissions = (appToken) => {
  return getObj(appToken)
    .then((app) => app.mutableData.newPermissions())
    .then(genHandle);
};

/**
 * Create a new PermissionsSet object.
 * @param {String} appToken - the application token
 * @returns {Promise<PermissionsSetHandle>}
 **/
module.exports.newPermissionSet = (appToken) => {
  return getObj(appToken)
    .then((app) => app.mutableData.newPermissionSet())
    .then(genHandle);
};

/**
 * Create a new Mutation object.
 * @param {String} appToken - the application token
 * @returns {Promise<MutationHandle>}
 **/
module.exports.newMutation = (appToken) => {
  return getObj(appToken)
    .then((app) => app.mutableData.newMutation())
    .then(genHandle);
};

/**
 * Create a new Entries object.
 * @param {String} appToken - the application token
 * @returns {Promise<EntriesHandle>}
 **/
module.exports.newEntries = (appToken) => {
  return getObj(appToken)
    .then((app) => app.mutableData.newEntries())
    .then(genHandle);
};

// MutableData functions
/**
 * Quickly set up a newly (not yet created) MutableData with
 * the app having full-access permissions (and no other).
 *
 * @param {String} appToken - the application token
 * @param {MutableDataHandle} mdHandle - the MutableData handle
 * @param {Object=} data - a key-value payload it should
 *        create the data with
 * @returns {Promise<MutableDataHandle>} - self
 **/
module.exports.quickSetup = (appToken, mdHandle, data) => {
  return getObj(appToken)
    .then(() => getObj(mdHandle))
    .then((md) => md.quickSetup(data))
    .then(() => mdHandle);
};

/**
 * Encrypt the entry key provided as parameter with the encryption key
 * contained in a Private MutableData. If the MutableData is Public, the same
 * (and unencrypted) value is returned.
 *
 * @param {String} appToken - the application token
 * @param {MutableDataHandle} mdHandle - the MutableData handle
 * @param {(String|Buffer)} key - the key you want to encrypt
 * @returns {Promise<Key>} - the encrypted entry key
 **/
module.exports.encryptKey = (appToken, mdHandle, key) => {
  return getObj(appToken)
    .then(() => getObj(mdHandle))
    .then((md) => md.encryptKey(key));
};

/**
 * Encrypt the entry value provided as parameter with the encryption key
 * contained in a Private MutableData. If the MutableData is Public, the same
 * (and unencrypted) value is returned.
 *
 * @param {String} appToken - the application token
 * @param {MutableDataHandle} mdHandle - the MutableData handle
 * @param {(String|Buffer)} value - the data you want to encrypt
 * @returns {Promise<Value>} - the encrypted entry value
 **/
module.exports.encryptValue = (appToken, mdHandle, value) => {
  return getObj(appToken)
    .then(() => getObj(mdHandle))
    .then((md) => md.encryptValue(value));
};

/**
 * Decrypt the entry key/value provided as parameter with the encryption key
 * contained in a Private MutableData.
 *
 * @param {String} appToken - the application token
 * @param {MutableDataHandle} mdHandle - the MutableData handle
 * @param {(String|Buffer)} value - the data you want to decrypt
 * @returns {Promise<Value>} - the decrypted value
 **/
module.exports.decrypt = (appToken, mdHandle, value) => {
  return getObj(appToken)
    .then(() => getObj(mdHandle))
    .then((md) => md.decrypt(value));
};

/**
 * Look up the name and tag of the MutableData as required to look it
 * up on the network.
 *
 * @param {String} appToken - the application token
 * @param {MutableDataHandle} mdHandle - the MutableData handle
 * @returns {Promise<NameAndTag>}
 **/
module.exports.getNameAndTag = (appToken, mdHandle) => {
  return getObj(appToken)
    .then(() => getObj(mdHandle))
    .then((md) => md.getNameAndTag());
};

/**
 * Look up the mutable data object version on the network
 *
 * @param {String} appToken - the application token
 * @param {MutableDataHandle} mdHandle - the MutableData handle
 * @returns {Promise<Number>} the version
 **/
module.exports.getVersion = (appToken, mdHandle) => {
  return getObj(appToken)
    .then(() => getObj(mdHandle))
    .then((md) => md.getVersion());
};

/**
 * Look up the value of a specific key
 *
 * @param {String} appToken - the application token
 * @param {MutableDataHandle} mdHandle - the MutableData handle
 * @param {String} key - the entry's key
 * @returns {Promise<ValueVersion>} - the value at the current version
 **/
module.exports.get = (appToken, mdHandle, key) => {
  return getObj(appToken)
    .then(() => getObj(mdHandle))
    .then((md) => md.get(key));
};

/**
 * Create this MutableData on the network.
 * @param {String} appToken - the application token
 * @param {MutableDataHandle} mdHandle - the MutableData handle
 * @param {PermissionsHandle} permissionsHandle - the permissions to create the mdata with
 * @param {EntriesHandle} entriesHandle - data payload to create the mdata with
 * @returns {Promise<()>}
 **/
module.exports.put = (appToken, mdHandle, permissionsHandle, entriesHandle) => {
  return getObj(appToken)
    .then(() => getObj(mdHandle))
    .then((md) => getObj(permissionsHandle)
      .then((permissions) => getObj(entriesHandle)
        .then((entries) => md.put(permissions, entries))
      ));
};

/**
 * Get a Handle to the entries associated with this mdata
 * @param {String} appToken - the application token
 * @param {MutableDataHandle} mdHandle - the MutableData handle
 * @returns {Promise<(EntriesHandle)>}
 **/
module.exports.getEntries = (appToken, mdHandle) => {
  return getObj(appToken)
    .then(() => getObj(mdHandle))
    .then((md) => md.getEntries())
    .then(genHandle);
};

/**
 * Get a Handle to the keys associated with this mdata
 * @param {String} appToken - the application token
 * @param {MutableDataHandle} mdHandle - the MutableData handle
 * @returns {Promise<(KeysHandle)>}
 **/
module.exports.getKeys = (appToken, mdHandle) => {
  return getObj(appToken)
    .then(() => getObj(mdHandle))
    .then((md) => md.getKeys())
    .then(genHandle);
};

/**
 * Get a Handle to the values associated with this mdata
 * @param {String} appToken - the application token
 * @param {MutableDataHandle} mdHandle - the MutableData handle
 * @returns {Promise<(ValuesHandle)>}
 **/
module.exports.getValues = (appToken, mdHandle) => {
  return getObj(appToken)
    .then(() => getObj(mdHandle))
    .then((md) => md.getValues())
    .then(genHandle);
};

/**
 * Get a Handle to the permissions associated with this mdata
 * @param {String} appToken - the application token
 * @param {MutableDataHandle} mdHandle - the MutableData handle
 * @returns {Promise<(PermissionsHandle)>}
 **/
module.exports.getPermissions = (appToken, mdHandle) => {
  return getObj(appToken)
    .then(() => getObj(mdHandle))
    .then((md) => md.getPermissions())
    .then(genHandle);
};

/**
 * Get a Handle to the permissions associated with this mdata for
 * a specifc key
 * @param {String} appToken - the application token
 * @param {MutableDataHandle} mdHandle - the MutableData handle
 * @param {SignKeyHandle} signKeyHandle - the sign key to look up
 * @returns {Promise<(PermissionsSetHandle)>}
 **/
module.exports.getUserPermissions = (appToken, mdHandle, signKeyHandle) => {
  return getObj(appToken)
    .then(() => getObj(signKeyHandle))
    .then((signKey) => getObj(mdHandle)
      .then((md) => md.getUserPermissions(signKey))
      .then(genHandle)
    );
};

/**
 * Delete the permissions of a specifc key. Directly commits to the network.
 * Requires 'ManagePermissions'-Permission for the app.
 * @param {String} appToken - the application token
 * @param {MutableDataHandle} mdHandle - the MutableData handle
 * @param {SignKeyHandle} signKeyHandle - the sign key to lookup for
 * @param {Number} version - the current version, to confirm you are
 *        actually asking for the right state
 * @returns {Promise} - once finished
 **/
module.exports.delUserPermissions = (appToken, mdHandle, signKeyHandle, version) => {
  return getObj(appToken)
    .then(() => getObj(signKeyHandle))
    .then((signKey) => getObj(mdHandle)
      .then((md) => md.delUserPermissions(signKey, version))
    );
};

/**
 * Set the permissions of a specifc key. Directly commits to the network.
 * Requires 'ManagePermissions'-Permission for the app.
 * @param {String} appToken - the application token
 * @param {MutableDataHandle} mdHandle - the MutableData handle
 * @param {SignKeyHandle} signKeyHandle - the sign key to lookup for
 * @param {PermissionsSetHandle} pmSetHandle - the PermissionsSet to set to
 * @param {Number} version - the current version, to confirm you are
 *        actually asking for the right state
 * @returns {Promise} - once finished
 **/
module.exports.setUserPermissions = (appToken, mdHandle, signKeyHandle, pmSetHandle, version) => {
  return getObj(appToken)
    .then(() => getObj(signKeyHandle)
      .then((signKey) => getObj(pmSetHandle)
        .then((pmSet) => getObj(mdHandle)
          .then((md) => md.setUserPermissions(signKey, pmSet, version))
        )));
};

/**
 * Commit the transaction to the network
 * @param {String} appToken - the application token
 * @param {MutableDataHandle} mdHandle - the MutableData handle
 * @param {MutationHandle} mutationHandle - the Mutation you want to apply
 * @return {Promise}
 **/
module.exports.applyEntriesMutation = (appToken, mdHandle, mutationHandle) => {
  return getObj(appToken)
    .then(() => getObj(mutationHandle))
    .then((mutation) => getObj(mdHandle)
      .then((md) => md.applyEntriesMutation(mutation))
    );
};

/**
 * Serialise the current mdata
 * @param {String} appToken - the application token
 * @param {MutableDataHandle} mdHandle - the MutableData handle
 * @returns {Promise<(String)>}
 **/
module.exports.serialise = (appToken, mdHandle) => {
  return getObj(appToken)
    .then(() => getObj(mdHandle))
    .then((md) => md.serialise());
};

/**
 * Deserialize the mdata
 * @param {String} appToken - the application token
 * @returns {Promise<MutableDataHandle>}
 */
module.exports.fromSerial = (appToken, data) => {
  return getObj(appToken)
    .then((app) => app.mutableData.fromSerial(data))
    .then(genHandle);
};

/**
 * Wrap this MData into a known abstraction. Currently known: `NFS`
 * @param {String} appToken - the application token
 * @param {MutableDataHandle} mdHandle - the MutableData handle
 * @param {String} eml - name of the emulation
 * @returns {EmulationHandle} the Emulation you are asking for
 **/
module.exports.emulateAs = (appToken, mdHandle, eml) => {
  return getObj(appToken)
    .then(() => getObj(mdHandle))
    .then((md) => md.emulateAs(eml))
    .then(genHandle);
};

/**
 * Free the MutableData instance from memory
 * @param {String} mdHandle - the MutableData handle
 */
module.exports.free = (mdHandle) => freeObj(mdHandle);


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

const { genHandle, getObj, freeObj, forEachHelper } = __webpack_require__(0);

module.exports.manifest = {
  len: 'promise',
  get: 'promise',
  _with_cb_forEach: 'readable',
  insert: 'promise',
  mutate: 'promise',
  free: 'sync'
};


/**
 * Get the total number of entries in the Mdata
 * @param {String} appToken - the application token
 * @param {EntriesHandle} entriesHandle - the Entries obj handle
 * @returns {Promise<Number>}
 **/
module.exports.len = (appToken, entriesHandle) => {
  return getObj(appToken)
    .then(() => getObj(entriesHandle))
    .then((entries) => entries.len());
};

/**
 * Look up the value of a specific key
 *
 * @param {String} appToken - the application token
 * @param {EntriesHandle} entriesHandle - the Entries obj handle
 * @param {String} keyName - the entry's key
 * @returns {Promise<ValueVersion>} - the value at the current version
 **/
module.exports.get = (appToken, entriesHandle, keyName) => {
  return getObj(appToken)
    .then(() => getObj(entriesHandle))
    .then((entries) => entries.get(keyName));
};

/**
 * Iterate over the entries, execute the function every time
 * @param {String} appToken - the application token
 * @param {EntriesHandle} entriesHandle - the Entries obj handle
 * @param {function(Buffer, ValueVersion)} fn - the function to call
 * @returns {Promise<()>} - resolves once the iteration is done
 **/
module.exports._with_cb_forEach = (appToken, entriesHandle) => {
  return forEachHelper(appToken, entriesHandle);
};

/**
 * Insert a new entry. Will directly commit that transaction to the network.
 * Will fail if the entry already exists or the current app doesn't have the
 * permissions to edit that mdata.
 *
 * @param {String} appToken - the application token
 * @param {EntriesHandle} entriesHandle - the Entries obj handle
 * @param {(String|Buffer)} keyName - the key you want store the data under
 * @param {(String|Buffer)} value - the data you want to store
 * @returns {Promise<>}
 **/
module.exports.insert = (appToken, entriesHandle, keyName, value) => {
  return getObj(appToken)
    .then(() => getObj(entriesHandle))
    .then((entries) => entries.insert(keyName, value));
};

/**
 * Start a new transaction of mutation of the entries
 * @param {String} appToken - the application token
 * @param {EntriesHandle} entriesHandle - the Entries obj handle
 * @return {Promise<MutationHandle>}
 **/
module.exports.mutate = (appToken, entriesHandle) => {
  return getObj(appToken)
    .then(() => getObj(entriesHandle))
    .then((entries) => entries.mutate())
    .then(genHandle);
};

/**
 * Free the Entries instance from memory
 * @param {String} entriesHandle - the Entries handle
 */
module.exports.free = (entriesHandle) => freeObj(entriesHandle);


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

const { getObj, freeObj, forEachHelper } = __webpack_require__(0);

module.exports.manifest = {
  len: 'promise',
  _with_cb_forEach: 'readable',
  free: 'sync'
};

/**
 * Get the total number of keys in the Mdata
 * @param {String} appToken - the application token
 * @param {KeysHandle} keysHandle - the Keys obj handle
 * @returns {Promise<Number>}
 **/
module.exports.len = (appToken, keysHandle) => {
  return getObj(appToken)
    .then(() => getObj(keysHandle))
    .then((keys) => keys.len());
};

/**
 * Iterate over the value, execute the function every time
 * @param {String} appToken - the application token
 * @param {KeysHandle} keysHandle - the Keys obj handle
 * @param {function(Buffer)} fn - the function to call with the key in the buffer
 * @returns {Promise<()>} - resolves once the iteration is done
 **/
module.exports._with_cb_forEach = (appToken, keysHandle) => {
  return forEachHelper(appToken, keysHandle);
}

/**
 * Free the Keys instance from memory
 * @param {String} keysHandle - the Keys handle
 */
module.exports.free = (keysHandle) => freeObj(keysHandle);


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

const { getObj, freeObj } = __webpack_require__(0);

module.exports.manifest = {
  insert: 'promise',
  remove: 'promise',
  update: 'promise',
  free: 'sync'
};

/**
 * Store a new `Insert`-Action in the transaction.
 *
 * @param {String} appToken - the application token
 * @param {MutationHandle} mutationHandle - the Mutation obj handle
 * @param {(String|Buffer)} keyName
 * @param {(String|Buffer)} value
 * @returns {Promise} resolves once the storing is done
 **/
module.exports.insert = (appToken, mutationHandle, keyName, value) => {
  return getObj(appToken)
    .then(() => getObj(mutationHandle))
    .then((mutation) => mutation.insert(keyName, value));
};

/**
 * Store a new `Remove`-Action in the transaction
 *
 * @param {String} appToken - the application token
 * @param {MutationHandle} mutationHandle - the Mutation obj handle
 * @param {(String|Buffer)} keyName - the key you want to remove
 * @param {Number} version - the current version, to confirm you are
 *        actually asking for the right state
 * @returns {Promise} resolves once the storing is done
 **/
module.exports.remove = (appToken, mutationHandle, keyName, version) => {
  return getObj(appToken)
    .then(() => getObj(mutationHandle))
    .then((mutation) => mutation.remove(keyName, version));
};

/**
 * Store a `Update`-Action in the transaction
 *
 * @param {String} appToken - the application token
 * @param {MutationHandle} mutationHandle - the Mutation obj handle
 * @param {(String|Buffer)} keyName - the key you want to remove
 * @param {(String|Buffer)} value - the value to upate to
 * @param {Number} version - the current version, to confirm you are
 *        actually asking for the right state
 * @returns {Promise} resolves once the storing is done
 **/
module.exports.update = (appToken, mutationHandle, keyName, value, version) => {
  return getObj(appToken)
    .then(() => getObj(mutationHandle))
    .then((mutation) => mutation.update(keyName, value, version));
};

/**
 * Free the Mutation instance from memory
 * @param {String} mutationHandle - the application token
 */
module.exports.free = (mutationHandle) => freeObj(mutationHandle);


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

const { genHandle, getObj, freeObj, forEachHelper } = __webpack_require__(0);

module.exports.manifest = {
  len: 'promise',
  getPermissionsSet: 'promise',
  insertPermissionsSet: 'promise',
  _with_cb_forEach: 'readable',
  free: 'sync'
};

/**
 * Total number of permission entries
 * @param {String} appToken - the application token
 * @param {PermissionsHandle} permissionsHandle - the Permissions obj handle
 * @returns {Promise<Number>}
 **/
module.exports.len = (appToken, permissionsHandle) => {
  return getObj(appToken)
    .then(() => getObj(permissionsHandle))
    .then((permissions) => permissions.len());
};

/**
 * Lookup the permissions of a specifc key
 * @param {String} appToken - the application token
 * @param {PermissionsHandle} permissionsHandle - the Permissions obj handle
 * @param {SignKeyHandle} signKeyHandle - the key to lookup for
 * @returns {Promise<PermissionsSetHandle>} - the permissions set for that key
 **/
module.exports.getPermissionsSet = (appToken, permissionsHandle, signKeyHandle) => {
  return getObj(appToken)
    .then(() => getObj(signKeyHandle))
    .then((signKey) => getObj(permissionsHandle)
      .then((permissions) => permissions.getPermissionSet(signKey))
      .then(genHandle)
    );
};

/**
 * Insert a new permissions to a specifc key. Directly commits to the network.
 * Requires 'ManagePermissions'-Permission for the app.
 * @param {String} appToken - the application token
 * @param {PermissionsHandle} permissionsHandle - the Permissions obj handle
 * @param {SignKeyHandle} signKeyHandle - the key to lookup for
 * @param {PermissionsSetHandle} pmSetHandle - the permissions set you'd like insert
 * @returns {Promise} - once finished
 **/
module.exports.insertPermissionsSet = (appToken, permissionsHandle, signKeyHandle, pmSetHandle) => {
  return getObj(appToken)
    .then(() => getObj(signKeyHandle))
    .then((signKey) => getObj(pmSetHandle)
      .then((pmSet) => getObj(permissionsHandle)
        .then((permissions) => permissions.insertPermissionSet(signKey, pmSet))
      ));
};

/**
 * Iterate over the entries, execute the function every time
 * @param {String} appToken - the application token
 * @param {PermissionsHandle} permissionsHandle - the Permissions obj handle
 * @param {function(Buffer, ValueVersion)} fn - the function to call
 * @returns {Promise<()>} - resolves once the iteration is done
 **/
module.exports._with_cb_forEach = (appToken, permissionsHandle) => {
  return forEachHelper(appToken, permissionsHandle, true);
};

/**
 * Free the Permissions instance from memory
 * @param {String} permissionsHandle - the application token
 */
module.exports.free = (permissionsHandle) => freeObj(permissionsHandle);


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

const { getObj, freeObj } = __webpack_require__(0);

module.exports.manifest = {
  setAllow: 'promise',
  setDeny: 'promise',
  clear: 'promise',
  free: 'sync'
};

/**
 * Set the action as allowed
 * @param {String} appToken - the application token
 * @param {PermissionsSetHandle} permissionsSetHandle - the PermissionsSet obj handle
 * @param {MDataAction} action
 * @returns {Promise}
 **/
module.exports.setAllow = (appToken, permissionsSetHandle, action) => {
  return getObj(appToken)
    .then(() => getObj(permissionsSetHandle))
    .then((pmSet) => pmSet.setAllow(action));
};

/**
 * Set the action as denied
 * @param {String} appToken - the application token
 * @param {PermissionsSetHandle} permissionsSetHandle - the PermissionsSet obj handle
 * @param {MDataAction} action
 * @returns {Promise}
 **/
module.exports.setDeny = (appToken, permissionsSetHandle, action) => {
  return getObj(appToken)
    .then(() => getObj(permissionsSetHandle))
    .then((pmSet) => pmSet.setDeny(action));
};

/**
 * Remove action from the set
 * @param {String} appToken - the application token
 * @param {PermissionsSetHandle} permissionsSetHandle - the PermissionsSet obj handle
 * @param {MDataAction} action
 * @returns {Promise}
 **/
module.exports.clear = (appToken, permissionsSetHandle, action) => {
  return getObj(appToken)
    .then(() => getObj(permissionsSetHandle))
    .then((pmSet) => pmSet.clear(action));
};

/**
 * Free the PermissionsSet instance from memory
 * @param {String} permissionsSetHandle - the application token
 */
module.exports.free = (permissionsSetHandle) => freeObj(permissionsSetHandle);


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

const { getObj, freeObj, forEachHelper } = __webpack_require__(0);

module.exports.manifest = {
  len: 'promise',
  _with_cb_forEach: 'readable',
  free: 'sync'
};

/**
 * Get the total number of values in the Mdata
 * @param {String} appToken - the application token
 * @param {ValuesHandle} valuesHandle - the Values obj handle
 * @returns {Promise<Number>}
 **/
module.exports.len = (appToken, valuesHandle) => {
  return getObj(appToken)
    .then(() => getObj(valuesHandle))
    .then((values) => values.len());
};

/**
 * Iterate over the value, execute the function every time
 * @param {String} appToken - the application token
 * @param {ValuesHandle} valuesHandle - the Values obj handle
 * @param {function(Buffer, ValueVersion)} fn - the function to call
 * @returns {Promise<()>} - resolves once the iteration is done
 **/
module.exports._with_cb_forEach = (appToken, valuesHandle) => {
  return forEachHelper(appToken, valuesHandle);
};

/**
 * Free the Values instance from memory
 * @param {String} valuesHandle - the Values handle
 */
module.exports.free = (valuesHandle) => freeObj(valuesHandle);


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

const app = __webpack_require__(1);
const cipherOpt = __webpack_require__(2);
const imdata = __webpack_require__(9);
const crypto = __webpack_require__(3);
const cryptoKeyPair = __webpack_require__(4);
const cryptoSecEncKey = __webpack_require__(6);
const cryptoPubEncKey = __webpack_require__(5);
const cryptoSignKey = __webpack_require__(7);
const mdata = __webpack_require__(10);
const mdataEntries = __webpack_require__(11);
const mdataKeys = __webpack_require__(12);
const mdataValues = __webpack_require__(16);
const mdataMutation = __webpack_require__(13);
const mdataPermissions = __webpack_require__(14);
const mdataPermissionsSet = __webpack_require__(15);
const nfs = __webpack_require__(8);

module.exports = [
  {
    name: 'safeApp',
    isInternal: true,
    manifest: app.manifest,
    methods: app
  },
  {
    name: 'safeCipherOpt',
    isInternal: true,
    manifest: cipherOpt.manifest,
    methods: cipherOpt
  },
  {
    name: 'safeImmutableData',
    isInternal: true,
    manifest: imdata.manifest,
    methods: imdata
  },
  {
    name: 'safeCrypto',
    isInternal: true,
    manifest: crypto.manifest,
    methods: crypto
  },
  {
    name: 'safeCryptoKeyPair',
    isInternal: true,
    manifest: cryptoKeyPair.manifest,
    methods: cryptoKeyPair
  },
  {
    name: 'safeCryptoSecEncKey',
    isInternal: true,
    manifest: cryptoSecEncKey.manifest,
    methods: cryptoSecEncKey
  },
  {
    name: 'safeCryptoPubEncKey',
    isInternal: true,
    manifest: cryptoPubEncKey.manifest,
    methods: cryptoPubEncKey
  },
  {
    name: 'safeCryptoSignKey',
    isInternal: true,
    manifest: cryptoSignKey.manifest,
    methods: cryptoSignKey
  },
  {
    name: 'safeMutableData',
    isInternal: true,
    manifest: mdata.manifest,
    methods: mdata
  },
  {
    name: 'safeMutableDataEntries',
    isInternal: true,
    manifest: mdataEntries.manifest,
    methods: mdataEntries
  },
  {
    name: 'safeMutableDataKeys',
    isInternal: true,
    manifest: mdataKeys.manifest,
    methods: mdataKeys
  },
  {
    name: 'safeMutableDataValues',
    isInternal: true,
    manifest: mdataValues.manifest,
    methods: mdataValues
  },
  {
    name: 'safeMutableDataMutation',
    isInternal: true,
    manifest: mdataMutation.manifest,
    methods: mdataMutation
  },
  {
    name: 'safeMutableDataPermissions',
    isInternal: true,
    manifest: mdataPermissions.manifest,
    methods: mdataPermissions
  },
  {
    name: 'safeMutableDataPermissionsSet',
    isInternal: true,
    manifest: mdataPermissionsSet.manifest,
    methods: mdataPermissionsSet
  },
  {
    name: 'safeNfs',
    isInternal: true,
    manifest: nfs.manifest,
    methods: nfs
  }
];


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable import/no-extraneous-dependencies, import/no-unresolved */
const ipcMain = __webpack_require__(20).ipcMain; // electron deps will be avaible inside browser
/* eslint-enable import/no-extraneous-dependencies, import/no-unresolved */
const genRandomString = __webpack_require__(0).genRandomString;

class IpcTask {
  constructor() {
    this.tasks = [];
    this.tasksInfo = {};
    this.isProcessing = false;
    this.currentTaskId = null;
    this.currentTaskInfo = null;
    this.currentTaskCb = null;
  }

  add(info, cb) {
    const token = genRandomString();
    this.tasks.push(token);
    this.tasksInfo[token] = { info, cb };
    this.next();
  }

  remove() {
    const index = this.tasks.indexOf(this.currentTaskId);
    this.tasks.splice(index, 1);
    delete this.tasksInfo[this.currentTaskId];
    this.isProcessing = false;
    return this;
  }

  next() {
    if (this.isProcessing || this.tasks.length === 0) {
      return;
    }
    this.isProcessing = true;
    this.currentTaskId = this.tasks[0];
    this.currentTaskInfo = this.tasksInfo[this.currentTaskId].info;
    this.currentTaskCb = this.tasksInfo[this.currentTaskId].cb;
    ipcEvent.sender.send('webClientAuthReq', this.currentTaskInfo);
  }
}

const ipcTask = new IpcTask();

let ipcEvent = null;

ipcMain.on('registerSafeApp', (event) => {
  ipcEvent = event;
});

ipcMain.on('webClientContainerRes', (event, res) => {
  // handle response
  if (typeof ipcTask.currentTaskCb === 'function') {
    ipcTask.currentTaskCb(null, res);
  }
  ipcTask.remove().next();
});

ipcMain.on('webClientAuthRes', (event, res) => {
  // handle response
  if (typeof ipcTask.currentTaskCb === 'function') {
    ipcTask.currentTaskCb(null, res);
  }
  ipcTask.remove().next();
});

ipcMain.on('webClientErrorRes', (event, err) => {
  // handle Error
  if (typeof ipcTask.currentTaskCb === 'function') {
    ipcTask.currentTaskCb(err);
  }
  ipcTask.remove().next();
});

module.exports.sendAuthReq = (req, cb) => {
  ipcTask.add(req.uri, cb);
};


/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = require("electron");

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = require("safe-app");

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ })
/******/ ]);
//# sourceMappingURL=api.js.map